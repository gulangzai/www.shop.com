var IS_CONCAT_BUILD = !0
  , BUILD_LMV_WORKER_URL = "viewer3D.min.js"
  , LMV_WORKER_URL = BUILD_LMV_WORKER_URL
  , ENABLE_DEBUG = !1
  , ENABLE_TRACE = !1
  , ENABLE_INLINE_WORKER = !0;
var _isIE11 = !!navigator.userAgent.match(/Trident\/7\./);
"undefined" !== typeof window && _isIE11 && function() {
    function a(a, c) {
        c = c || {
            bubbles: !1,
            cancelable: !1,
            detail: void 0
        };
        var e = document.createEvent("CustomEvent");
        e.initCustomEvent(a, c.bubbles, c.cancelable, c.detail);
        return e
    }
    a.prototype = window.CustomEvent.prototype;
    window.CustomEvent = a
}
();
ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = function(a, b) {
    !b || b > this.byteLength ? b = this.byteLength : 0 > b && (b = this.byteLength + b,
    0 > b && (b = 0));
    0 > a && (a = this.byteLength + a,
    0 > a && (a = 0));
    if (b <= a)
        return new ArrayBuffer;
    for (var c = b - a, e = new Uint8Array(this,a,c), d = new Uint8Array(c), g = 0; g < c; g++)
        d[g] = e[g];
    return d.buffer
}
);
var METADATA = METADATA || {};
METADATA.Viewer = function(a, b) {
    var c = document.getElementById(a);
    this.container = document.createElement("div");
    this.container.id = a + "-viewer";
    this.container.className = "viewer";
    c.appendChild(this.container);
    this.listeners = {}
}
;
METADATA.Viewer.prototype = {
    initialize: function() {
        throw "void initialize() must be implemented.  For more details, read the Viewer class documentation.";
    },
    load: function(a, b) {
        throw "bool load(urn, function(void)) must be implemented.  For more details, read the Viewer class documentation.";
    },
    uninitialize: function() {
        throw "void uninitialize() must be implemented.  For more details, read the Viewer class documentation.";
    },
    setCameraFromArray: function(a) {
        throw "void setCameraFromArray(params) must be implemented.  For more details, read the Viewer class documentation.";
    },
    setCameraFromFile: function() {
        throw "void setCameraFromFile() must be implemented.  For more details, read the Viewer class documentation.";
    }
};
METADATA.Viewer.prototype.addEventListener = function(a, b) {
    "undefined" == typeof this.listeners[a] && (this.listeners[a] = []);
    this.listeners[a].push(b)
}
;
METADATA.Viewer.prototype.removeEventListener = function(a, b) {
    if (this.listeners[a] instanceof Array)
        for (var c = this.listeners[a], e = 0, d = c.length; e < d; e++)
            if (c[e] === b) {
                c.splice(e, 1);
                break
            }
}
;
METADATA.Viewer.prototype.fireEvent = function(a) {
    "string" == typeof a && (a = {
        type: a
    });
    a.target || (a.target = this);
    if (!a.type)
        throw Error("event type unknown.");
    if (this.listeners[a.type] instanceof Array)
        for (var b = 0, c = this.listeners[a.type].length; b < c; b++)
            this.listeners[a.type][b].call(this, a)
}
;
METADATA.Viewer.prototype.getDimensions = function() {
    if (this.container) {
        var a = this.container.getBoundingClientRect();
        return {
            width: a.width,
            height: a.height
        }
    }
    return null 
}
;
METADATA.Viewer.prototype.resize = function() {}
;
var THREE = {
    REVISION: "66"
};
self.console = self.console || {
    info: function() {},
    log: function() {},
    debug: function() {},
    warn: function() {},
    error: function() {}
};
(function() {
    for (var a = 0, b = ["ms", "moz", "webkit", "o"], c = 0; c < b.length && !self.requestAnimationFrame; ++c)
        self.requestAnimationFrame = self[b[c] + "RequestAnimationFrame"],
        self.cancelAnimationFrame = self[b[c] + "CancelAnimationFrame"] || self[b[c] + "CancelRequestAnimationFrame"];
    void 0 === self.requestAnimationFrame && void 0 !== self.setTimeout && (self.requestAnimationFrame = function(b) {
        var d = Date.now()
          , c = Math.max(0, 16 - (d - a))
          , f = self.setTimeout(function() {
            b(d + c)
        }
        , c);
        a = d + c;
        return f
    }
    );
    void 0 === self.cancelAnimationFrame && void 0 !== 
    self.clearTimeout && (self.cancelAnimationFrame = function(a) {
        self.clearTimeout(a)
    }
    )
}
)();
THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;
THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;
THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;
THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;
THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;
THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;
THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;
THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;
THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;
THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;
THREE.UVMapping = function() {}
;
THREE.CubeReflectionMapping = function() {}
;
THREE.CubeRefractionMapping = function() {}
;
THREE.SphericalReflectionMapping = function() {}
;
THREE.SphericalRefractionMapping = function() {}
;
THREE.RepeatWrapping = 1E3;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;
THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;
THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;
THREE.HalfFloatType = 1099;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;
THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;
THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;
THREE.Color = function(a) {
    return 3 === arguments.length ? this.setRGB(arguments[0], arguments[1], arguments[2]) : this.set(a)
}
;
THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function(a) {
        a instanceof THREE.Color ? this.copy(a) : "number" === typeof a ? this.setHex(a) : "string" === typeof a && this.setStyle(a);
        return this
    },
    setHex: function(a) {
        a = Math.floor(a);
        this.r = (a >> 16 & 255) / 255;
        this.g = (a >> 8 & 255) / 255;
        this.b = (a & 255) / 255;
        return this
    },
    setRGB: function(a, b, c) {
        this.r = a;
        this.g = b;
        this.b = c;
        return this
    },
    setHSL: function(a, b, c) {
        if (0 === b)
            this.r = this.g = this.b = c;
        else {
            var e = function(a, b, f) {
                0 > f && (f += 1);
                1 < f && --f;
                return f < 1 / 6 ? a + 6 * (b - a) * f : 
                .5 > f ? b : f < 2 / 3 ? a + 6 * (b - a) * (2 / 3 - f) : a
            }
            ;
            b = .5 >= c ? c * (1 + b) : c + b - c * b;
            c = 2 * c - b;
            this.r = e(c, b, a + 1 / 3);
            this.g = e(c, b, a);
            this.b = e(c, b, a - 1 / 3)
        }
        return this
    },
    setStyle: function(a) {
        if (/^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test(a))
            return a = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec(a),
            this.r = Math.min(255, parseInt(a[1], 10)) / 255,
            this.g = Math.min(255, parseInt(a[2], 10)) / 255,
            this.b = Math.min(255, parseInt(a[3], 10)) / 255,
            this;
        if (/^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test(a))
            return a = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec(a),
            this.r = 
            Math.min(100, parseInt(a[1], 10)) / 100,
            this.g = Math.min(100, parseInt(a[2], 10)) / 100,
            this.b = Math.min(100, parseInt(a[3], 10)) / 100,
            this;
        if (/^\#([0-9a-f]{6})$/i.test(a))
            return a = /^\#([0-9a-f]{6})$/i.exec(a),
            this.setHex(parseInt(a[1], 16)),
            this;
        if (/^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test(a))
            return a = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec(a),
            this.setHex(parseInt(a[1] + a[1] + a[2] + a[2] + a[3] + a[3], 16)),
            this;
        if (/^(\w+)$/i.test(a))
            return this.setHex(THREE.ColorKeywords[a]),
            this
    },
    copy: function(a) {
        this.r = a.r;
        this.g = 
        a.g;
        this.b = a.b;
        return this
    },
    copyGammaToLinear: function(a) {
        this.r = a.r * a.r;
        this.g = a.g * a.g;
        this.b = a.b * a.b;
        return this
    },
    copyLinearToGamma: function(a) {
        this.r = Math.sqrt(a.r);
        this.g = Math.sqrt(a.g);
        this.b = Math.sqrt(a.b);
        return this
    },
    convertGammaToLinear: function() {
        var a = this.r
          , b = this.g
          , c = this.b;
        this.r = a * a;
        this.g = b * b;
        this.b = c * c;
        return this
    },
    convertLinearToGamma: function() {
        this.r = Math.sqrt(this.r);
        this.g = Math.sqrt(this.g);
        this.b = Math.sqrt(this.b);
        return this
    },
    getHex: function() {
        return 255 * this.r << 16 ^ 255 * this.g << 
        8 ^ 255 * this.b << 0
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice(-6)
    },
    getHSL: function(a) {
        a = a || {
            h: 0,
            s: 0,
            l: 0
        };
        var b = this.r, c = this.g, e = this.b, d = Math.max(b, c, e), g = Math.min(b, c, e), f, k = (g + d) / 2;
        if (g === d)
            g = f = 0;
        else {
            var h = d - g
              , g = .5 >= k ? h / (d + g) : h / (2 - d - g);
            switch (d) {
            case b:
                f = (c - e) / h + (c < e ? 6 : 0);
                break;
            case c:
                f = (e - b) / h + 2;
                break;
            case e:
                f = (b - c) / h + 4
            }
            f /= 6
        }
        a.h = f;
        a.s = g;
        a.l = k;
        return a
    },
    getStyle: function() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    },
    offsetHSL: function(a, 
    b, c) {
        var e = this.getHSL();
        e.h += a;
        e.s += b;
        e.l += c;
        this.setHSL(e.h, e.s, e.l);
        return this
    },
    add: function(a) {
        this.r += a.r;
        this.g += a.g;
        this.b += a.b;
        return this
    },
    addColors: function(a, b) {
        this.r = a.r + b.r;
        this.g = a.g + b.g;
        this.b = a.b + b.b;
        return this
    },
    addScalar: function(a) {
        this.r += a;
        this.g += a;
        this.b += a;
        return this
    },
    multiply: function(a) {
        this.r *= a.r;
        this.g *= a.g;
        this.b *= a.b;
        return this
    },
    multiplyScalar: function(a) {
        this.r *= a;
        this.g *= a;
        this.b *= a;
        return this
    },
    lerp: function(a, b) {
        this.r += (a.r - this.r) * b;
        this.g += (a.g - this.g) * b;
        this.b += (a.b - this.b) * b;
        return this
    },
    equals: function(a) {
        return a.r === this.r && a.g === this.g && a.b === this.b
    },
    fromArray: function(a) {
        this.r = a[0];
        this.g = a[1];
        this.b = a[2];
        return this
    },
    toArray: function() {
        return [this.r, this.g, this.b]
    },
    clone: function() {
        return (new THREE.Color).setRGB(this.r, this.g, this.b)
    }
};
THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
};
THREE.Quaternion = function(a, b, c, e) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._w = void 0 !== e ? e : 1
}
;
THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    _x: 0,
    _y: 0,
    _z: 0,
    _w: 0,
    _euler: void 0,
    _updateEuler: function(a) {
        void 0 !== this._euler && this._euler.setFromQuaternion(this, void 0, !1)
    },
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a;
        this._updateEuler()
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a;
        this._updateEuler()
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a;
        this._updateEuler()
    },
    get w() {
        return this._w
    },
    set w(a) {
        this._w = a;
        this._updateEuler()
    },
    set: function(a, b, c, e) {
        this._x = a;
        this._y = b;
        this._z = c;
        this._w = 
        e;
        this._updateEuler();
        return this
    },
    copy: function(a) {
        this._x = a._x;
        this._y = a._y;
        this._z = a._z;
        this._w = a._w;
        this._updateEuler();
        return this
    },
    setFromEuler: function(a, b) {
        if (!1 === a instanceof THREE.Euler)
            throw Error("ERROR: Quaternion's .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
        var c = Math.cos(a._x / 2)
          , e = Math.cos(a._y / 2)
          , d = Math.cos(a._z / 2)
          , g = Math.sin(a._x / 2)
          , f = Math.sin(a._y / 2)
          , k = Math.sin(a._z / 2);
        "XYZ" === a.order ? (this._x = g * e * d + c * f * k,
        this._y = c * 
        f * d - g * e * k,
        this._z = c * e * k + g * f * d,
        this._w = c * e * d - g * f * k) : "YXZ" === a.order ? (this._x = g * e * d + c * f * k,
        this._y = c * f * d - g * e * k,
        this._z = c * e * k - g * f * d,
        this._w = c * e * d + g * f * k) : "ZXY" === a.order ? (this._x = g * e * d - c * f * k,
        this._y = c * f * d + g * e * k,
        this._z = c * e * k + g * f * d,
        this._w = c * e * d - g * f * k) : "ZYX" === a.order ? (this._x = g * e * d - c * f * k,
        this._y = c * f * d + g * e * k,
        this._z = c * e * k - g * f * d,
        this._w = c * e * d + g * f * k) : "YZX" === a.order ? (this._x = g * e * d + c * f * k,
        this._y = c * f * d + g * e * k,
        this._z = c * e * k - g * f * d,
        this._w = c * e * d - g * f * k) : "XZY" === a.order && (this._x = g * e * d - c * f * k,
        this._y = c * f * d - g * e * k,
        this._z = c * e * k + g * f * d,
        this._w = c * e * d + g * f * k);
        !1 !== b && this._updateEuler();
        return this
    },
    setFromAxisAngle: function(a, b) {
        var c = b / 2
          , e = Math.sin(c);
        this._x = a.x * e;
        this._y = a.y * e;
        this._z = a.z * e;
        this._w = Math.cos(c);
        this._updateEuler();
        return this
    },
    setFromRotationMatrix: function(a) {
        var b = a.elements
          , c = b[0];
        a = b[4];
        var e = b[8]
          , d = b[1]
          , g = b[5]
          , f = b[9]
          , k = b[2]
          , h = b[6]
          , b = b[10]
          , l = c + g + b;
        0 < l ? (c = .5 / Math.sqrt(l + 1),
        this._w = .25 / c,
        this._x = (h - f) * c,
        this._y = (e - k) * c,
        this._z = (d - a) * c) : c > g && c > b ? (c = 2 * Math.sqrt(1 + c - g - b),
        this._w = (h - f) / c,
        this._x = 
        .25 * c,
        this._y = (a + d) / c,
        this._z = (e + k) / c) : g > b ? (c = 2 * Math.sqrt(1 + g - c - b),
        this._w = (e - k) / c,
        this._x = (a + d) / c,
        this._y = .25 * c,
        this._z = (f + h) / c) : (c = 2 * Math.sqrt(1 + b - c - g),
        this._w = (d - a) / c,
        this._x = (e + k) / c,
        this._y = (f + h) / c,
        this._z = .25 * c);
        this._updateEuler();
        return this
    },
    inverse: function() {
        this.conjugate().normalize();
        return this
    },
    conjugate: function() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._updateEuler();
        return this
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    },
    length: function() {
        return Math.sqrt(this._x * 
        this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    },
    normalize: function() {
        var a = this.length();
        0 === a ? (this._z = this._y = this._x = 0,
        this._w = 1) : (a = 1 / a,
        this._x *= a,
        this._y *= a,
        this._z *= a,
        this._w *= a);
        return this
    },
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("DEPRECATED: Quaternion's .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
        this.multiplyQuaternions(a, b)) : this.multiplyQuaternions(this, a)
    },
    multiplyQuaternions: function(a, b) {
        var c = a._x
          , e = a._y
          , d = a._z
          , g = 
        a._w
          , f = b._x
          , k = b._y
          , h = b._z
          , l = b._w;
        this._x = c * l + g * f + e * h - d * k;
        this._y = e * l + g * k + d * f - c * h;
        this._z = d * l + g * h + c * k - e * f;
        this._w = g * l - c * f - e * k - d * h;
        this._updateEuler();
        return this
    },
    multiplyVector3: function(a) {
        console.warn("DEPRECATED: Quaternion's .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.");
        return a.applyQuaternion(this)
    },
    slerp: function(a, b) {
        var c = this._x
          , e = this._y
          , d = this._z
          , g = this._w
          , f = g * a._w + c * a._x + e * a._y + d * a._z;
        0 > f ? (this._w = -a._w,
        this._x = -a._x,
        this._y = -a._y,
        this._z = 
        -a._z,
        f = -f) : this.copy(a);
        if (1 <= f)
            return this._w = g,
            this._x = c,
            this._y = e,
            this._z = d,
            this;
        var k = Math.acos(f)
          , h = Math.sqrt(1 - f * f);
        if (.001 > Math.abs(h))
            return this._w = .5 * (g + this._w),
            this._x = .5 * (c + this._x),
            this._y = .5 * (e + this._y),
            this._z = .5 * (d + this._z),
            this;
        f = Math.sin((1 - b) * k) / h;
        k = Math.sin(b * k) / h;
        this._w = g * f + this._w * k;
        this._x = c * f + this._x * k;
        this._y = e * f + this._y * k;
        this._z = d * f + this._z * k;
        this._updateEuler();
        return this
    },
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._w === this._w
    },
    fromArray: function(a) {
        this._x = 
        a[0];
        this._y = a[1];
        this._z = a[2];
        this._w = a[3];
        this._updateEuler();
        return this
    },
    toArray: function() {
        return [this._x, this._y, this._z, this._w]
    },
    clone: function() {
        return new THREE.Quaternion(this._x,this._y,this._z,this._w)
    }
};
THREE.Quaternion.slerp = function(a, b, c, e) {
    return c.copy(a).slerp(b, e)
}
;
THREE.Vector2 = function(a, b) {
    this.x = a || 0;
    this.y = b || 0
}
;
THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    set: function(a, b) {
        this.x = a;
        this.y = b;
        return this
    },
    setX: function(a) {
        this.x = a;
        return this
    },
    setY: function(a) {
        this.y = a;
        return this
    },
    setComponent: function(a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        return this
    },
    add: function(a, 
    b) {
        if (void 0 !== b)
            return console.warn("DEPRECATED: Vector2's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        return this
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this
    },
    addScalar: function(a) {
        this.x += a;
        this.y += a;
        return this
    },
    sub: function(a, b) {
        if (void 0 !== b)
            return console.warn("DEPRECATED: Vector2's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(a, b);
        this.x -= a.x;
        this.y -= 
        a.y;
        return this
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this
    },
    multiplyScalar: function(a) {
        this.x *= a;
        this.y *= a;
        return this
    },
    divideScalar: function(a) {
        0 !== a ? (a = 1 / a,
        this.x *= a,
        this.y *= a) : this.y = this.x = 0;
        return this
    },
    min: function(a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        return this
    },
    max: function(a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y = a.y);
        return this
    },
    clamp: function(a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        return this
    },
    clampScalar: function() {
        var a, b;
        return function(c, e) {
            void 0 === a && (a = new THREE.Vector2,
            b = new THREE.Vector2);
            a.set(c, c);
            b.set(e, e);
            return this.clamp(a, b)
        }
    }
    (),
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this
    },
    roundToZero: function() {
        this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ? 
        Math.ceil(this.y) : Math.floor(this.y);
        return this
    },
    negate: function() {
        return this.multiplyScalar(-1)
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x;
        a = this.y - a.y;
        return b * b + a * a
    },
    setLength: function(a) {
        var b = 
        this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function(a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        return this
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y
    },
    fromArray: function(a) {
        this.x = a[0];
        this.y = a[1];
        return this
    },
    toArray: function() {
        return [this.x, this.y]
    },
    clone: function() {
        return new THREE.Vector2(this.x,this.y)
    }
};
THREE.Vector3 = function(a, b, c) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0
}
;
THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function(a, b, c) {
        this.x = a;
        this.y = b;
        this.z = c;
        return this
    },
    setX: function(a) {
        this.x = a;
        return this
    },
    setY: function(a) {
        this.y = a;
        return this
    },
    setZ: function(a) {
        this.z = a;
        return this
    },
    setComponent: function(a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        case 2:
            this.z = b;
            break;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw Error("index is out of range: " + 
            a);
        }
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        return this
    },
    add: function(a, b) {
        if (void 0 !== b)
            return console.warn("DEPRECATED: Vector3's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        return this
    },
    addScalar: function(a) {
        this.x += a;
        this.y += a;
        this.z += a;
        return this
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this
    },
    sub: function(a, b) {
        if (void 0 !== b)
            return console.warn("DEPRECATED: Vector3's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        return this
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this
    },
    multiply: function(a, b) {
        if (void 0 !== b)
            return console.warn("DEPRECATED: Vector3's .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),
            this.multiplyVectors(a, b);
        this.x *= a.x;
        this.y *= a.y;
        this.z *= a.z;
        return this
    },
    multiplyScalar: function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return this
    },
    multiplyVectors: function(a, b) {
        this.x = a.x * 
        b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this
    },
    applyEuler: function() {
        var a;
        return function(b) {
            !1 === b instanceof THREE.Euler && console.error("ERROR: Vector3's .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
            void 0 === a && (a = new THREE.Quaternion);
            this.applyQuaternion(a.setFromEuler(b));
            return this
        }
    }
    (),
    applyAxisAngle: function() {
        var a;
        return function(b, c) {
            void 0 === a && (a = new THREE.Quaternion);
            this.applyQuaternion(a.setFromAxisAngle(b, c));
            return this
        }
    }
    (),
    applyMatrix3: function(a) {
        var b = this.x
          , c = this.y
          , e = this.z;
        a = a.elements;
        this.x = a[0] * b + a[3] * c + a[6] * e;
        this.y = a[1] * b + a[4] * c + a[7] * e;
        this.z = a[2] * b + a[5] * c + a[8] * e;
        return this
    },
    applyMatrix4: function(a) {
        var b = this.x
          , c = this.y
          , e = this.z;
        a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * e + a[12];
        this.y = a[1] * b + a[5] * c + a[9] * e + a[13];
        this.z = a[2] * b + a[6] * c + a[10] * e + a[14];
        return this
    },
    applyProjection: function(a) {
        var b = this.x
          , c = this.y
          , e = this.z;
        a = a.elements;
        var d = 1 / (a[3] * b + a[7] * c + a[11] * e + a[15]);
        this.x = (a[0] * b + a[4] * c + a[8] * e + a[12]) * d;
        this.y = 
        (a[1] * b + a[5] * c + a[9] * e + a[13]) * d;
        this.z = (a[2] * b + a[6] * c + a[10] * e + a[14]) * d;
        return this
    },
    applyQuaternion: function(a) {
        var b = this.x
          , c = this.y
          , e = this.z
          , d = a.x
          , g = a.y
          , f = a.z;
        a = a.w;
        var k = a * b + g * e - f * c
          , h = a * c + f * b - d * e
          , l = a * e + d * c - g * b
          , b = -d * b - g * c - f * e;
        this.x = k * a + b * -d + h * -f - l * -g;
        this.y = h * a + b * -g + l * -d - k * -f;
        this.z = l * a + b * -f + k * -g - h * -d;
        return this
    },
    transformDirection: function(a) {
        var b = this.x
          , c = this.y
          , e = this.z;
        a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * e;
        this.y = a[1] * b + a[5] * c + a[9] * e;
        this.z = a[2] * b + a[6] * c + a[10] * e;
        this.normalize();
        return this
    },
    divide: function(a) {
        this.x /= a.x;
        this.y /= a.y;
        this.z /= a.z;
        return this
    },
    divideScalar: function(a) {
        0 !== a ? (a = 1 / a,
        this.x *= a,
        this.y *= a,
        this.z *= a) : this.z = this.y = this.x = 0;
        return this
    },
    min: function(a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        this.z > a.z && (this.z = a.z);
        return this
    },
    max: function(a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y = a.y);
        this.z < a.z && (this.z = a.z);
        return this
    },
    clamp: function(a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        this.z < 
        a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
        return this
    },
    clampScalar: function() {
        var a, b;
        return function(c, e) {
            void 0 === a && (a = new THREE.Vector3,
            b = new THREE.Vector3);
            a.set(c, c, c);
            b.set(e, e, e);
            return this.clamp(a, b)
        }
    }
    (),
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this
    },
    roundToZero: function() {
        this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
        return this
    },
    negate: function() {
        return this.multiplyScalar(-1)
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + 
        Math.abs(this.y) + Math.abs(this.z)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    setLength: function(a) {
        var b = this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function(a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        this.z += (a.z - this.z) * b;
        return this
    },
    cross: function(a, b) {
        if (void 0 !== b)
            return console.warn("DEPRECATED: Vector3's .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
            this.crossVectors(a, b);
        var c = this.x
          , e = this.y
          , d = this.z;
        this.x = 
        e * a.z - d * a.y;
        this.y = d * a.x - c * a.z;
        this.z = c * a.y - e * a.x;
        return this
    },
    crossVectors: function(a, b) {
        var c = a.x
          , e = a.y
          , d = a.z
          , g = b.x
          , f = b.y
          , k = b.z;
        this.x = e * k - d * f;
        this.y = d * g - c * k;
        this.z = c * f - e * g;
        return this
    },
    projectOnVector: function() {
        var a, b;
        return function(c) {
            void 0 === a && (a = new THREE.Vector3);
            a.copy(c).normalize();
            b = this.dot(a);
            return this.copy(a).multiplyScalar(b)
        }
    }
    (),
    projectOnPlane: function() {
        var a;
        return function(b) {
            void 0 === a && (a = new THREE.Vector3);
            a.copy(this).projectOnVector(b);
            return this.sub(a)
        }
    }
    (),
    reflect: function() {
        var a;
        return function(b) {
            void 0 === a && (a = new THREE.Vector3);
            return this.sub(a.copy(b).multiplyScalar(2 * this.dot(b)))
        }
    }
    (),
    angleTo: function(a) {
        a = this.dot(a) / (this.length() * a.length());
        return Math.acos(THREE.Math.clamp(a, -1, 1))
    },
    distanceTo: function(a) {
        return Math.sqrt(this.distanceToSquared(a))
    },
    distanceToSquared: function(a) {
        var b = this.x - a.x
          , c = this.y - a.y;
        a = this.z - a.z;
        return b * b + c * c + a * a
    },
    setEulerFromRotationMatrix: function(a, b) {
        console.error("REMOVED: Vector3's setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.")
    },
    setEulerFromQuaternion: function(a, b) {
        console.error("REMOVED: Vector3's setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.")
    },
    getPositionFromMatrix: function(a) {
        console.warn("DEPRECATED: Vector3's .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code.");
        return this.setFromMatrixPosition(a)
    },
    getScaleFromMatrix: function(a) {
        console.warn("DEPRECATED: Vector3's .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code.");
        return this.setFromMatrixScale(a)
    },
    getColumnFromMatrix: function(a, b) {
        console.warn("DEPRECATED: Vector3's .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code.");
        return this.setFromMatrixColumn(a, b)
    },
    setFromMatrixPosition: function(a) {
        this.x = a.elements[12];
        this.y = a.elements[13];
        this.z = a.elements[14];
        return this
    },
    setFromMatrixScale: function(a) {
        var b = this.set(a.elements[0], a.elements[1], a.elements[2]).length()
          , c = this.set(a.elements[4], a.elements[5], a.elements[6]).length();
        a = this.set(a.elements[8], a.elements[9], a.elements[10]).length();
        this.x = b;
        this.y = c;
        this.z = a;
        return this
    },
    setFromMatrixColumn: function(a, b) {
        var c = 4 * a
          , e = b.elements;
        this.x = e[c];
        this.y = e[c + 1];
        this.z = e[c + 2];
        return this
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z
    },
    fromArray: function(a) {
        this.x = a[0];
        this.y = a[1];
        this.z = a[2];
        return this
    },
    toArray: function() {
        return [this.x, this.y, this.z]
    },
    clone: function() {
        return new THREE.Vector3(this.x,this.y,this.z)
    }
};
THREE.Vector4 = function(a, b, c, e) {
    this.x = a || 0;
    this.y = b || 0;
    this.z = c || 0;
    this.w = void 0 !== e ? e : 1
}
;
THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function(a, b, c, e) {
        this.x = a;
        this.y = b;
        this.z = c;
        this.w = e;
        return this
    },
    setX: function(a) {
        this.x = a;
        return this
    },
    setY: function(a) {
        this.y = a;
        return this
    },
    setZ: function(a) {
        this.z = a;
        return this
    },
    setW: function(a) {
        this.w = a;
        return this
    },
    setComponent: function(a, b) {
        switch (a) {
        case 0:
            this.x = b;
            break;
        case 1:
            this.y = b;
            break;
        case 2:
            this.z = b;
            break;
        case 3:
            this.w = b;
            break;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    getComponent: function(a) {
        switch (a) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw Error("index is out of range: " + a);
        }
    },
    copy: function(a) {
        this.x = a.x;
        this.y = a.y;
        this.z = a.z;
        this.w = void 0 !== a.w ? a.w : 1;
        return this
    },
    add: function(a, b) {
        if (void 0 !== b)
            return console.warn("DEPRECATED: Vector4's .add() now only accepts one argument. Use .addVectors( a, b ) instead."),
            this.addVectors(a, b);
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
        this.w += a.w;
        return this
    },
    addScalar: function(a) {
        this.x += a;
        this.y += a;
        this.z += a;
        this.w += a;
        return this
    },
    addVectors: function(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this
    },
    sub: function(a, b) {
        if (void 0 !== b)
            return console.warn("DEPRECATED: Vector4's .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),
            this.subVectors(a, b);
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
        this.w -= a.w;
        return this
    },
    subVectors: function(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this
    },
    multiplyScalar: function(a) {
        this.x *= a;
        this.y *= a;
        this.z *= a;
        this.w *= a;
        return this
    },
    applyMatrix4: function(a) {
        var b = this.x
          , c = this.y
          , e = this.z
          , d = this.w;
        a = a.elements;
        this.x = a[0] * b + a[4] * c + a[8] * e + a[12] * d;
        this.y = a[1] * b + a[5] * c + a[9] * e + a[13] * d;
        this.z = a[2] * b + a[6] * c + a[10] * e + a[14] * d;
        this.w = a[3] * b + a[7] * c + a[11] * e + a[15] * d;
        return this
    },
    divideScalar: function(a) {
        0 !== a ? (a = 1 / a,
        this.x *= a,
        this.y *= a,
        this.z *= a,
        this.w *= a) : (this.z = this.y = this.x = 0,
        this.w = 1);
        return this
    },
    setAxisAngleFromQuaternion: function(a) {
        this.w = 2 * Math.acos(a.w);
        var b = Math.sqrt(1 - a.w * a.w);
        1E-4 > b ? (this.x = 1,
        this.z = this.y = 0) : (this.x = a.x / b,
        this.y = a.y / b,
        this.z = a.z / b);
        return this
    },
    setAxisAngleFromRotationMatrix: function(a) {
        var b, c, e;
        a = a.elements;
        var d = a[0];
        e = a[4];
        var g = a[8]
          , f = a[1]
          , k = a[5]
          , h = a[9];
        c = a[2];
        b = a[6];
        var l = a[10];
        if (.01 > Math.abs(e - f) && .01 > Math.abs(g - c) && .01 > Math.abs(h - b)) {
            if (.1 > Math.abs(e + f) && .1 > Math.abs(g + c) && .1 > Math.abs(h + b) && .1 > Math.abs(d + k + l - 3))
                return this.set(1, 0, 0, 0),
                this;
            a = Math.PI;
            d = (d + 1) / 2;
            k = (k + 1) / 2;
            l = (l + 1) / 2;
            e = (e + f) / 4;
            g = (g + c) / 4;
            h = (h + b) / 4;
            d > k && d > l ? .01 > d ? (b = 0,
            e = c = .707106781) : (b = Math.sqrt(d),
            c = e / b,
            e = g / b) : k > l ? .01 > k ? (b = .707106781,
            c = 0,
            e = .707106781) : (c = Math.sqrt(k),
            b = e / c,
            e = h / c) : .01 > l ? (c = b = .707106781,
            e = 0) : (e = Math.sqrt(l),
            b = g / e,
            c = h / e);
            this.set(b, c, e, a);
            return this
        }
        a = Math.sqrt((b - h) * (b - h) + (g - c) * (g - c) + (f - e) * (f - e));
        .001 > Math.abs(a) && (a = 1);
        this.x = (b - h) / a;
        this.y = (g - c) / a;
        this.z = (f - e) / a;
        this.w = Math.acos((d + k + l - 1) / 2);
        return this
    },
    min: function(a) {
        this.x > a.x && (this.x = a.x);
        this.y > a.y && (this.y = a.y);
        this.z > a.z && (this.z = a.z);
        this.w > a.w && (this.w = a.w);
        return this
    },
    max: function(a) {
        this.x < a.x && (this.x = a.x);
        this.y < a.y && (this.y = a.y);
        this.z < a.z && 
        (this.z = a.z);
        this.w < a.w && (this.w = a.w);
        return this
    },
    clamp: function(a, b) {
        this.x < a.x ? this.x = a.x : this.x > b.x && (this.x = b.x);
        this.y < a.y ? this.y = a.y : this.y > b.y && (this.y = b.y);
        this.z < a.z ? this.z = a.z : this.z > b.z && (this.z = b.z);
        this.w < a.w ? this.w = a.w : this.w > b.w && (this.w = b.w);
        return this
    },
    clampScalar: function() {
        var a, b;
        return function(c, e) {
            void 0 === a && (a = new THREE.Vector4,
            b = new THREE.Vector4);
            a.set(c, c, c, c);
            b.set(e, e, e, e);
            return this.clamp(a, b)
        }
    }
    (),
    floor: function() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this
    },
    ceil: function() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this
    },
    round: function() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this
    },
    roundToZero: function() {
        this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x);
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y);
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z);
        this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w);
        return this
    },
    negate: function() {
        return this.multiplyScalar(-1)
    },
    dot: function(a) {
        return this.x * a.x + this.y * a.y + this.z * a.z + this.w * a.w
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    setLength: function(a) {
        var b = this.length();
        0 !== b && a !== b && this.multiplyScalar(a / b);
        return this
    },
    lerp: function(a, b) {
        this.x += (a.x - this.x) * b;
        this.y += (a.y - this.y) * b;
        this.z += (a.z - this.z) * b;
        this.w += (a.w - this.w) * b;
        return this
    },
    equals: function(a) {
        return a.x === this.x && a.y === this.y && a.z === this.z && a.w === this.w
    },
    fromArray: function(a) {
        this.x = a[0];
        this.y = a[1];
        this.z = a[2];
        this.w = a[3];
        return this
    },
    toArray: function() {
        return [this.x, this.y, this.z, this.w]
    },
    clone: function() {
        return new THREE.Vector4(this.x,this.y,this.z,
        this.w)
    }
};
THREE.Euler = function(a, b, c, e) {
    this._x = a || 0;
    this._y = b || 0;
    this._z = c || 0;
    this._order = e || THREE.Euler.DefaultOrder
}
;
THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" ");
THREE.Euler.DefaultOrder = "XYZ";
THREE.Euler.prototype = {
    constructor: THREE.Euler,
    _x: 0,
    _y: 0,
    _z: 0,
    _order: THREE.Euler.DefaultOrder,
    _quaternion: void 0,
    _updateQuaternion: function() {
        void 0 !== this._quaternion && this._quaternion.setFromEuler(this, !1)
    },
    get x() {
        return this._x
    },
    set x(a) {
        this._x = a;
        this._updateQuaternion()
    },
    get y() {
        return this._y
    },
    set y(a) {
        this._y = a;
        this._updateQuaternion()
    },
    get z() {
        return this._z
    },
    set z(a) {
        this._z = a;
        this._updateQuaternion()
    },
    get order() {
        return this._order
    },
    set order(a) {
        this._order = a;
        this._updateQuaternion()
    },
    set: function(a, b, c, e) {
        this._x = a;
        this._y = b;
        this._z = c;
        this._order = e || this._order;
        this._updateQuaternion();
        return this
    },
    copy: function(a) {
        this._x = a._x;
        this._y = a._y;
        this._z = a._z;
        this._order = a._order;
        this._updateQuaternion();
        return this
    },
    setFromRotationMatrix: function(a, b) {
        function c(a) {
            return Math.min(Math.max(a, -1), 1)
        }
        var e = a.elements
          , d = e[0]
          , g = e[4]
          , f = e[8]
          , k = e[1]
          , h = e[5]
          , l = e[9]
          , m = e[2]
          , n = e[6]
          , e = e[10];
        b = b || this._order;
        "XYZ" === b ? (this._y = Math.asin(c(f)),
        .99999 > Math.abs(f) ? (this._x = Math.atan2(-l, e),
        this._z = 
        Math.atan2(-g, d)) : (this._x = Math.atan2(n, h),
        this._z = 0)) : "YXZ" === b ? (this._x = Math.asin(-c(l)),
        .99999 > Math.abs(l) ? (this._y = Math.atan2(f, e),
        this._z = Math.atan2(k, h)) : (this._y = Math.atan2(-m, d),
        this._z = 0)) : "ZXY" === b ? (this._x = Math.asin(c(n)),
        .99999 > Math.abs(n) ? (this._y = Math.atan2(-m, e),
        this._z = Math.atan2(-g, h)) : (this._y = 0,
        this._z = Math.atan2(k, d))) : "ZYX" === b ? (this._y = Math.asin(-c(m)),
        .99999 > Math.abs(m) ? (this._x = Math.atan2(n, e),
        this._z = Math.atan2(k, d)) : (this._x = 0,
        this._z = Math.atan2(-g, h))) : "YZX" === b ? (this._z = 
        Math.asin(c(k)),
        .99999 > Math.abs(k) ? (this._x = Math.atan2(-l, h),
        this._y = Math.atan2(-m, d)) : (this._x = 0,
        this._y = Math.atan2(f, e))) : "XZY" === b ? (this._z = Math.asin(-c(g)),
        .99999 > Math.abs(g) ? (this._x = Math.atan2(n, h),
        this._y = Math.atan2(f, d)) : (this._x = Math.atan2(-l, e),
        this._y = 0)) : console.warn("WARNING: Euler.setFromRotationMatrix() given unsupported order: " + b);
        this._order = b;
        this._updateQuaternion();
        return this
    },
    setFromQuaternion: function(a, b, c) {
        function e(a) {
            return Math.min(Math.max(a, -1), 1)
        }
        var d = a.x * a.x
          , g = a.y * 
        a.y
          , f = a.z * a.z
          , k = a.w * a.w;
        b = b || this._order;
        "XYZ" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.y * a.z), k - d - g + f),
        this._y = Math.asin(e(2 * (a.x * a.z + a.y * a.w))),
        this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), k + d - g - f)) : "YXZ" === b ? (this._x = Math.asin(e(2 * (a.x * a.w - a.y * a.z))),
        this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), k - d - g + f),
        this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), k - d + g - f)) : "ZXY" === b ? (this._x = Math.asin(e(2 * (a.x * a.w + a.y * a.z))),
        this._y = Math.atan2(2 * (a.y * a.w - a.z * a.x), k - d - g + f),
        this._z = Math.atan2(2 * (a.z * a.w - a.x * a.y), k - d + g - f)) : "ZYX" === b ? 
        (this._x = Math.atan2(2 * (a.x * a.w + a.z * a.y), k - d - g + f),
        this._y = Math.asin(e(2 * (a.y * a.w - a.x * a.z))),
        this._z = Math.atan2(2 * (a.x * a.y + a.z * a.w), k + d - g - f)) : "YZX" === b ? (this._x = Math.atan2(2 * (a.x * a.w - a.z * a.y), k - d + g - f),
        this._y = Math.atan2(2 * (a.y * a.w - a.x * a.z), k + d - g - f),
        this._z = Math.asin(e(2 * (a.x * a.y + a.z * a.w)))) : "XZY" === b ? (this._x = Math.atan2(2 * (a.x * a.w + a.y * a.z), k - d + g - f),
        this._y = Math.atan2(2 * (a.x * a.z + a.y * a.w), k + d - g - f),
        this._z = Math.asin(e(2 * (a.z * a.w - a.x * a.y)))) : console.warn("WARNING: Euler.setFromQuaternion() given unsupported order: " + 
        b);
        this._order = b;
        !1 !== c && this._updateQuaternion();
        return this
    },
    reorder: function() {
        var a = new THREE.Quaternion;
        return function(b) {
            a.setFromEuler(this);
            this.setFromQuaternion(a, b)
        }
    }
    (),
    fromArray: function(a) {
        this._x = a[0];
        this._y = a[1];
        this._z = a[2];
        void 0 !== a[3] && (this._order = a[3]);
        this._updateQuaternion();
        return this
    },
    toArray: function() {
        return [this._x, this._y, this._z, this._order]
    },
    equals: function(a) {
        return a._x === this._x && a._y === this._y && a._z === this._z && a._order === this._order
    },
    clone: function() {
        return new THREE.Euler(this._x,
        this._y,this._z,this._order)
    }
};
THREE.Line3 = function(a, b) {
    this.start = void 0 !== a ? a : new THREE.Vector3;
    this.end = void 0 !== b ? b : new THREE.Vector3
}
;
THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function(a, b) {
        this.start.copy(a);
        this.end.copy(b);
        return this
    },
    copy: function(a) {
        this.start.copy(a.start);
        this.end.copy(a.end);
        return this
    },
    center: function(a) {
        return (a || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
    },
    delta: function(a) {
        return (a || new THREE.Vector3).subVectors(this.end, this.start)
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end)
    },
    distance: function() {
        return this.start.distanceTo(this.end)
    },
    at: function(a, 
    b) {
        var c = b || new THREE.Vector3;
        return this.delta(c).multiplyScalar(a).add(this.start)
    },
    closestPointToPointParameter: function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3;
        return function(c, e) {
            a.subVectors(c, this.start);
            b.subVectors(this.end, this.start);
            var d = b.dot(b)
              , d = b.dot(a) / d;
            e && (d = THREE.Math.clamp(d, 0, 1));
            return d
        }
    }
    (),
    closestPointToPoint: function(a, b, c) {
        a = this.closestPointToPointParameter(a, b);
        c = c || new THREE.Vector3;
        return this.delta(c).multiplyScalar(a).add(this.start)
    },
    applyMatrix4: function(a) {
        this.start.applyMatrix4(a);
        this.end.applyMatrix4(a);
        return this
    },
    equals: function(a) {
        return a.start.equals(this.start) && a.end.equals(this.end)
    },
    clone: function() {
        return (new THREE.Line3).copy(this)
    }
};
THREE.Box2 = function(a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector2(Infinity,Infinity);
    this.max = void 0 !== b ? b : new THREE.Vector2(-Infinity,-Infinity)
}
;
THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function(a, b) {
        this.min.copy(a);
        this.max.copy(b);
        return this
    },
    setFromPoints: function(a) {
        if (0 < a.length) {
            var b = a[0];
            this.min.copy(b);
            this.max.copy(b);
            for (var c = 1, e = a.length; c < e; c++)
                b = a[c],
                b.x < this.min.x ? this.min.x = b.x : b.x > this.max.x && (this.max.x = b.x),
                b.y < this.min.y ? this.min.y = b.y : b.y > this.max.y && (this.max.y = b.y)
        } else
            this.makeEmpty();
        return this
    },
    setFromCenterAndSize: function() {
        var a = new THREE.Vector2;
        return function(b, c) {
            var e = a.copy(c).multiplyScalar(.5);
            this.min.copy(b).sub(e);
            this.max.copy(b).add(e);
            return this
        }
    }
    (),
    copy: function(a) {
        this.min.copy(a.min);
        this.max.copy(a.max);
        return this
    },
    makeEmpty: function() {
        this.min.x = this.min.y = Infinity;
        this.max.x = this.max.y = -Infinity;
        return this
    },
    empty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    },
    center: function(a) {
        return (a || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
    },
    size: function(a) {
        return (a || new THREE.Vector2).subVectors(this.max, this.min)
    },
    expandByPoint: function(a) {
        this.min.min(a);
        this.max.max(a);
        return this
    },
    expandByVector: function(a) {
        this.min.sub(a);
        this.max.add(a);
        return this
    },
    expandByScalar: function(a) {
        this.min.addScalar(-a);
        this.max.addScalar(a);
        return this
    },
    containsPoint: function(a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y ? !1 : !0
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y ? !0 : !1
    },
    getParameter: function(a, b) {
        return (b || new THREE.Vector2).set((a.x - this.min.x) / (this.max.x - this.min.x), 
        (a.y - this.min.y) / (this.max.y - this.min.y))
    },
    isIntersectionBox: function(a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y ? !1 : !0
    },
    clampPoint: function(a, b) {
        return (b || new THREE.Vector2).copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function() {
        var a = new THREE.Vector2;
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length()
        }
    }
    (),
    intersect: function(a) {
        this.min.max(a.min);
        this.max.min(a.max);
        return this
    },
    union: function(a) {
        this.min.min(a.min);
        this.max.max(a.max);
        return this
    },
    translate: function(a) {
        this.min.add(a);
        this.max.add(a);
        return this
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    },
    clone: function() {
        return (new THREE.Box2).copy(this)
    }
};
THREE.Box3 = function(a, b) {
    this.min = void 0 !== a ? a : new THREE.Vector3(Infinity,Infinity,Infinity);
    this.max = void 0 !== b ? b : new THREE.Vector3(-Infinity,-Infinity,-Infinity)
}
;
THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function(a, b) {
        this.min.copy(a);
        this.max.copy(b);
        return this
    },
    addPoint: function(a) {
        a.x < this.min.x ? this.min.x = a.x : a.x > this.max.x && (this.max.x = a.x);
        a.y < this.min.y ? this.min.y = a.y : a.y > this.max.y && (this.max.y = a.y);
        a.z < this.min.z ? this.min.z = a.z : a.z > this.max.z && (this.max.z = a.z)
    },
    setFromPoints: function(a) {
        if (0 < a.length) {
            var b = a[0];
            this.min.copy(b);
            this.max.copy(b);
            for (var b = 1, c = a.length; b < c; b++)
                this.addPoint(a[b])
        } else
            this.makeEmpty();
        return this
    },
    setFromCenterAndSize: function() {
        var a = 
        new THREE.Vector3;
        return function(b, c) {
            var e = a.copy(c).multiplyScalar(.5);
            this.min.copy(b).sub(e);
            this.max.copy(b).add(e);
            return this
        }
    }
    (),
    setFromObject: function() {
        var a = new THREE.Vector3;
        return function(b) {
            var c = this;
            b.updateMatrixWorld(!0);
            this.makeEmpty();
            b.traverse(function(b) {
                if (void 0 !== b.geometry && void 0 !== b.geometry.vertices)
                    for (var d = b.geometry.vertices, g = 0, f = d.length; g < f; g++)
                        a.copy(d[g]),
                        a.applyMatrix4(b.matrixWorld),
                        c.expandByPoint(a)
            }
            );
            return this
        }
    }
    (),
    copy: function(a) {
        this.min.copy(a.min);
        this.max.copy(a.max);
        return this
    },
    makeEmpty: function() {
        this.min.x = this.min.y = this.min.z = Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this
    },
    empty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    },
    center: function(a) {
        return (a || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
    },
    size: function(a) {
        return (a || new THREE.Vector3).subVectors(this.max, this.min)
    },
    expandByPoint: function(a) {
        this.min.min(a);
        this.max.max(a);
        return this
    },
    expandByVector: function(a) {
        this.min.sub(a);
        this.max.add(a);
        return this
    },
    expandByScalar: function(a) {
        this.min.addScalar(-a);
        this.max.addScalar(a);
        return this
    },
    containsPoint: function(a) {
        return a.x < this.min.x || a.x > this.max.x || a.y < this.min.y || a.y > this.max.y || a.z < this.min.z || a.z > this.max.z ? !1 : !0
    },
    containsBox: function(a) {
        return this.min.x <= a.min.x && a.max.x <= this.max.x && this.min.y <= a.min.y && a.max.y <= this.max.y && this.min.z <= a.min.z && a.max.z <= this.max.z ? !0 : !1
    },
    getParameter: function(a, b) {
        return (b || new THREE.Vector3).set((a.x - this.min.x) / (this.max.x - 
        this.min.x), (a.y - this.min.y) / (this.max.y - this.min.y), (a.z - this.min.z) / (this.max.z - this.min.z))
    },
    isIntersectionBox: function(a) {
        return a.max.x < this.min.x || a.min.x > this.max.x || a.max.y < this.min.y || a.min.y > this.max.y || a.max.z < this.min.z || a.min.z > this.max.z ? !1 : !0
    },
    clampPoint: function(a, b) {
        return (b || new THREE.Vector3).copy(a).clamp(this.min, this.max)
    },
    distanceToPoint: function() {
        var a = new THREE.Vector3;
        return function(b) {
            return a.copy(b).clamp(this.min, this.max).sub(b).length()
        }
    }
    (),
    getBoundingSphere: function() {
        var a = 
        new THREE.Vector3;
        return function(b) {
            b = b || new THREE.Sphere;
            b.center = this.center();
            b.radius = .5 * this.size(a).length();
            return b
        }
    }
    (),
    intersect: function(a) {
        this.min.max(a.min);
        this.max.min(a.max);
        return this
    },
    union: function(a) {
        this.min.min(a.min);
        this.max.max(a.max);
        return this
    },
    applyMatrix4: function() {
        var a = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
        return function(b) {
            a[0].set(this.min.x, this.min.y, 
            this.min.z).applyMatrix4(b);
            a[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(b);
            a[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(b);
            a[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(b);
            a[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(b);
            a[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(b);
            a[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(b);
            a[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(b);
            this.makeEmpty();
            this.setFromPoints(a);
            return this
        }
    }
    (),
    translate: function(a) {
        this.min.add(a);
        this.max.add(a);
        return this
    },
    equals: function(a) {
        return a.min.equals(this.min) && a.max.equals(this.max)
    },
    clone: function() {
        return (new THREE.Box3).copy(this)
    }
};
THREE.Matrix3 = function(a, b, c, e, d, g, f, k, h) {
    this.elements = new Float32Array(9);
    this.set(void 0 !== a ? a : 1, b || 0, c || 0, e || 0, void 0 !== d ? d : 1, g || 0, f || 0, k || 0, void 0 !== h ? h : 1)
}
;
THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function(a, b, c, e, d, g, f, k, h) {
        var l = this.elements;
        l[0] = a;
        l[3] = b;
        l[6] = c;
        l[1] = e;
        l[4] = d;
        l[7] = g;
        l[2] = f;
        l[5] = k;
        l[8] = h;
        return this
    },
    identity: function() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this
    },
    copy: function(a) {
        a = a.elements;
        this.set(a[0], a[3], a[6], a[1], a[4], a[7], a[2], a[5], a[8]);
        return this
    },
    multiplyVector3: function(a) {
        console.warn("DEPRECATED: Matrix3's .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.");
        return a.applyMatrix3(this)
    },
    multiplyVector3Array: function() {
        var a = new THREE.Vector3;
        return function(b) {
            for (var c = 0, e = b.length; c < e; c += 3)
                a.x = b[c],
                a.y = b[c + 1],
                a.z = b[c + 2],
                a.applyMatrix3(this),
                b[c] = a.x,
                b[c + 1] = a.y,
                b[c + 2] = a.z;
            return b
        }
    }
    (),
    multiplyScalar: function(a) {
        var b = this.elements;
        b[0] *= a;
        b[3] *= a;
        b[6] *= a;
        b[1] *= a;
        b[4] *= a;
        b[7] *= a;
        b[2] *= a;
        b[5] *= a;
        b[8] *= a;
        return this
    },
    determinant: function() {
        var a = this.elements
          , b = a[0]
          , c = a[1]
          , e = a[2]
          , d = a[3]
          , g = a[4]
          , f = a[5]
          , k = a[6]
          , h = a[7]
          , a = a[8];
        return b * g * a - b * f * h - c * d * a + c * f * k + e * d * h - e * g * k
    },
    getInverse: function(a, 
    b) {
        var c = a.elements
          , e = this.elements;
        e[0] = c[10] * c[5] - c[6] * c[9];
        e[1] = -c[10] * c[1] + c[2] * c[9];
        e[2] = c[6] * c[1] - c[2] * c[5];
        e[3] = -c[10] * c[4] + c[6] * c[8];
        e[4] = c[10] * c[0] - c[2] * c[8];
        e[5] = -c[6] * c[0] + c[2] * c[4];
        e[6] = c[9] * c[4] - c[5] * c[8];
        e[7] = -c[9] * c[0] + c[1] * c[8];
        e[8] = c[5] * c[0] - c[1] * c[4];
        c = c[0] * e[0] + c[1] * e[3] + c[2] * e[6];
        if (0 === c) {
            if (b)
                throw Error("Matrix3.getInverse(): can't invert matrix, determinant is 0");
            console.warn("Matrix3.getInverse(): can't invert matrix, determinant is 0");
            this.identity();
            return this
        }
        this.multiplyScalar(1 / 
        c);
        return this
    },
    transpose: function() {
        var a, b = this.elements;
        a = b[1];
        b[1] = b[3];
        b[3] = a;
        a = b[2];
        b[2] = b[6];
        b[6] = a;
        a = b[5];
        b[5] = b[7];
        b[7] = a;
        return this
    },
    getNormalMatrix: function(a) {
        this.getInverse(a).transpose();
        return this
    },
    transposeIntoArray: function(a) {
        var b = this.elements;
        a[0] = b[0];
        a[1] = b[3];
        a[2] = b[6];
        a[3] = b[1];
        a[4] = b[4];
        a[5] = b[7];
        a[6] = b[2];
        a[7] = b[5];
        a[8] = b[8];
        return this
    },
    fromArray: function(a) {
        this.elements.set(a);
        return this
    },
    toArray: function() {
        var a = this.elements;
        return [a[0], a[1], a[2], a[3], a[4], a[5], 
        a[6], a[7], a[8]]
    },
    clone: function() {
        var a = this.elements;
        return new THREE.Matrix3(a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8])
    }
};
THREE.Matrix4 = function(a, b, c, e, d, g, f, k, h, l, m, n, p, t, v, r) {
    var u = this.elements = new Float32Array(16);
    u[0] = void 0 !== a ? a : 1;
    u[4] = b || 0;
    u[8] = c || 0;
    u[12] = e || 0;
    u[1] = d || 0;
    u[5] = void 0 !== g ? g : 1;
    u[9] = f || 0;
    u[13] = k || 0;
    u[2] = h || 0;
    u[6] = l || 0;
    u[10] = void 0 !== m ? m : 1;
    u[14] = n || 0;
    u[3] = p || 0;
    u[7] = t || 0;
    u[11] = v || 0;
    u[15] = void 0 !== r ? r : 1
}
;
THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function(a, b, c, e, d, g, f, k, h, l, m, n, p, t, v, r) {
        var u = this.elements;
        u[0] = a;
        u[4] = b;
        u[8] = c;
        u[12] = e;
        u[1] = d;
        u[5] = g;
        u[9] = f;
        u[13] = k;
        u[2] = h;
        u[6] = l;
        u[10] = m;
        u[14] = n;
        u[3] = p;
        u[7] = t;
        u[11] = v;
        u[15] = r;
        return this
    },
    identity: function() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this
    },
    copy: function(a) {
        this.elements.set(a.elements);
        return this
    },
    extractPosition: function(a) {
        console.warn("DEPRECATED: Matrix4's .extractPosition() has been renamed to .copyPosition().");
        return this.copyPosition(a)
    },
    copyPosition: function(a) {
        var b = this.elements;
        a = a.elements;
        b[12] = a[12];
        b[13] = a[13];
        b[14] = a[14];
        return this
    },
    extractRotation: function() {
        var a = new THREE.Vector3;
        return function(b) {
            var c = this.elements;
            b = b.elements;
            var e = 1 / a.set(b[0], b[1], b[2]).length()
              , d = 1 / a.set(b[4], b[5], b[6]).length()
              , g = 1 / a.set(b[8], b[9], b[10]).length();
            c[0] = b[0] * e;
            c[1] = b[1] * e;
            c[2] = b[2] * e;
            c[4] = b[4] * d;
            c[5] = b[5] * d;
            c[6] = b[6] * d;
            c[8] = b[8] * g;
            c[9] = b[9] * g;
            c[10] = b[10] * g;
            return this
        }
    }
    (),
    makeRotationFromEuler: function(a) {
        !1 === 
        a instanceof THREE.Euler && console.error("ERROR: Matrix's .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.");
        var b = this.elements
          , c = a.x
          , e = a.y
          , d = a.z
          , g = Math.cos(c)
          , c = Math.sin(c)
          , f = Math.cos(e)
          , e = Math.sin(e)
          , k = Math.cos(d)
          , d = Math.sin(d);
        if ("XYZ" === a.order) {
            a = g * k;
            var h = g * d
              , l = c * k
              , m = c * d;
            b[0] = f * k;
            b[4] = -f * d;
            b[8] = e;
            b[1] = h + l * e;
            b[5] = a - m * e;
            b[9] = -c * f;
            b[2] = m - a * e;
            b[6] = l + h * e;
            b[10] = g * f
        } else
            "YXZ" === a.order ? (a = f * k,
            h = f * d,
            l = e * k,
            m = e * d,
            b[0] = a + m * c,
            b[4] = l * c - h,
            b[8] = 
            g * e,
            b[1] = g * d,
            b[5] = g * k,
            b[9] = -c,
            b[2] = h * c - l,
            b[6] = m + a * c,
            b[10] = g * f) : "ZXY" === a.order ? (a = f * k,
            h = f * d,
            l = e * k,
            m = e * d,
            b[0] = a - m * c,
            b[4] = -g * d,
            b[8] = l + h * c,
            b[1] = h + l * c,
            b[5] = g * k,
            b[9] = m - a * c,
            b[2] = -g * e,
            b[6] = c,
            b[10] = g * f) : "ZYX" === a.order ? (a = g * k,
            h = g * d,
            l = c * k,
            m = c * d,
            b[0] = f * k,
            b[4] = l * e - h,
            b[8] = a * e + m,
            b[1] = f * d,
            b[5] = m * e + a,
            b[9] = h * e - l,
            b[2] = -e,
            b[6] = c * f,
            b[10] = g * f) : "YZX" === a.order ? (a = g * f,
            h = g * e,
            l = c * f,
            m = c * e,
            b[0] = f * k,
            b[4] = m - a * d,
            b[8] = l * d + h,
            b[1] = d,
            b[5] = g * k,
            b[9] = -c * k,
            b[2] = -e * k,
            b[6] = h * d + l,
            b[10] = a - m * d) : "XZY" === a.order && (a = g * f,
            h = g * e,
            l = c * f,
            m = c * e,
            b[0] = 
            f * k,
            b[4] = -d,
            b[8] = e * k,
            b[1] = a * d + m,
            b[5] = g * k,
            b[9] = h * d - l,
            b[2] = l * d - h,
            b[6] = c * k,
            b[10] = m * d + a);
        b[3] = 0;
        b[7] = 0;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return this
    },
    setRotationFromQuaternion: function(a) {
        console.warn("DEPRECATED: Matrix4's .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.");
        return this.makeRotationFromQuaternion(a)
    },
    makeRotationFromQuaternion: function(a) {
        var b = this.elements
          , c = a.x
          , e = a.y
          , d = a.z
          , g = a.w
          , f = c + c
          , k = e + e
          , h = d + d;
        a = c * f;
        var l = c * 
        k
          , c = c * h
          , m = e * k
          , e = e * h
          , d = d * h
          , f = g * f
          , k = g * k
          , g = g * h;
        b[0] = 1 - (m + d);
        b[4] = l - g;
        b[8] = c + k;
        b[1] = l + g;
        b[5] = 1 - (a + d);
        b[9] = e - f;
        b[2] = c - k;
        b[6] = e + f;
        b[10] = 1 - (a + m);
        b[3] = 0;
        b[7] = 0;
        b[11] = 0;
        b[12] = 0;
        b[13] = 0;
        b[14] = 0;
        b[15] = 1;
        return this
    },
    lookAt: function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3
          , c = new THREE.Vector3;
        return function(e, d, g) {
            var f = this.elements;
            c.subVectors(e, d).normalize();
            0 === c.length() && (c.z = 1);
            a.crossVectors(g, c).normalize();
            0 === a.length() && (c.x += 1E-4,
            a.crossVectors(g, c).normalize());
            b.crossVectors(c, a);
            f[0] = 
            a.x;
            f[4] = b.x;
            f[8] = c.x;
            f[1] = a.y;
            f[5] = b.y;
            f[9] = c.y;
            f[2] = a.z;
            f[6] = b.z;
            f[10] = c.z;
            return this
        }
    }
    (),
    multiply: function(a, b) {
        return void 0 !== b ? (console.warn("DEPRECATED: Matrix4's .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),
        this.multiplyMatrices(a, b)) : this.multiplyMatrices(this, a)
    },
    multiplyMatrices: function(a, b) {
        var c = a.elements
          , e = b.elements
          , d = this.elements
          , g = c[0]
          , f = c[4]
          , k = c[8]
          , h = c[12]
          , l = c[1]
          , m = c[5]
          , n = c[9]
          , p = c[13]
          , t = c[2]
          , v = c[6]
          , r = c[10]
          , u = c[14]
          , w = c[3]
          , x = c[7]
          , A = c[11]
          , 
        c = c[15]
          , y = e[0]
          , z = e[4]
          , E = e[8]
          , C = e[12]
          , B = e[1]
          , K = e[5]
          , F = e[9]
          , O = e[13]
          , M = e[2]
          , G = e[6]
          , Q = e[10]
          , R = e[14]
          , S = e[3]
          , U = e[7]
          , H = e[11]
          , e = e[15];
        d[0] = g * y + f * B + k * M + h * S;
        d[4] = g * z + f * K + k * G + h * U;
        d[8] = g * E + f * F + k * Q + h * H;
        d[12] = g * C + f * O + k * R + h * e;
        d[1] = l * y + m * B + n * M + p * S;
        d[5] = l * z + m * K + n * G + p * U;
        d[9] = l * E + m * F + n * Q + p * H;
        d[13] = l * C + m * O + n * R + p * e;
        d[2] = t * y + v * B + r * M + u * S;
        d[6] = t * z + v * K + r * G + u * U;
        d[10] = t * E + v * F + r * Q + u * H;
        d[14] = t * C + v * O + r * R + u * e;
        d[3] = w * y + x * B + A * M + c * S;
        d[7] = w * z + x * K + A * G + c * U;
        d[11] = w * E + x * F + A * Q + c * H;
        d[15] = w * C + x * O + A * R + c * e;
        return this
    },
    multiplyToArray: function(a, 
    b, c) {
        var e = this.elements;
        this.multiplyMatrices(a, b);
        c[0] = e[0];
        c[1] = e[1];
        c[2] = e[2];
        c[3] = e[3];
        c[4] = e[4];
        c[5] = e[5];
        c[6] = e[6];
        c[7] = e[7];
        c[8] = e[8];
        c[9] = e[9];
        c[10] = e[10];
        c[11] = e[11];
        c[12] = e[12];
        c[13] = e[13];
        c[14] = e[14];
        c[15] = e[15];
        return this
    },
    multiplyScalar: function(a) {
        var b = this.elements;
        b[0] *= a;
        b[4] *= a;
        b[8] *= a;
        b[12] *= a;
        b[1] *= a;
        b[5] *= a;
        b[9] *= a;
        b[13] *= a;
        b[2] *= a;
        b[6] *= a;
        b[10] *= a;
        b[14] *= a;
        b[3] *= a;
        b[7] *= a;
        b[11] *= a;
        b[15] *= a;
        return this
    },
    multiplyVector3: function(a) {
        console.warn("DEPRECATED: Matrix4's .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.");
        return a.applyProjection(this)
    },
    multiplyVector4: function(a) {
        console.warn("DEPRECATED: Matrix4's .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    multiplyVector3Array: function() {
        var a = new THREE.Vector3;
        return function(b) {
            for (var c = 0, e = b.length; c < e; c += 3)
                a.x = b[c],
                a.y = b[c + 1],
                a.z = b[c + 2],
                a.applyProjection(this),
                b[c] = a.x,
                b[c + 1] = a.y,
                b[c + 2] = a.z;
            return b
        }
    }
    (),
    rotateAxis: function(a) {
        console.warn("DEPRECATED: Matrix4's .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.");
        a.transformDirection(this)
    },
    crossVector: function(a) {
        console.warn("DEPRECATED: Matrix4's .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.");
        return a.applyMatrix4(this)
    },
    determinant: function() {
        var a = this.elements
          , b = a[0]
          , c = a[4]
          , e = a[8]
          , d = a[12]
          , g = a[1]
          , f = a[5]
          , k = a[9]
          , h = a[13]
          , l = a[2]
          , m = a[6]
          , n = a[10]
          , p = a[14];
        return a[3] * (+d * k * m - e * h * m - d * f * n + c * h * n + e * f * p - c * k * p) + a[7] * (+b * k * p - b * h * n + d * g * n - e * g * p + e * h * l - d * k * l) + a[11] * (+b * h * m - b * f * p - d * g * m + c * g * p + d * f * l - c * h * l) + a[15] * (-e * f * l - b * k * m + b * f * n + e * g * m - c * g * 
        n + c * k * l)
    },
    transpose: function() {
        var a = this.elements, b;
        b = a[1];
        a[1] = a[4];
        a[4] = b;
        b = a[2];
        a[2] = a[8];
        a[8] = b;
        b = a[6];
        a[6] = a[9];
        a[9] = b;
        b = a[3];
        a[3] = a[12];
        a[12] = b;
        b = a[7];
        a[7] = a[13];
        a[13] = b;
        b = a[11];
        a[11] = a[14];
        a[14] = b;
        return this
    },
    flattenToArray: function(a) {
        var b = this.elements;
        a[0] = b[0];
        a[1] = b[1];
        a[2] = b[2];
        a[3] = b[3];
        a[4] = b[4];
        a[5] = b[5];
        a[6] = b[6];
        a[7] = b[7];
        a[8] = b[8];
        a[9] = b[9];
        a[10] = b[10];
        a[11] = b[11];
        a[12] = b[12];
        a[13] = b[13];
        a[14] = b[14];
        a[15] = b[15];
        return a
    },
    flattenToArrayOffset: function(a, b) {
        var c = this.elements;
        a[b] = c[0];
        a[b + 1] = c[1];
        a[b + 2] = c[2];
        a[b + 3] = c[3];
        a[b + 4] = c[4];
        a[b + 5] = c[5];
        a[b + 6] = c[6];
        a[b + 7] = c[7];
        a[b + 8] = c[8];
        a[b + 9] = c[9];
        a[b + 10] = c[10];
        a[b + 11] = c[11];
        a[b + 12] = c[12];
        a[b + 13] = c[13];
        a[b + 14] = c[14];
        a[b + 15] = c[15];
        return a
    },
    getPosition: function() {
        var a = new THREE.Vector3;
        return function() {
            console.warn("DEPRECATED: Matrix4's .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.");
            var b = this.elements;
            return a.set(b[12], b[13], b[14])
        }
    }
    (),
    setPosition: function(a) {
        var b = this.elements;
        b[12] = a.x;
        b[13] = a.y;
        b[14] = a.z;
        return this
    },
    getInverse: function(a, b) {
        var c = this.elements
          , e = a.elements
          , d = e[0]
          , g = e[4]
          , f = e[8]
          , k = e[12]
          , h = e[1]
          , l = e[5]
          , m = e[9]
          , n = e[13]
          , p = e[2]
          , t = e[6]
          , v = e[10]
          , r = e[14]
          , u = e[3]
          , w = e[7]
          , x = e[11]
          , e = e[15];
        c[0] = m * r * w - n * v * w + n * t * x - l * r * x - m * t * e + l * v * e;
        c[4] = k * v * w - f * r * w - k * t * x + g * r * x + f * t * e - g * v * e;
        c[8] = f * n * w - k * m * w + k * l * x - g * n * x - f * l * e + g * m * e;
        c[12] = k * m * t - f * n * t - k * l * v + g * n * v + f * l * r - g * m * r;
        c[1] = n * v * u - m * r * u - n * p * x + h * r * x + m * p * e - h * v * e;
        c[5] = f * r * u - k * v * u + k * p * x - d * r * x - f * p * e + d * v * e;
        c[9] = k * m * u - f * n * u - k * h * x + d * n * x + f * h * e - 
        d * m * e;
        c[13] = f * n * p - k * m * p + k * h * v - d * n * v - f * h * r + d * m * r;
        c[2] = l * r * u - n * t * u + n * p * w - h * r * w - l * p * e + h * t * e;
        c[6] = k * t * u - g * r * u - k * p * w + d * r * w + g * p * e - d * t * e;
        c[10] = g * n * u - k * l * u + k * h * w - d * n * w - g * h * e + d * l * e;
        c[14] = k * l * p - g * n * p - k * h * t + d * n * t + g * h * r - d * l * r;
        c[3] = m * t * u - l * v * u - m * p * w + h * v * w + l * p * x - h * t * x;
        c[7] = g * v * u - f * t * u + f * p * w - d * v * w - g * p * x + d * t * x;
        c[11] = f * l * u - g * m * u - f * h * w + d * m * w + g * h * x - d * l * x;
        c[15] = g * m * p - f * l * p + f * h * t - d * m * t - g * h * v + d * l * v;
        c = d * c[0] + h * c[4] + p * c[8] + u * c[12];
        if (0 == c) {
            if (b)
                throw Error("Matrix4.getInverse(): can't invert matrix, determinant is 0");
            console.warn("Matrix4.getInverse(): can't invert matrix, determinant is 0");
            this.identity();
            return this
        }
        this.multiplyScalar(1 / c);
        return this
    },
    translate: function(a) {
        console.warn("DEPRECATED: Matrix4's .translate() has been removed.")
    },
    rotateX: function(a) {
        console.warn("DEPRECATED: Matrix4's .rotateX() has been removed.")
    },
    rotateY: function(a) {
        console.warn("DEPRECATED: Matrix4's .rotateY() has been removed.")
    },
    rotateZ: function(a) {
        console.warn("DEPRECATED: Matrix4's .rotateZ() has been removed.")
    },
    rotateByAxis: function(a, b) {
        console.warn("DEPRECATED: Matrix4's .rotateByAxis() has been removed.")
    },
    scale: function(a) {
        var b = this.elements
          , c = a.x
          , e = a.y;
        a = a.z;
        b[0] *= c;
        b[4] *= e;
        b[8] *= a;
        b[1] *= c;
        b[5] *= e;
        b[9] *= a;
        b[2] *= c;
        b[6] *= e;
        b[10] *= a;
        b[3] *= c;
        b[7] *= e;
        b[11] *= a;
        return this
    },
    getMaxScaleOnAxis: function() {
        var a = this.elements;
        return Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1] + a[2] * a[2], Math.max(a[4] * a[4] + a[5] * a[5] + a[6] * a[6], a[8] * a[8] + a[9] * a[9] + a[10] * a[10])))
    },
    makeTranslation: function(a, b, c) {
        this.set(1, 0, 0, a, 0, 1, 0, b, 0, 0, 1, c, 0, 0, 0, 1);
        return this
    },
    makeRotationX: function(a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        this.set(1, 
        0, 0, 0, 0, b, -a, 0, 0, a, b, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationY: function(a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        this.set(b, 0, a, 0, 0, 1, 0, 0, -a, 0, b, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationZ: function(a) {
        var b = Math.cos(a);
        a = Math.sin(a);
        this.set(b, -a, 0, 0, a, b, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this
    },
    makeRotationAxis: function(a, b) {
        var c = Math.cos(b)
          , e = Math.sin(b)
          , d = 1 - c
          , g = a.x
          , f = a.y
          , k = a.z
          , h = d * g
          , l = d * f;
        this.set(h * g + c, h * f - e * k, h * k + e * f, 0, h * f + e * k, l * f + c, l * k - e * g, 0, h * k - e * f, l * k + e * g, d * k * k + c, 0, 0, 0, 0, 1);
        return this
    },
    makeScale: function(a, b, c) {
        this.set(a, 
        0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, 0, 1);
        return this
    },
    compose: function(a, b, c) {
        this.makeRotationFromQuaternion(b);
        this.scale(c);
        this.setPosition(a);
        return this
    },
    decompose: function() {
        var a = new THREE.Vector3
          , b = new THREE.Matrix4;
        return function(c, e, d) {
            var g = this.elements
              , f = a.set(g[0], g[1], g[2]).length()
              , k = a.set(g[4], g[5], g[6]).length()
              , h = a.set(g[8], g[9], g[10]).length();
            0 > this.determinant() && (f = -f);
            c.x = g[12];
            c.y = g[13];
            c.z = g[14];
            b.elements.set(this.elements);
            c = 1 / f;
            var g = 1 / k
              , l = 1 / h;
            b.elements[0] *= c;
            b.elements[1] *= 
            c;
            b.elements[2] *= c;
            b.elements[4] *= g;
            b.elements[5] *= g;
            b.elements[6] *= g;
            b.elements[8] *= l;
            b.elements[9] *= l;
            b.elements[10] *= l;
            e.setFromRotationMatrix(b);
            d.x = f;
            d.y = k;
            d.z = h;
            return this
        }
    }
    (),
    makeFrustum: function(a, b, c, e, d, g) {
        var f = this.elements;
        f[0] = 2 * d / (b - a);
        f[4] = 0;
        f[8] = (b + a) / (b - a);
        f[12] = 0;
        f[1] = 0;
        f[5] = 2 * d / (e - c);
        f[9] = (e + c) / (e - c);
        f[13] = 0;
        f[2] = 0;
        f[6] = 0;
        f[10] = -(g + d) / (g - d);
        f[14] = -2 * g * d / (g - d);
        f[3] = 0;
        f[7] = 0;
        f[11] = -1;
        f[15] = 0;
        return this
    },
    makePerspective: function(a, b, c, e) {
        a = c * Math.tan(THREE.Math.degToRad(.5 * a));
        var d = -a;
        return this.makeFrustum(d * b, a * b, d, a, c, e)
    },
    makeOrthographic: function(a, b, c, e, d, g) {
        var f = this.elements
          , k = b - a
          , h = c - e
          , l = g - d;
        f[0] = 2 / k;
        f[4] = 0;
        f[8] = 0;
        f[12] = -((b + a) / k);
        f[1] = 0;
        f[5] = 2 / h;
        f[9] = 0;
        f[13] = -((c + e) / h);
        f[2] = 0;
        f[6] = 0;
        f[10] = -2 / l;
        f[14] = -((g + d) / l);
        f[3] = 0;
        f[7] = 0;
        f[11] = 0;
        f[15] = 1;
        return this
    },
    fromArray: function(a) {
        this.elements.set(a);
        return this
    },
    toArray: function() {
        var a = this.elements;
        return [a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15]]
    },
    clone: function() {
        var a = 
        this.elements;
        return new THREE.Matrix4(a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15])
    }
};
THREE.Ray = function(a, b) {
    this.origin = void 0 !== a ? a : new THREE.Vector3;
    this.direction = void 0 !== b ? b : new THREE.Vector3
}
;
THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function(a, b) {
        this.origin.copy(a);
        this.direction.copy(b);
        return this
    },
    copy: function(a) {
        this.origin.copy(a.origin);
        this.direction.copy(a.direction);
        return this
    },
    at: function(a, b) {
        return (b || new THREE.Vector3).copy(this.direction).multiplyScalar(a).add(this.origin)
    },
    recast: function() {
        var a = new THREE.Vector3;
        return function(b) {
            this.origin.copy(this.at(b, a));
            return this
        }
    }
    (),
    closestPointToPoint: function(a, b) {
        var c = b || new THREE.Vector3;
        c.subVectors(a, this.origin);
        var e = c.dot(this.direction);
        return 0 > e ? c.copy(this.origin) : c.copy(this.direction).multiplyScalar(e).add(this.origin)
    },
    distanceToPoint: function() {
        var a = new THREE.Vector3;
        return function(b) {
            var c = a.subVectors(b, this.origin).dot(this.direction);
            if (0 > c)
                return this.origin.distanceTo(b);
            a.copy(this.direction).multiplyScalar(c).add(this.origin);
            return a.distanceTo(b)
        }
    }
    (),
    distanceSqToSegment: function(a, b, c, e) {
        var d = a.clone().add(b).multiplyScalar(.5)
          , g = b.clone().sub(a).normalize()
          , f = .5 * a.distanceTo(b)
          , k = 
        this.origin.clone().sub(d);
        a = -this.direction.dot(g);
        b = k.dot(this.direction);
        var h = -k.dot(g), l = k.lengthSq(), m = Math.abs(1 - a * a), n, p;
        0 <= m ? (k = a * h - b,
        n = a * b - h,
        p = f * m,
        0 <= k ? n >= -p ? n <= p ? (f = 1 / m,
        k *= f,
        n *= f,
        a = k * (k + a * n + 2 * b) + n * (a * k + n + 2 * h) + l) : (n = f,
        k = Math.max(0, -(a * n + b)),
        a = -k * k + n * (n + 2 * h) + l) : (n = -f,
        k = Math.max(0, -(a * n + b)),
        a = -k * k + n * (n + 2 * h) + l) : n <= -p ? (k = Math.max(0, -(-a * f + b)),
        n = 0 < k ? -f : Math.min(Math.max(-f, -h), f),
        a = -k * k + n * (n + 2 * h) + l) : n <= p ? (k = 0,
        n = Math.min(Math.max(-f, -h), f),
        a = n * (n + 2 * h) + l) : (k = Math.max(0, -(a * f + b)),
        n = 0 < k ? f : Math.min(Math.max(-f, 
        -h), f),
        a = -k * k + n * (n + 2 * h) + l)) : (n = 0 < a ? -f : f,
        k = Math.max(0, -(a * n + b)),
        a = -k * k + n * (n + 2 * h) + l);
        c && c.copy(this.direction.clone().multiplyScalar(k).add(this.origin));
        e && e.copy(g.clone().multiplyScalar(n).add(d));
        return a
    },
    isIntersectionSphere: function(a) {
        return this.distanceToPoint(a.center) <= a.radius
    },
    isIntersectionPlane: function(a) {
        var b = a.distanceToPoint(this.origin);
        return 0 === b || 0 > a.normal.dot(this.direction) * b ? !0 : !1
    },
    distanceToPlane: function(a) {
        var b = a.normal.dot(this.direction);
        if (0 == b)
            return 0 == a.distanceToPoint(this.origin) ? 
            0 : null ;
        a = -(this.origin.dot(a.normal) + a.constant) / b;
        return 0 <= a ? a : null 
    },
    intersectPlane: function(a, b) {
        var c = this.distanceToPlane(a);
        return null  === c ? null  : this.at(c, b)
    },
    isIntersectionBox: function() {
        var a = new THREE.Vector3;
        return function(b) {
            return null  !== this.intersectBox(b, a)
        }
    }
    (),
    intersectBox: function(a, b) {
        var c, e, d, g, f;
        e = 1 / this.direction.x;
        g = 1 / this.direction.y;
        f = 1 / this.direction.z;
        var k = this.origin;
        0 <= e ? (c = (a.min.x - k.x) * e,
        e *= a.max.x - k.x) : (c = (a.max.x - k.x) * e,
        e *= a.min.x - k.x);
        0 <= g ? (d = (a.min.y - k.y) * g,
        g *= 
        a.max.y - k.y) : (d = (a.max.y - k.y) * g,
        g *= a.min.y - k.y);
        if (c > g || d > e)
            return null ;
        if (d > c || c !== c)
            c = d;
        if (g < e || e !== e)
            e = g;
        0 <= f ? (d = (a.min.z - k.z) * f,
        f *= a.max.z - k.z) : (d = (a.max.z - k.z) * f,
        f *= a.min.z - k.z);
        if (c > f || d > e)
            return null ;
        if (d > c || c !== c)
            c = d;
        if (f < e || e !== e)
            e = f;
        return 0 > e ? null  : this.at(0 <= c ? c : e, b)
    },
    intersectTriangle: function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3
          , c = new THREE.Vector3
          , e = new THREE.Vector3;
        return function(d, g, f, k, h) {
            b.subVectors(g, d);
            c.subVectors(f, d);
            e.crossVectors(b, c);
            g = this.direction.dot(e);
            if (0 < 
            g) {
                if (k)
                    return null ;
                k = 1
            } else if (0 > g)
                k = -1,
                g = -g;
            else
                return null ;
            a.subVectors(this.origin, d);
            d = k * this.direction.dot(c.crossVectors(a, c));
            if (0 > d)
                return null ;
            f = k * this.direction.dot(b.cross(a));
            if (0 > f || d + f > g)
                return null ;
            d = -k * a.dot(e);
            return 0 > d ? null  : this.at(d / g, h)
        }
    }
    (),
    applyMatrix4: function(a) {
        this.direction.add(this.origin).applyMatrix4(a);
        this.origin.applyMatrix4(a);
        this.direction.sub(this.origin);
        this.direction.normalize();
        return this
    },
    equals: function(a) {
        return a.origin.equals(this.origin) && a.direction.equals(this.direction)
    },
    clone: function() {
        return (new THREE.Ray).copy(this)
    }
};
THREE.Sphere = function(a, b) {
    this.center = void 0 !== a ? a : new THREE.Vector3;
    this.radius = void 0 !== b ? b : 0
}
;
THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function(a, b) {
        this.center.copy(a);
        this.radius = b;
        return this
    },
    setFromPoints: function() {
        var a = new THREE.Box3;
        return function(b, c) {
            var e = this.center;
            void 0 !== c ? e.copy(c) : a.setFromPoints(b).center(e);
            for (var d = 0, g = 0, f = b.length; g < f; g++)
                d = Math.max(d, e.distanceToSquared(b[g]));
            this.radius = Math.sqrt(d);
            return this
        }
    }
    (),
    copy: function(a) {
        this.center.copy(a.center);
        this.radius = a.radius;
        return this
    },
    empty: function() {
        return 0 >= this.radius
    },
    containsPoint: function(a) {
        return a.distanceToSquared(this.center) <= 
        this.radius * this.radius
    },
    distanceToPoint: function(a) {
        return a.distanceTo(this.center) - this.radius
    },
    intersectsSphere: function(a) {
        var b = this.radius + a.radius;
        return a.center.distanceToSquared(this.center) <= b * b
    },
    clampPoint: function(a, b) {
        var c = this.center.distanceToSquared(a)
          , e = b || new THREE.Vector3;
        e.copy(a);
        c > this.radius * this.radius && (e.sub(this.center).normalize(),
        e.multiplyScalar(this.radius).add(this.center));
        return e
    },
    getBoundingBox: function(a) {
        a = a || new THREE.Box3;
        a.set(this.center, this.center);
        a.expandByScalar(this.radius);
        return a
    },
    applyMatrix4: function(a) {
        this.center.applyMatrix4(a);
        this.radius *= a.getMaxScaleOnAxis();
        return this
    },
    translate: function(a) {
        this.center.add(a);
        return this
    },
    equals: function(a) {
        return a.center.equals(this.center) && a.radius === this.radius
    },
    clone: function() {
        return (new THREE.Sphere).copy(this)
    }
};
THREE.Frustum = function(a, b, c, e, d, g) {
    this.planes = [void 0 !== a ? a : new THREE.Plane, void 0 !== b ? b : new THREE.Plane, void 0 !== c ? c : new THREE.Plane, void 0 !== e ? e : new THREE.Plane, void 0 !== d ? d : new THREE.Plane, void 0 !== g ? g : new THREE.Plane]
}
;
THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function(a, b, c, e, d, g) {
        var f = this.planes;
        f[0].copy(a);
        f[1].copy(b);
        f[2].copy(c);
        f[3].copy(e);
        f[4].copy(d);
        f[5].copy(g);
        return this
    },
    copy: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++)
            b[c].copy(a.planes[c]);
        return this
    },
    setFromMatrix: function(a) {
        var b = this.planes
          , c = a.elements;
        a = c[0];
        var e = c[1]
          , d = c[2]
          , g = c[3]
          , f = c[4]
          , k = c[5]
          , h = c[6]
          , l = c[7]
          , m = c[8]
          , n = c[9]
          , p = c[10]
          , t = c[11]
          , v = c[12]
          , r = c[13]
          , u = c[14]
          , c = c[15];
        b[0].setComponents(g - a, l - f, t - m, c - v).normalize();
        b[1].setComponents(g + 
        a, l + f, t + m, c + v).normalize();
        b[2].setComponents(g + e, l + k, t + n, c + r).normalize();
        b[3].setComponents(g - e, l - k, t - n, c - r).normalize();
        b[4].setComponents(g - d, l - h, t - p, c - u).normalize();
        b[5].setComponents(g + d, l + h, t + p, c + u).normalize();
        return this
    },
    intersectsObject: function() {
        var a = new THREE.Sphere;
        return function(b) {
            var c = b.geometry;
            null  === c.boundingSphere && c.computeBoundingSphere();
            a.copy(c.boundingSphere);
            a.applyMatrix4(b.matrixWorld);
            return this.intersectsSphere(a)
        }
    }
    (),
    intersectsSphere: function(a) {
        var b = this.planes
          , 
        c = a.center;
        a = -a.radius;
        for (var e = 0; 6 > e; e++)
            if (b[e].distanceToPoint(c) < a)
                return !1;
        return !0
    },
    intersectsBox: function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3;
        return function(c) {
            for (var e = this.planes, d = 0; 6 > d; d++) {
                var g = e[d];
                a.x = 0 < g.normal.x ? c.min.x : c.max.x;
                b.x = 0 < g.normal.x ? c.max.x : c.min.x;
                a.y = 0 < g.normal.y ? c.min.y : c.max.y;
                b.y = 0 < g.normal.y ? c.max.y : c.min.y;
                a.z = 0 < g.normal.z ? c.min.z : c.max.z;
                b.z = 0 < g.normal.z ? c.max.z : c.min.z;
                var f = g.distanceToPoint(a)
                  , g = g.distanceToPoint(b);
                if (0 > f && 0 > g)
                    return !1
            }
            return !0
        }
    }
    (),
    containsPoint: function(a) {
        for (var b = this.planes, c = 0; 6 > c; c++)
            if (0 > b[c].distanceToPoint(a))
                return !1;
        return !0
    },
    clone: function() {
        return (new THREE.Frustum).copy(this)
    }
};
THREE.Plane = function(a, b) {
    this.normal = void 0 !== a ? a : new THREE.Vector3(1,0,0);
    this.constant = void 0 !== b ? b : 0
}
;
THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function(a, b) {
        this.normal.copy(a);
        this.constant = b;
        return this
    },
    setComponents: function(a, b, c, e) {
        this.normal.set(a, b, c);
        this.constant = e;
        return this
    },
    setFromNormalAndCoplanarPoint: function(a, b) {
        this.normal.copy(a);
        this.constant = -b.dot(this.normal);
        return this
    },
    setFromCoplanarPoints: function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3;
        return function(c, e, d) {
            e = a.subVectors(d, e).cross(b.subVectors(c, e)).normalize();
            this.setFromNormalAndCoplanarPoint(e, 
            c);
            return this
        }
    }
    (),
    copy: function(a) {
        this.normal.copy(a.normal);
        this.constant = a.constant;
        return this
    },
    normalize: function() {
        var a = 1 / this.normal.length();
        this.normal.multiplyScalar(a);
        this.constant *= a;
        return this
    },
    negate: function() {
        this.constant *= -1;
        this.normal.negate();
        return this
    },
    distanceToPoint: function(a) {
        return this.normal.dot(a) + this.constant
    },
    distanceToSphere: function(a) {
        return this.distanceToPoint(a.center) - a.radius
    },
    projectPoint: function(a, b) {
        return this.orthoPoint(a, b).sub(a).negate()
    },
    orthoPoint: function(a, 
    b) {
        var c = this.distanceToPoint(a);
        return (b || new THREE.Vector3).copy(this.normal).multiplyScalar(c)
    },
    isIntersectionLine: function(a) {
        var b = this.distanceToPoint(a.start);
        a = this.distanceToPoint(a.end);
        return 0 > b && 0 < a || 0 > a && 0 < b
    },
    intersectLine: function() {
        var a = new THREE.Vector3;
        return function(b, c) {
            var e = c || new THREE.Vector3
              , d = b.delta(a)
              , g = this.normal.dot(d);
            if (0 == g) {
                if (0 == this.distanceToPoint(b.start))
                    return e.copy(b.start)
            } else
                return g = -(b.start.dot(this.normal) + this.constant) / g,
                0 > g || 1 < g ? void 0 : e.copy(d).multiplyScalar(g).add(b.start)
        }
    }
    (),
    coplanarPoint: function(a) {
        return (a || new THREE.Vector3).copy(this.normal).multiplyScalar(-this.constant)
    },
    applyMatrix4: function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3
          , c = new THREE.Matrix3;
        return function(e, d) {
            var g = d || c.getNormalMatrix(e)
              , g = a.copy(this.normal).applyMatrix3(g)
              , f = this.coplanarPoint(b);
            f.applyMatrix4(e);
            this.setFromNormalAndCoplanarPoint(g, f);
            return this
        }
    }
    (),
    translate: function(a) {
        this.constant -= a.dot(this.normal);
        return this
    },
    equals: function(a) {
        return a.normal.equals(this.normal) && 
        a.constant == this.constant
    },
    clone: function() {
        return (new THREE.Plane).copy(this)
    }
};
THREE.Math = {
    PI2: 2 * Math.PI,
    generateUUID: function() {
        var a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""), b = Array(36), c = 0, e;
        return function() {
            for (var d = 0; 36 > d; d++)
                8 == d || 13 == d || 18 == d || 23 == d ? b[d] = "-" : 14 == d ? b[d] = "4" : (2 >= c && (c = 33554432 + 16777216 * Math.random() | 0),
                e = c & 15,
                c >>= 4,
                b[d] = a[19 == d ? e & 3 | 8 : e]);
            return b.join("")
        }
    }
    (),
    clamp: function(a, b, c) {
        return a < b ? b : a > c ? c : a
    },
    clampBottom: function(a, b) {
        return a < b ? b : a
    },
    mapLinear: function(a, b, c, e, d) {
        return e + (a - b) * (d - e) / (c - b)
    },
    smoothstep: function(a, 
    b, c) {
        if (a <= b)
            return 0;
        if (a >= c)
            return 1;
        a = (a - b) / (c - b);
        return a * a * (3 - 2 * a)
    },
    smootherstep: function(a, b, c) {
        if (a <= b)
            return 0;
        if (a >= c)
            return 1;
        a = (a - b) / (c - b);
        return a * a * a * (a * (6 * a - 15) + 10)
    },
    random16: function() {
        return (65280 * Math.random() + 255 * Math.random()) / 65535
    },
    randInt: function(a, b) {
        return a + Math.floor(Math.random() * (b - a + 1))
    },
    randFloat: function(a, b) {
        return a + Math.random() * (b - a)
    },
    randFloatSpread: function(a) {
        return a * (.5 - Math.random())
    },
    sign: function(a) {
        return 0 > a ? -1 : 0 < a ? 1 : 0
    },
    degToRad: function() {
        var a = Math.PI / 
        180;
        return function(b) {
            return b * a
        }
    }
    (),
    radToDeg: function() {
        var a = 180 / Math.PI;
        return function(b) {
            return b * a
        }
    }
    (),
    isPowerOfTwo: function(a) {
        return 0 === (a & a - 1) && 0 !== a
    }
};
THREE.Spline = function(a) {
    function b(a, f, b, d, c, k, e) {
        a = .5 * (b - a);
        d = .5 * (d - f);
        return (2 * (f - b) + a + d) * e + (-3 * (f - b) - 2 * a - d) * k + a * c + f
    }
    this.points = a;
    var c = [], e = {
        x: 0,
        y: 0,
        z: 0
    }, d, g, f, k, h, l, m, n, p;
    this.initFromArray = function(a) {
        this.points = [];
        for (var f = 0; f < a.length; f++)
            this.points[f] = {
                x: a[f][0],
                y: a[f][1],
                z: a[f][2]
            }
    }
    ;
    this.getPoint = function(a) {
        d = (this.points.length - 1) * a;
        g = Math.floor(d);
        f = d - g;
        c[0] = 0 === g ? g : g - 1;
        c[1] = g;
        c[2] = g > this.points.length - 2 ? this.points.length - 1 : g + 1;
        c[3] = g > this.points.length - 3 ? this.points.length - 1 : g + 
        2;
        l = this.points[c[0]];
        m = this.points[c[1]];
        n = this.points[c[2]];
        p = this.points[c[3]];
        k = f * f;
        h = f * k;
        e.x = b(l.x, m.x, n.x, p.x, f, k, h);
        e.y = b(l.y, m.y, n.y, p.y, f, k, h);
        e.z = b(l.z, m.z, n.z, p.z, f, k, h);
        return e
    }
    ;
    this.getControlPointsArray = function() {
        var a, f, b = this.points.length, d = [];
        for (a = 0; a < b; a++)
            f = this.points[a],
            d[a] = [f.x, f.y, f.z];
        return d
    }
    ;
    this.getLength = function(a) {
        var f, b, d, c = 0, k = new THREE.Vector3, e = new THREE.Vector3, h = [], g = 0;
        h[0] = 0;
        a || (a = 100);
        b = this.points.length * a;
        k.copy(this.points[0]);
        for (a = 1; a < b; a++)
            f = a / b,
            d = this.getPoint(f),
            e.copy(d),
            g += e.distanceTo(k),
            k.copy(d),
            f *= this.points.length - 1,
            f = Math.floor(f),
            f != c && (h[f] = g,
            c = f);
        h[h.length] = g;
        return {
            chunks: h,
            total: g
        }
    }
    ;
    this.reparametrizeByArcLength = function(a) {
        var f, b, d, c, k, e, h = [], g = new THREE.Vector3, l = this.getLength();
        h.push(g.copy(this.points[0]).clone());
        for (f = 1; f < this.points.length; f++) {
            b = l.chunks[f] - l.chunks[f - 1];
            e = Math.ceil(a * b / l.total);
            c = (f - 1) / (this.points.length - 1);
            k = f / (this.points.length - 1);
            for (b = 1; b < e - 1; b++)
                d = c + 1 / e * b * (k - c),
                d = this.getPoint(d),
                h.push(g.copy(d).clone());
            h.push(g.copy(this.points[f]).clone())
        }
        this.points = h
    }
}
;
THREE.Triangle = function(a, b, c) {
    this.a = void 0 !== a ? a : new THREE.Vector3;
    this.b = void 0 !== b ? b : new THREE.Vector3;
    this.c = void 0 !== c ? c : new THREE.Vector3
}
;
THREE.Triangle.normal = function() {
    var a = new THREE.Vector3;
    return function(b, c, e, d) {
        d = d || new THREE.Vector3;
        d.subVectors(e, c);
        a.subVectors(b, c);
        d.cross(a);
        b = d.lengthSq();
        return 0 < b ? d.multiplyScalar(1 / Math.sqrt(b)) : d.set(0, 0, 0)
    }
}
();
THREE.Triangle.barycoordFromPoint = function() {
    var a = new THREE.Vector3
      , b = new THREE.Vector3
      , c = new THREE.Vector3;
    return function(e, d, g, f, k) {
        a.subVectors(f, d);
        b.subVectors(g, d);
        c.subVectors(e, d);
        e = a.dot(a);
        d = a.dot(b);
        g = a.dot(c);
        var h = b.dot(b);
        f = b.dot(c);
        var l = e * h - d * d;
        k = k || new THREE.Vector3;
        if (0 == l)
            return k.set(-2, -1, -1);
        l = 1 / l;
        h = (h * g - d * f) * l;
        e = (e * f - d * g) * l;
        return k.set(1 - h - e, e, h)
    }
}
();
THREE.Triangle.containsPoint = function() {
    var a = new THREE.Vector3;
    return function(b, c, e, d) {
        b = THREE.Triangle.barycoordFromPoint(b, c, e, d, a);
        return 0 <= b.x && 0 <= b.y && 1 >= b.x + b.y
    }
}
();
THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this
    },
    setFromPointsAndIndices: function(a, b, c, e) {
        this.a.copy(a[b]);
        this.b.copy(a[c]);
        this.c.copy(a[e]);
        return this
    },
    copy: function(a) {
        this.a.copy(a.a);
        this.b.copy(a.b);
        this.c.copy(a.c);
        return this
    },
    area: function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3;
        return function() {
            a.subVectors(this.c, this.b);
            b.subVectors(this.a, this.b);
            return .5 * a.cross(b).length()
        }
    }
    (),
    midpoint: function(a) {
        return (a || 
        new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    },
    normal: function(a) {
        return THREE.Triangle.normal(this.a, this.b, this.c, a)
    },
    plane: function(a) {
        return (a || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
    },
    barycoordFromPoint: function(a, b) {
        return THREE.Triangle.barycoordFromPoint(a, this.a, this.b, this.c, b)
    },
    containsPoint: function(a) {
        return THREE.Triangle.containsPoint(a, this.a, this.b, this.c)
    },
    equals: function(a) {
        return a.a.equals(this.a) && a.b.equals(this.b) && a.c.equals(this.c)
    },
    clone: function() {
        return (new THREE.Triangle).copy(this)
    }
};
THREE.Vertex = function(a) {
    console.warn("THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.");
    return a
}
;
THREE.UV = function(a, b) {
    console.warn("THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.");
    return new THREE.Vector2(a,b)
}
;
THREE.Clock = function(a) {
    this.autoStart = void 0 !== a ? a : !0;
    this.elapsedTime = this.oldTime = this.startTime = 0;
    this.running = !1
}
;
THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function() {
        this.oldTime = this.startTime = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now();
        this.running = !0
    },
    stop: function() {
        this.getElapsedTime();
        this.running = !1
    },
    getElapsedTime: function() {
        this.getDelta();
        return this.elapsedTime
    },
    getDelta: function() {
        var a = 0;
        this.autoStart && !this.running && this.start();
        if (this.running) {
            var b = void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now() : Date.now()
              , 
            a = .001 * (b - this.oldTime);
            this.oldTime = b;
            this.elapsedTime += a
        }
        return a
    }
};
THREE.EventDispatcher = function() {}
;
THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function(a) {
        a.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
        a.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
        a.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
        a.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
    },
    addEventListener: function(a, b) {
        void 0 === this._listeners && (this._listeners = {});
        var c = this._listeners;
        void 0 === c[a] && (c[a] = []);
        -1 === c[a].indexOf(b) && 
        c[a].push(b)
    },
    hasEventListener: function(a, b) {
        if (void 0 === this._listeners)
            return !1;
        var c = this._listeners;
        return void 0 !== c[a] && -1 !== c[a].indexOf(b) ? !0 : !1
    },
    removeEventListener: function(a, b) {
        if (void 0 !== this._listeners) {
            var c = this._listeners[a];
            if (void 0 !== c) {
                var e = c.indexOf(b);
                -1 !== e && c.splice(e, 1)
            }
        }
    },
    dispatchEvent: function() {
        var a = [];
        return function(b) {
            if (void 0 !== this._listeners) {
                var c = this._listeners[b.type];
                if (void 0 !== c) {
                    b.target = this;
                    for (var e = c.length, d = 0; d < e; d++)
                        a[d] = c[d];
                    for (d = 0; d < e; d++)
                        a[d].call(this, 
                        b)
                }
            }
        }
    }
    ()
};
(function(a) {
    a.Raycaster = function(f, b, d, c) {
        this.ray = new a.Ray(f,b);
        this.near = d || 0;
        this.far = c || Infinity
    }
    ;
    var b = new a.Sphere
      , c = new a.Ray;
    new a.Plane;
    new a.Vector3;
    var e = new a.Vector3
      , d = new a.Matrix4
      , g = function(a, f) {
        return a.distance - f.distance
    }
      , f = new a.Vector3
      , k = new a.Vector3
      , h = new a.Vector3
      , l = function(g, m, t) {
        if (g instanceof a.Sprite) {
            e.setFromMatrixPosition(g.matrixWorld);
            var v = m.ray.distanceToPoint(e);
            if (v > g.scale.x)
                return t;
            t.push({
                distance: v,
                point: g.position,
                face: null ,
                object: g
            })
        } else if (g instanceof a.LOD)
            e.setFromMatrixPosition(g.matrixWorld),
            v = m.ray.origin.distanceTo(e),
            l(g.getObjectForDistance(v), m, t);
        else if (g instanceof a.Mesh) {
            var r = g.geometry;
            null  === r.boundingSphere && r.computeBoundingSphere();
            b.copy(r.boundingSphere);
            b.applyMatrix4(g.matrixWorld);
            if (!1 === m.ray.isIntersectionSphere(b))
                return t;
            d.getInverse(g.matrixWorld);
            c.copy(m.ray).applyMatrix4(d);
            if (null  !== r.boundingBox && !1 === c.isIntersectionBox(r.boundingBox))
                return t;
            if (r instanceof a.BufferGeometry) {
                var u = g.material;
                if (void 0 === u)
                    return t;
                var w = r.attributes, x, A, y = m.precision;
                if (void 0 !== w.index)
                    for (var z = r.offsets, E = w.index.array, C = r.vb ? r.vb : w.position.array, B = r.vb ? r.vbstride : 3, K = 0, F = z.length; K < F; ++K)
                        for (var w = z[K].start, O = z[K].index, r = w, M = w + z[K].count; r < M; r += 3) {
                            w = O + E[r];
                            x = O + E[r + 1];
                            A = O + E[r + 2];
                            f.set(C[w * B], C[w * B + 1], C[w * B + 2]);
                            k.set(C[x * B], C[x * B + 1], C[x * B + 2]);
                            h.set(C[A * B], C[A * B + 1], C[A * B + 2]);
                            var G = u.side === a.BackSide ? c.intersectTriangle(h, k, f, !0) : c.intersectTriangle(f, k, h, u.side !== a.DoubleSide);
                            null  !== G && (G.applyMatrix4(g.matrixWorld),
                            v = m.ray.origin.distanceTo(G),
                            v < y || v < m.near || 
                            v > m.far || t.push({
                                distance: v,
                                point: G,
                                indices: [w, x, A],
                                face: null ,
                                faceIndex: null ,
                                object: g
                            }))
                        }
                else
                    for (C = r.vb ? r.vb : w.position.array,
                    B = r.vb ? r.vbstride : 3,
                    r = 0,
                    M = w.position.array.length; r < M; r += 3)
                        w = r,
                        x = r + 1,
                        A = r + 2,
                        f.set(C[w * B], C[w * B + 1], C[w * B + 2]),
                        k.set(C[x * B], C[x * B + 1], C[x * B + 2]),
                        h.set(C[A * B], C[A * B + 1], C[A * B + 2]),
                        G = u.side === a.BackSide ? c.intersectTriangle(h, k, f, !0) : c.intersectTriangle(f, k, h, u.side !== a.DoubleSide),
                        null  !== G && (G.applyMatrix4(g.matrixWorld),
                        v = m.ray.origin.distanceTo(G),
                        v < y || v < m.near || v > m.far || t.push({
                            distance: v,
                            point: G,
                            indices: [w, x, A],
                            face: null ,
                            faceIndex: null ,
                            object: g
                        }))
            } else if (r instanceof a.Geometry)
                for (E = g.material instanceof a.MeshFaceMaterial,
                C = !0 === E ? g.material.materials : null ,
                y = m.precision,
                z = r.vertices,
                B = 0,
                K = r.faces.length; B < K; B++)
                    if (F = r.faces[B],
                    u = !0 === E ? C[F.materialIndex] : g.material,
                    void 0 !== u) {
                        w = z[F.a];
                        x = z[F.b];
                        A = z[F.c];
                        if (!0 === u.morphTargets) {
                            v = r.morphTargets;
                            G = g.morphTargetInfluences;
                            f.set(0, 0, 0);
                            k.set(0, 0, 0);
                            h.set(0, 0, 0);
                            O = 0;
                            for (M = v.length; O < M; O++) {
                                var Q = G[O];
                                if (0 !== Q) {
                                    var R = v[O].vertices;
                                    f.x += 
                                    (R[F.a].x - w.x) * Q;
                                    f.y += (R[F.a].y - w.y) * Q;
                                    f.z += (R[F.a].z - w.z) * Q;
                                    k.x += (R[F.b].x - x.x) * Q;
                                    k.y += (R[F.b].y - x.y) * Q;
                                    k.z += (R[F.b].z - x.z) * Q;
                                    h.x += (R[F.c].x - A.x) * Q;
                                    h.y += (R[F.c].y - A.y) * Q;
                                    h.z += (R[F.c].z - A.z) * Q
                                }
                            }
                            f.add(w);
                            k.add(x);
                            h.add(A);
                            w = f;
                            x = k;
                            A = h
                        }
                        G = u.side === a.BackSide ? c.intersectTriangle(A, x, w, !0) : c.intersectTriangle(w, x, A, u.side !== a.DoubleSide);
                        null  !== G && (G.applyMatrix4(g.matrixWorld),
                        v = m.ray.origin.distanceTo(G),
                        v < y || v < m.near || v > m.far || t.push({
                            distance: v,
                            point: G,
                            face: F,
                            faceIndex: B,
                            object: g
                        }))
                    }
        } else if (g instanceof 
        a.Line) {
            y = m.linePrecision;
            u = y * y;
            r = g.geometry;
            null  === r.boundingSphere && r.computeBoundingSphere();
            b.copy(r.boundingSphere);
            b.applyMatrix4(g.matrixWorld);
            if (!1 === m.ray.isIntersectionSphere(b))
                return t;
            d.getInverse(g.matrixWorld);
            c.copy(m.ray).applyMatrix4(d);
            if (r instanceof a.Geometry)
                for (z = r.vertices,
                y = z.length,
                w = new a.Vector3,
                x = new a.Vector3,
                A = g.type === a.LineStrip ? 1 : 2,
                r = 0; r < y - 1; r += A)
                    c.distanceSqToSegment(z[r], z[r + 1], x, w) > u || (v = c.origin.distanceTo(x),
                    v < m.near || v > m.far || t.push({
                        distance: v,
                        point: w.clone().applyMatrix4(g.matrixWorld),
                        face: null ,
                        faceIndex: null ,
                        object: g
                    }))
        }
    }
      , m = function(a, f, b) {
        a = a.getDescendants();
        for (var d = 0, c = a.length; d < c; d++)
            l(a[d], f, b)
    }
    ;
    a.Raycaster.prototype.precision = 1E-4;
    a.Raycaster.prototype.linePrecision = 1;
    a.Raycaster.prototype.set = function(a, f) {
        this.ray.set(a, f)
    }
    ;
    a.Raycaster.prototype.intersectObject = function(a, f) {
        var b = [];
        !0 === f && m(a, this, b);
        l(a, this, b);
        b.sort(g);
        return b
    }
    ;
    a.Raycaster.prototype.intersectObjects = function(a, f) {
        for (var b = [], d = 0, c = a.length; d < c; d++)
            l(a[d], this, b),
            !0 === f && m(a[d], this, b);
        b.sort(g);
        return b
    }
}
)(THREE);
THREE.Object3D = function(a) {
    this.id = THREE.Object3DIdCount++;
    this.parent = void 0;
    a ? (this.matrixAutoUpdate = !1,
    this.skipModTerms = !0) : (this.up = new THREE.Vector3(0,1,0),
    this.position = new THREE.Vector3,
    this._rotation = new THREE.Euler,
    this._quaternion = new THREE.Quaternion,
    this.scale = new THREE.Vector3(1,1,1),
    this._rotation._quaternion = this.quaternion,
    this._quaternion._euler = this.rotation,
    this.matrixAutoUpdate = !0,
    this.matrix = new THREE.Matrix4,
    this.skipModTerms = !1);
    this.renderDepth = null ;
    this.rotationAutoUpdate = !0;
    this.matrixWorld = new THREE.Matrix4;
    this.visible = this.matrixWorldNeedsUpdate = !0;
    this.receiveShadow = this.castShadow = !1;
    this.frustumCulled = !0
}
;
THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    get rotation() {
        return this._rotation
    },
    set rotation(a) {
        this._rotation = a;
        this._rotation._quaternion = this._quaternion;
        this._quaternion._euler = this._rotation;
        this._rotation._updateQuaternion()
    },
    get quaternion() {
        return this._quaternion
    },
    set quaternion(a) {
        this._quaternion = a;
        this._quaternion._euler = this._rotation;
        this._rotation._quaternion = this._quaternion;
        this._quaternion._updateEuler()
    },
    get eulerOrder() {
        console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
        return this.rotation.order
    },
    set eulerOrder(a) {
        console.warn("DEPRECATED: Object3D's .eulerOrder has been moved to Object3D's .rotation.order.");
        this.rotation.order = a
    },
    get useQuaternion() {
        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
    },
    set useQuaternion(a) {
        console.warn("DEPRECATED: Object3D's .useQuaternion has been removed. The library now uses quaternions by default.")
    },
    applyMatrix: function(a) {
        this.matrix.multiplyMatrices(a, this.matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    },
    setRotationFromAxisAngle: function(a, b) {
        this.quaternion.setFromAxisAngle(a, b)
    },
    setRotationFromEuler: function(a) {
        this.quaternion.setFromEuler(a, !0)
    },
    setRotationFromMatrix: function(a) {
        this.quaternion.setFromRotationMatrix(a)
    },
    setRotationFromQuaternion: function(a) {
        this.quaternion.copy(a)
    },
    rotateOnAxis: function() {
        var a = new THREE.Quaternion;
        return function(b, c) {
            a.setFromAxisAngle(b, c);
            this.quaternion.multiply(a);
            return this
        }
    }
    (),
    rotateX: function() {
        var a = 
        new THREE.Vector3(1,0,0);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }
    (),
    rotateY: function() {
        var a = new THREE.Vector3(0,1,0);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }
    (),
    rotateZ: function() {
        var a = new THREE.Vector3(0,0,1);
        return function(b) {
            return this.rotateOnAxis(a, b)
        }
    }
    (),
    translateOnAxis: function() {
        var a = new THREE.Vector3;
        return function(b, c) {
            a.copy(b);
            a.applyQuaternion(this.quaternion);
            this.position.add(a.multiplyScalar(c));
            return this
        }
    }
    (),
    translate: function(a, b) {
        console.warn("DEPRECATED: Object3D's .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.");
        return this.translateOnAxis(b, a)
    },
    translateX: function() {
        var a = new THREE.Vector3(1,0,0);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }
    (),
    translateY: function() {
        var a = new THREE.Vector3(0,1,0);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }
    (),
    translateZ: function() {
        var a = new THREE.Vector3(0,0,1);
        return function(b) {
            return this.translateOnAxis(a, b)
        }
    }
    (),
    localToWorld: function(a) {
        return a.applyMatrix4(this.matrixWorld)
    },
    worldToLocal: function() {
        var a = new THREE.Matrix4;
        return function(b) {
            return b.applyMatrix4(a.getInverse(this.matrixWorld))
        }
    }
    (),
    lookAt: function() {
        var a = new THREE.Matrix4;
        return function(b) {
            a.lookAt(b, this.position, this.up);
            this.quaternion.setFromRotationMatrix(a)
        }
    }
    (),
    add: function(a) {
        if (a === this)
            console.warn("THREE.Object3D.add: An object can't be added as a child of itself.");
        else if (a instanceof THREE.Object3D) {
            void 0 !== a.parent && a.parent.remove(a);
            a.parent = this;
            a.dispatchEvent({
                type: "added"
            });
            this.children || (this.children = []);
            this.children.push(a);
            for (var b = this; void 0 !== b.parent; )
                b = b.parent;
            void 0 !== b && b instanceof THREE.Scene && 
            b.__addObject(a)
        }
    },
    remove: function(a) {
        var b = this.children.indexOf(a);
        if (-1 !== b) {
            a.parent = void 0;
            a.dispatchEvent({
                type: "removed"
            });
            this.children.splice(b, 1);
            for (b = this; void 0 !== b.parent; )
                b = b.parent;
            void 0 !== b && b instanceof THREE.Scene && b.__removeObject(a)
        }
    },
    traverse: function(a) {
        a(this);
        for (var b = 0, c = this.children.length; b < c; b++)
            this.children[b].traverse(a)
    },
    getObjectById: function(a, b) {
        for (var c = 0, e = this.children.length; c < e; c++) {
            var d = this.children[c];
            if (d.id === a || !0 === b && (d = d.getObjectById(a, b),
            void 0 !== 
            d))
                return d
        }
    },
    getObjectByName: function(a, b) {
        for (var c = 0, e = this.children.length; c < e; c++) {
            var d = this.children[c];
            if (d.name === a || !0 === b && (d = d.getObjectByName(a, b),
            void 0 !== d))
                return d
        }
    },
    getChildByName: function(a, b) {
        console.warn("DEPRECATED: Object3D's .getChildByName() has been renamed to .getObjectByName().");
        return this.getObjectByName(a, b)
    },
    getDescendants: function(a) {
        if (!this.children)
            return null ;
        void 0 === a && (a = []);
        Array.prototype.push.apply(a, this.children);
        for (var b = 0, c = this.children.length; b < c; b++)
            this.children[b].getDescendants(a);
        return a
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = !0
    },
    updateMatrixWorld: function(a) {
        !0 === this.matrixAutoUpdate && this.updateMatrix();
        if (!0 === this.matrixWorldNeedsUpdate || !0 === a)
            void 0 === this.parent && this.matrix ? this.matrixWorld.copy(this.matrix) : this.matrix && this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
            this.matrixWorldNeedsUpdate = !1,
            a = !0;
        if (this.children)
            for (var b = 0, c = this.children.length; b < c; b++)
                this.children[b].updateMatrixWorld(a)
    },
    clone: function(a, b) {
        void 0 === a && (a = new THREE.Object3D(this.skipModTerms));
        void 0 === b && (b = !0);
        this.name && (a.name = this.name);
        this.skipModTerms || (a.up.copy(this.up),
        a.position.copy(this.position),
        a.quaternion.copy(this.quaternion),
        a.scale.copy(this.scale));
        a.renderDepth = this.renderDepth;
        a.rotationAutoUpdate = this.rotationAutoUpdate;
        this.matrix ? a.matrix.copy(this.matrix) : a.matrix = null ;
        a.matrixWorld.copy(this.matrixWorld);
        a.matrixAutoUpdate = this.matrixAutoUpdate;
        a.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;
        a.visible = this.visible;
        a.castShadow = this.castShadow;
        a.receiveShadow = this.receiveShadow;
        a.frustumCulled = this.frustumCulled;
        a.userData = JSON.parse(JSON.stringify(this.userData));
        if (!0 === b && this.children)
            for (var c = 0; c < this.children.length; c++)
                a.add(this.children[c].clone());
        return a
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype);
THREE.Object3DIdCount = 0;
THREE.Projector = function() {
    function a() {
        if (m === p) {
            var a = new THREE.RenderableVertex;
            n.push(a);
            p++;
            m++;
            return a
        }
        return n[m++]
    }
    function b() {
        if (v === u) {
            var a = new THREE.RenderableFace;
            r.push(a);
            u++;
            v++;
            return a
        }
        return r[v++]
    }
    function c() {
        if (x === y) {
            var a = new THREE.RenderableLine;
            A.push(a);
            y++;
            x++;
            return a
        }
        return A[x++]
    }
    function e(a, f) {
        return a.z !== f.z ? f.z - a.z : a.id !== f.id ? a.id - f.id : 0
    }
    function d(a, f) {
        var b = 0
          , d = 1
          , c = a.z + a.w
          , k = f.z + f.w
          , e = -a.z + a.w
          , h = -f.z + f.w;
        if (0 <= c && 0 <= k && 0 <= e && 0 <= h)
            return !0;
        if (0 > c && 0 > k || 0 > e && 
        0 > h)
            return !1;
        0 > c ? b = Math.max(b, c / (c - k)) : 0 > k && (d = Math.min(d, c / (c - k)));
        0 > e ? b = Math.max(b, e / (e - h)) : 0 > h && (d = Math.min(d, e / (e - h)));
        if (d < b)
            return !1;
        a.lerp(f, b);
        f.lerp(a, 1 - d);
        return !0
    }
    var g, f, k = [], h = 0, l, m, n = [], p = 0, t, v, r = [], u = 0, w, x, A = [], y = 0, z, E, C = [], B = 0, K = {
        objects: [],
        lights: [],
        elements: []
    }, F = new THREE.Vector3, O = new THREE.Vector3, M = new THREE.Vector3, G = new THREE.Vector3, Q = new THREE.Vector4, R = new THREE.Box3(new THREE.Vector3(-1,-1,-1),new THREE.Vector3(1,1,1)), S = new THREE.Box3, U = Array(3), H = new THREE.Matrix4, Z = 
    new THREE.Matrix4, N, ca = new THREE.Matrix4, J = new THREE.Matrix3, Y = new THREE.Frustum, P = new THREE.Vector4, fa = new THREE.Vector4;
    this.projectVector = function(a, f) {
        f.matrixWorldInverse.getInverse(f.matrixWorld);
        Z.multiplyMatrices(f.projectionMatrix, f.matrixWorldInverse);
        return a.applyProjection(Z)
    }
    ;
    this.unprojectVector = function() {
        var a = new THREE.Matrix4;
        return function(f, b) {
            a.getInverse(b.projectionMatrix);
            Z.multiplyMatrices(b.matrixWorld, a);
            return f.applyProjection(Z)
        }
    }
    ();
    this.pickingRay = function(a, f) {
        a.z = 
        -1;
        var b = new THREE.Vector3(a.x,a.y,1);
        this.unprojectVector(a, f);
        this.unprojectVector(b, f);
        b.sub(a).normalize();
        return new THREE.Raycaster(a,b)
    }
    ;
    var ia = function(a) {
        if (!1 !== a.visible) {
            if (a instanceof THREE.Light)
                K.lights.push(a);
            else if (a instanceof THREE.Mesh || a instanceof THREE.Line || a instanceof THREE.Sprite)
                if (!1 === a.frustumCulled || !0 === Y.intersectsObject(a)) {
                    if (f === h) {
                        var b = new THREE.RenderableObject;
                        k.push(b);
                        h++;
                        f++;
                        g = b
                    } else
                        g = k[f++];
                    g.id = a.id;
                    g.object = a;
                    null  !== a.renderDepth ? g.z = a.renderDepth : 
                    (G.setFromMatrixPosition(a.matrixWorld),
                    G.applyProjection(Z),
                    g.z = G.z);
                    K.objects.push(g)
                }
            for (var b = 0, d = a.children.length; b < d; b++)
                ia(a.children[b])
        }
    }
      , aa = new function() {
        var f = []
          , d = null 
          , k = new THREE.Matrix3
          , e = function(a) {
            var f = a.positionWorld
              , b = a.positionScreen;
            f.copy(a.position).applyMatrix4(N);
            b.copy(f).applyMatrix4(Z);
            f = 1 / b.w;
            b.x *= f;
            b.y *= f;
            b.z *= f;
            a.visible = -1 <= b.x && 1 >= b.x && -1 <= b.y && 1 >= b.y && -1 <= b.z && 1 >= b.z
        }
          , h = function(a, f, b) {
            U[0] = a.positionScreen;
            U[1] = f.positionScreen;
            U[2] = b.positionScreen;
            return !0 === 
            a.visible || !0 === f.visible || !0 === b.visible || R.isIntersectionBox(S.setFromPoints(U)) ? 0 > (b.positionScreen.x - a.positionScreen.x) * (f.positionScreen.y - a.positionScreen.y) - (b.positionScreen.y - a.positionScreen.y) * (f.positionScreen.x - a.positionScreen.x) : !1
        }
        ;
        return {
            setObject: function(a) {
                d = a;
                k.getNormalMatrix(d.matrixWorld);
                f.length = 0
            },
            projectVertex: e,
            checkTriangleVisibility: h,
            pushVertex: function(f, b, d) {
                l = a();
                l.position.set(f, b, d);
                e(l)
            },
            pushNormal: function(a, b, d) {
                f.push(a, b, d)
            },
            pushLine: function(a, f) {
                var b = 
                n[a]
                  , k = n[f];
                w = c();
                w.id = d.id;
                w.v1.copy(b);
                w.v2.copy(k);
                w.z = (b.positionScreen.z + k.positionScreen.z) / 2;
                w.material = d.material;
                K.elements.push(w)
            },
            pushTriangle: function(a, c, e) {
                var g = n[a]
                  , l = n[c]
                  , m = n[e];
                if (!0 === h(g, l, m)) {
                    t = b();
                    t.id = d.id;
                    t.v1.copy(g);
                    t.v2.copy(l);
                    t.v3.copy(m);
                    t.z = (g.positionScreen.z + l.positionScreen.z + m.positionScreen.z) / 3;
                    for (g = 0; 3 > g; g++)
                        l = 3 * arguments[g],
                        m = t.vertexNormalsModel[g],
                        m.set(f[l + 0], f[l + 1], f[l + 2]),
                        m.applyMatrix3(k).normalize();
                    t.vertexNormalsLength = 3;
                    t.material = d.material;
                    K.elements.push(t)
                }
            }
        }
    }
    ;
    this.projectScene = function(k, h, g, l) {
        var p, r, u, R, A, S, y, G, U;
        E = x = v = 0;
        K.elements.length = 0;
        !0 === k.autoUpdate && k.updateMatrixWorld();
        void 0 === h.parent && h.updateMatrixWorld();
        H.copy(h.matrixWorldInverse.getInverse(h.matrixWorld));
        Z.multiplyMatrices(h.projectionMatrix, H);
        Y.setFromMatrix(Z);
        f = 0;
        K.objects.length = 0;
        K.lights.length = 0;
        ia(k);
        !0 === g && K.objects.sort(e);
        k = 0;
        for (g = K.objects.length; k < g; k++)
            if (p = K.objects[k].object,
            r = p.geometry,
            aa.setObject(p),
            N = p.matrixWorld,
            m = 0,
            p instanceof THREE.Mesh)
                if (r instanceof 
                THREE.BufferGeometry) {
                    if (S = r.attributes,
                    p = r.offsets,
                    void 0 !== S.position) {
                        G = S.position.array;
                        r = 0;
                        for (R = G.length; r < R; r += 3)
                            aa.pushVertex(G[r], G[r + 1], G[r + 2]);
                        U = S.normal.array;
                        r = 0;
                        for (R = U.length; r < R; r += 3)
                            aa.pushNormal(U[r], U[r + 1], U[r + 2]);
                        if (void 0 !== S.index)
                            if (S = S.index.array,
                            0 < p.length)
                                for (k = 0; k < p.length; k++)
                                    for (R = p[k],
                                    G = R.index,
                                    r = R.start,
                                    R = R.start + R.count; r < R; r += 3)
                                        aa.pushTriangle(S[r] + G, S[r + 1] + G, S[r + 2] + G);
                            else
                                for (r = 0,
                                R = S.length; r < R; r += 3)
                                    aa.pushTriangle(S[r], S[r + 1], S[r + 2]);
                        else
                            for (r = 0,
                            R = G.length / 3; r < 
                            R; r += 3)
                                aa.pushTriangle(r, r + 1, r + 2)
                    }
                } else {
                    if (r instanceof THREE.Geometry) {
                        u = r.vertices;
                        R = r.faces;
                        S = r.faceVertexUvs;
                        J.getNormalMatrix(N);
                        G = p.material instanceof THREE.MeshFaceMaterial;
                        U = !0 === G ? p.material : null ;
                        for (var ja = 0, Ga = u.length; ja < Ga; ja++) {
                            var ka = u[ja];
                            aa.pushVertex(ka.x, ka.y, ka.z)
                        }
                        ja = 0;
                        for (Ga = R.length; ja < Ga; ja++) {
                            u = R[ja];
                            var ta = !0 === G ? U.materials[u.materialIndex] : p.material;
                            if (void 0 !== ta) {
                                y = ta.side;
                                var ka = n[u.a]
                                  , ua = n[u.b]
                                  , na = n[u.c];
                                if (!0 === ta.morphTargets) {
                                    A = r.morphTargets;
                                    var va = p.morphTargetInfluences
                                      , 
                                    pa = ka.position
                                      , Aa = ua.position
                                      , wa = na.position;
                                    F.set(0, 0, 0);
                                    O.set(0, 0, 0);
                                    M.set(0, 0, 0);
                                    for (var xa = 0, $a = A.length; xa < $a; xa++) {
                                        var ra = va[xa];
                                        if (0 !== ra) {
                                            var ba = A[xa].vertices;
                                            F.x += (ba[u.a].x - pa.x) * ra;
                                            F.y += (ba[u.a].y - pa.y) * ra;
                                            F.z += (ba[u.a].z - pa.z) * ra;
                                            O.x += (ba[u.b].x - Aa.x) * ra;
                                            O.y += (ba[u.b].y - Aa.y) * ra;
                                            O.z += (ba[u.b].z - Aa.z) * ra;
                                            M.x += (ba[u.c].x - wa.x) * ra;
                                            M.y += (ba[u.c].y - wa.y) * ra;
                                            M.z += (ba[u.c].z - wa.z) * ra
                                        }
                                    }
                                    ka.position.add(F);
                                    ua.position.add(O);
                                    na.position.add(M);
                                    aa.projectVertex(ka);
                                    aa.projectVertex(ua);
                                    aa.projectVertex(na)
                                }
                                va = 
                                aa.checkTriangleVisibility(ka, ua, na);
                                if (!(!1 === va && y === THREE.FrontSide || !0 === va && y === THREE.BackSide)) {
                                    t = b();
                                    t.id = p.id;
                                    t.v1.copy(ka);
                                    t.v2.copy(ua);
                                    t.v3.copy(na);
                                    t.normalModel.copy(u.normal);
                                    !1 !== va || y !== THREE.BackSide && y !== THREE.DoubleSide || t.normalModel.negate();
                                    t.normalModel.applyMatrix3(J).normalize();
                                    t.centroidModel.copy(u.centroid).applyMatrix4(N);
                                    A = u.vertexNormals;
                                    pa = 0;
                                    for (Aa = Math.min(A.length, 3); pa < Aa; pa++)
                                        wa = t.vertexNormalsModel[pa],
                                        wa.copy(A[pa]),
                                        !1 !== va || y !== THREE.BackSide && y !== THREE.DoubleSide || 
                                        wa.negate(),
                                        wa.applyMatrix3(J).normalize();
                                    t.vertexNormalsLength = A.length;
                                    A = 0;
                                    for (va = Math.min(S.length, 3); A < va; A++)
                                        if (y = S[A][ja],
                                        void 0 !== y)
                                            for (pa = 0,
                                            Aa = y.length; pa < Aa; pa++)
                                                t.uvs[A][pa] = y[pa];
                                    t.color = u.color;
                                    t.material = ta;
                                    t.z = (ka.positionScreen.z + ua.positionScreen.z + na.positionScreen.z) / 3;
                                    K.elements.push(t)
                                }
                            }
                        }
                    }
                }
            else if (p instanceof THREE.Line)
                if (r instanceof THREE.BufferGeometry) {
                    if (S = r.attributes,
                    void 0 !== S.position) {
                        G = S.position.array;
                        r = 0;
                        for (R = G.length; r < R; r += 3)
                            aa.pushVertex(G[r], G[r + 1], G[r + 2]);
                        if (void 0 !== S.index)
                            for (S = S.index.array,
                            r = 0,
                            R = S.length; r < R; r += 2)
                                aa.pushLine(S[r], S[r + 1]);
                        else
                            for (r = 0,
                            R = G.length / 3 - 1; r < R; r++)
                                aa.pushLine(r, r + 1)
                    }
                } else {
                    if (r instanceof THREE.Geometry && (ca.multiplyMatrices(Z, N),
                    u = p.geometry.vertices,
                    0 !== u.length))
                        for (ka = a(),
                        ka.positionScreen.copy(u[0]).applyMatrix4(ca),
                        r = p.type === THREE.LinePieces ? 2 : 1,
                        ja = 1,
                        Ga = u.length; ja < Ga; ja++)
                            ka = a(),
                            ka.positionScreen.copy(u[ja]).applyMatrix4(ca),
                            0 < (ja + 1) % r || (ua = n[m - 2],
                            P.copy(ka.positionScreen),
                            fa.copy(ua.positionScreen),
                            !0 === d(P, fa) && 
                            (P.multiplyScalar(1 / P.w),
                            fa.multiplyScalar(1 / fa.w),
                            w = c(),
                            w.id = p.id,
                            w.v1.positionScreen.copy(P),
                            w.v2.positionScreen.copy(fa),
                            w.z = Math.max(P.z, fa.z),
                            w.material = p.material,
                            p.material.vertexColors === THREE.VertexColors && (w.vertexColors[0].copy(p.geometry.colors[ja]),
                            w.vertexColors[1].copy(p.geometry.colors[ja - 1])),
                            K.elements.push(w)))
                }
            else
                p instanceof THREE.Sprite && (Q.set(N.elements[12], N.elements[13], N.elements[14], 1),
                Q.applyMatrix4(Z),
                r = 1 / Q.w,
                Q.z *= r,
                -1 <= Q.z && 1 >= Q.z && (E === B ? (R = new THREE.RenderableSprite,
                C.push(R),
                B++,
                E++,
                z = R) : z = C[E++],
                z.id = p.id,
                z.x = Q.x * r,
                z.y = Q.y * r,
                z.z = Q.z,
                z.object = p,
                z.rotation = p.rotation,
                z.scale.x = p.scale.x * Math.abs(z.x - (Q.x + h.projectionMatrix.elements[0]) / (Q.w + h.projectionMatrix.elements[12])),
                z.scale.y = p.scale.y * Math.abs(z.y - (Q.y + h.projectionMatrix.elements[5]) / (Q.w + h.projectionMatrix.elements[13])),
                z.material = p.material,
                K.elements.push(z)));
        !0 === l && K.elements.sort(e);
        return K
    }
}
;
THREE.Face3 = function(a, b, c, e, d, g) {
    this.a = a;
    this.b = b;
    this.c = c;
    this.normal = e instanceof THREE.Vector3 ? e : new THREE.Vector3;
    this.vertexNormals = e instanceof Array ? e : [];
    this.color = d instanceof THREE.Color ? d : new THREE.Color;
    this.vertexColors = d instanceof Array ? d : [];
    this.vertexTangents = [];
    this.materialIndex = void 0 !== g ? g : 0;
    this.centroid = new THREE.Vector3
}
;
THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function() {
        var a = new THREE.Face3(this.a,this.b,this.c);
        a.normal.copy(this.normal);
        a.color.copy(this.color);
        a.centroid.copy(this.centroid);
        a.materialIndex = this.materialIndex;
        var b, c;
        b = 0;
        for (c = this.vertexNormals.length; b < c; b++)
            a.vertexNormals[b] = this.vertexNormals[b].clone();
        b = 0;
        for (c = this.vertexColors.length; b < c; b++)
            a.vertexColors[b] = this.vertexColors[b].clone();
        b = 0;
        for (c = this.vertexTangents.length; b < c; b++)
            a.vertexTangents[b] = this.vertexTangents[b].clone();
        return a
    }
};
THREE.Face4 = function(a, b, c, e, d, g, f) {
    console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead.");
    return new THREE.Face3(a,b,c,d,g,f)
}
;
THREE.BufferGeometry = function() {
    this.id = THREE.GeometryIdCount++;
    this.attributes = {};
    this.offsets = [];
    this.boundingSphere = this.boundingBox = null 
}
;
THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    addAttribute: function(a, b, c, e) {
        this.attributes[a] = {
            array: new b(c * e),
            itemSize: e
        };
        return this.attributes[a]
    },
    applyMatrix: function(a) {
        var b = this.attributes.position;
        void 0 !== b && (a.multiplyVector3Array(b.array),
        b.needsUpdate = !0);
        b = this.attributes.normal;
        void 0 !== b && ((new THREE.Matrix3).getNormalMatrix(a).multiplyVector3Array(b.array),
        b.needsUpdate = !0)
    },
    computeBoundingBox: function() {
        null  === this.boundingBox && (this.boundingBox = new THREE.Box3);
        var a = this.attributes.position.array;
        if (a) {
            var b = this.boundingBox;
            3 <= a.length && (b.min.x = b.max.x = a[0],
            b.min.y = b.max.y = a[1],
            b.min.z = b.max.z = a[2]);
            for (var c = 3, e = a.length; c < e; c += 3) {
                var d = a[c]
                  , g = a[c + 1]
                  , f = a[c + 2];
                d < b.min.x ? b.min.x = d : d > b.max.x && (b.max.x = d);
                g < b.min.y ? b.min.y = g : g > b.max.y && (b.max.y = g);
                f < b.min.z ? b.min.z = f : f > b.max.z && (b.max.z = f)
            }
        }
        if (void 0 === a || 0 === a.length)
            this.boundingBox.min.set(0, 0, 0),
            this.boundingBox.max.set(0, 0, 0)
    },
    computeBoundingSphere: function() {
        var a = new THREE.Box3
          , b = new THREE.Vector3;
        return function() {
            null  === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
            var c = this.attributes.position.array;
            if (c) {
                a.makeEmpty();
                for (var e = this.boundingSphere.center, d = 0, g = c.length; d < g; d += 3)
                    b.set(c[d], c[d + 1], c[d + 2]),
                    a.addPoint(b);
                a.center(e);
                for (var f = 0, d = 0, g = c.length; d < g; d += 3)
                    b.set(c[d], c[d + 1], c[d + 2]),
                    f = Math.max(f, e.distanceToSquared(b));
                this.boundingSphere.radius = Math.sqrt(f)
            }
        }
    }
    (),
    computeVertexNormals: function() {
        if (this.attributes.position) {
            var a, b, c, e;
            a = this.attributes.position.array.length;
            if (void 0 === this.attributes.normal)
                this.attributes.normal = {
                    itemSize: 3,
                    array: new Float32Array(a)
                };
            else
                for (a = 0,
                b = this.attributes.normal.array.length; a < b; a++)
                    this.attributes.normal.array[a] = 0;
            var d = this.attributes.position.array, g = this.attributes.normal.array, f, k, h, l, m, n, p = new THREE.Vector3, t = new THREE.Vector3, v = new THREE.Vector3, r = new THREE.Vector3, u = new THREE.Vector3;
            if (this.attributes.index) {
                var w = this.attributes.index.array
                  , x = this.offsets;
                c = 0;
                for (e = x.length; c < e; ++c) {
                    b = x[c].start;
                    f = x[c].count;
                    var A = 
                    x[c].index;
                    a = b;
                    for (b += f; a < b; a += 3)
                        f = A + w[a],
                        k = A + w[a + 1],
                        h = A + w[a + 2],
                        l = d[3 * f],
                        m = d[3 * f + 1],
                        n = d[3 * f + 2],
                        p.set(l, m, n),
                        l = d[3 * k],
                        m = d[3 * k + 1],
                        n = d[3 * k + 2],
                        t.set(l, m, n),
                        l = d[3 * h],
                        m = d[3 * h + 1],
                        n = d[3 * h + 2],
                        v.set(l, m, n),
                        r.subVectors(v, t),
                        u.subVectors(p, t),
                        r.cross(u),
                        g[3 * f] += r.x,
                        g[3 * f + 1] += r.y,
                        g[3 * f + 2] += r.z,
                        g[3 * k] += r.x,
                        g[3 * k + 1] += r.y,
                        g[3 * k + 2] += r.z,
                        g[3 * h] += r.x,
                        g[3 * h + 1] += r.y,
                        g[3 * h + 2] += r.z
                }
            } else
                for (a = 0,
                b = d.length; a < b; a += 9)
                    l = d[a],
                    m = d[a + 1],
                    n = d[a + 2],
                    p.set(l, m, n),
                    l = d[a + 3],
                    m = d[a + 4],
                    n = d[a + 5],
                    t.set(l, m, n),
                    l = d[a + 6],
                    m = d[a + 7],
                    n = d[a + 8],
                    v.set(l, m, n),
                    r.subVectors(v, t),
                    u.subVectors(p, t),
                    r.cross(u),
                    g[a] = r.x,
                    g[a + 1] = r.y,
                    g[a + 2] = r.z,
                    g[a + 3] = r.x,
                    g[a + 4] = r.y,
                    g[a + 5] = r.z,
                    g[a + 6] = r.x,
                    g[a + 7] = r.y,
                    g[a + 8] = r.z;
            this.normalizeNormals();
            this.normalsNeedUpdate = !0
        }
    },
    normalizeNormals: function() {
        for (var a = this.attributes.normal.array, b, c, e, d = 0, g = a.length; d < g; d += 3)
            b = a[d],
            c = a[d + 1],
            e = a[d + 2],
            b = 1 / Math.sqrt(b * b + c * c + e * e),
            a[d] *= b,
            a[d + 1] *= b,
            a[d + 2] *= b
    },
    computeTangents: function() {
        function a(a, f, b) {
            n = e[3 * a];
            p = e[3 * a + 1];
            t = e[3 * a + 2];
            v = e[3 * f];
            r = e[3 * f + 1];
            u = e[3 * f + 2];
            w = e[3 * b];
            x = e[3 * b + 1];
            A = e[3 * b + 2];
            y = g[2 * a];
            z = g[2 * a + 1];
            E = g[2 * f];
            C = g[2 * f + 1];
            B = g[2 * b];
            K = g[2 * b + 1];
            F = v - n;
            O = w - n;
            M = r - p;
            G = x - p;
            Q = u - t;
            R = A - t;
            S = E - y;
            U = B - y;
            H = C - z;
            Z = K - z;
            N = 1 / (S * Z - U * H);
            ca.set((Z * F - H * O) * N, (Z * M - H * G) * N, (Z * Q - H * R) * N);
            J.set((S * O - U * F) * N, (S * G - U * M) * N, (S * R - U * Q) * N);
            h[a].add(ca);
            h[f].add(ca);
            h[b].add(ca);
            l[a].add(J);
            l[f].add(J);
            l[b].add(J)
        }
        function b(a) {
            ma.x = d[3 * a];
            ma.y = d[3 * a + 1];
            ma.z = d[3 * a + 2];
            Ka.copy(ma);
            La = h[a];
            Da.copy(La);
            Da.sub(ma.multiplyScalar(ma.dot(La))).normalize();
            Ra.crossVectors(Ka, La);
            Sa = Ra.dot(l[a]);
            za = 0 > Sa ? 
            -1 : 1;
            k[4 * a] = Da.x;
            k[4 * a + 1] = Da.y;
            k[4 * a + 2] = Da.z;
            k[4 * a + 3] = za
        }
        if (void 0 === this.attributes.index || void 0 === this.attributes.position || void 0 === this.attributes.normal || void 0 === this.attributes.uv)
            console.warn("Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()");
        else {
            var c = this.attributes.index.array
              , e = this.attributes.position.array
              , d = this.attributes.normal.array
              , g = this.attributes.uv.array
              , f = e.length / 3;
            void 0 === this.attributes.tangent && (this.attributes.tangent = 
            {
                itemSize: 4,
                array: new Float32Array(4 * f)
            });
            for (var k = this.attributes.tangent.array, h = [], l = [], m = 0; m < f; m++)
                h[m] = new THREE.Vector3,
                l[m] = new THREE.Vector3;
            var n, p, t, v, r, u, w, x, A, y, z, E, C, B, K, F, O, M, G, Q, R, S, U, H, Z, N, ca = new THREE.Vector3, J = new THREE.Vector3, Y, P, fa, ia, aa, oa = this.offsets, m = 0;
            for (P = oa.length; m < P; ++m) {
                Y = oa[m].start;
                fa = oa[m].count;
                var ya = oa[m].index
                  , f = Y;
                for (Y += fa; f < Y; f += 3)
                    fa = ya + c[f],
                    ia = ya + c[f + 1],
                    aa = ya + c[f + 2],
                    a(fa, ia, aa)
            }
            var Da = new THREE.Vector3, Ra = new THREE.Vector3, ma = new THREE.Vector3, Ka = new THREE.Vector3, 
            za, La, Sa, m = 0;
            for (P = oa.length; m < P; ++m)
                for (Y = oa[m].start,
                fa = oa[m].count,
                ya = oa[m].index,
                f = Y,
                Y += fa; f < Y; f += 3)
                    fa = ya + c[f],
                    ia = ya + c[f + 1],
                    aa = ya + c[f + 2],
                    b(fa),
                    b(ia),
                    b(aa)
        }
    },
    computeOffsets: function(a) {
        var b = a;
        void 0 === a && (b = 65535);
        Date.now();
        a = this.attributes.index.array;
        for (var c = this.attributes.position.array, e = a.length / 3, d = new Uint16Array(a.length), g = 0, f = 0, k = [{
            start: 0,
            count: 0,
            index: 0
        }], h = k[0], l = 0, m = 0, n = new Int32Array(6), p = new Int32Array(c.length), t = new Int32Array(c.length), v = 0; v < c.length; v++)
            p[v] = -1,
            t[v] = -1;
        for (c = 0; c < e; c++) {
            for (var r = m = 0; 3 > r; r++)
                v = a[3 * c + r],
                -1 == p[v] ? (n[2 * r] = v,
                n[2 * r + 1] = -1,
                m++) : p[v] < h.index ? (n[2 * r] = v,
                n[2 * r + 1] = -1,
                l++) : (n[2 * r] = v,
                n[2 * r + 1] = p[v]);
            if (f + m > h.index + b)
                for (h = {
                    start: g,
                    count: 0,
                    index: f
                },
                k.push(h),
                m = 0; 6 > m; m += 2)
                    r = n[m + 1],
                    -1 < r && r < h.index && (n[m + 1] = -1);
            for (m = 0; 6 > m; m += 2)
                v = n[m],
                r = n[m + 1],
                -1 === r && (r = f++),
                p[v] = r,
                t[r] = v,
                d[g++] = r - h.index,
                h.count++
        }
        this.reorderBuffers(d, t, f);
        return this.offsets = k
    },
    reorderBuffers: function(a, b, c) {
        var e = {}, d = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, 
        Int32Array, Uint32Array, Float32Array, Float64Array], g;
        for (g in this.attributes)
            if ("index" != g)
                for (var f = this.attributes[g].array, k = 0, h = d.length; k < h; k++) {
                    var l = d[k];
                    if (f instanceof l) {
                        e[g] = new l(this.attributes[g].itemSize * c);
                        break
                    }
                }
        for (d = 0; d < c; d++)
            for (g in f = b[d],
            this.attributes)
                if ("index" != g)
                    for (var k = this.attributes[g].array, h = this.attributes[g].itemSize, l = e[g], m = 0; m < h; m++)
                        l[d * h + m] = k[f * h + m];
        this.attributes.index.array = a;
        for (g in this.attributes)
            "index" != g && (this.attributes[g].array = e[g],
            this.attributes[g].numItems = 
            this.attributes[g].itemSize * c)
    },
    clone: function() {
        var a = new THREE.BufferGeometry, b = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], c;
        for (c in this.attributes) {
            for (var e = this.attributes[c], d = e.array, g = {
                itemSize: e.itemSize,
                array: null 
            }, e = 0, f = b.length; e < f; e++) {
                var k = b[e];
                if (d instanceof k) {
                    g.array = new k(d);
                    break
                }
            }
            a.attributes[c] = g
        }
        e = 0;
        for (f = this.offsets.length; e < f; e++)
            b = this.offsets[e],
            a.offsets.push({
                start: b.start,
                index: b.index,
                count: b.count
            });
        return a
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype);
THREE.Geometry = function() {
    this.id = THREE.GeometryIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.vertices = [];
    this.colors = [];
    this.faces = [];
    this.faceVertexUvs = [[]];
    this.morphTargets = [];
    this.morphColors = [];
    this.morphNormals = [];
    this.skinWeights = [];
    this.skinIndices = [];
    this.lineDistances = [];
    this.boundingSphere = this.boundingBox = null ;
    this.hasTangents = !1;
    this.dynamic = !0;
    this.buffersNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.tangentsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = 
    this.elementsNeedUpdate = this.verticesNeedUpdate = !1
}
;
THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function(a) {
        for (var b = (new THREE.Matrix3).getNormalMatrix(a), c = 0, e = this.vertices.length; c < e; c++)
            this.vertices[c].applyMatrix4(a);
        c = 0;
        for (e = this.faces.length; c < e; c++) {
            var d = this.faces[c];
            d.normal.applyMatrix3(b).normalize();
            for (var g = 0, f = d.vertexNormals.length; g < f; g++)
                d.vertexNormals[g].applyMatrix3(b).normalize();
            d.centroid.applyMatrix4(a)
        }
        this.boundingBox instanceof THREE.Box3 && this.computeBoundingBox();
        this.boundingSphere instanceof 
        THREE.Sphere && this.computeBoundingSphere()
    },
    computeCentroids: function() {
        var a, b, c;
        a = 0;
        for (b = this.faces.length; a < b; a++)
            c = this.faces[a],
            c.centroid.set(0, 0, 0),
            c.centroid.add(this.vertices[c.a]),
            c.centroid.add(this.vertices[c.b]),
            c.centroid.add(this.vertices[c.c]),
            c.centroid.divideScalar(3)
    },
    computeFaceNormals: function() {
        for (var a = new THREE.Vector3, b = new THREE.Vector3, c = 0, e = this.faces.length; c < e; c++) {
            var d = this.faces[c]
              , g = this.vertices[d.a]
              , f = this.vertices[d.b];
            a.subVectors(this.vertices[d.c], f);
            b.subVectors(g, 
            f);
            a.cross(b);
            a.normalize();
            d.normal.copy(a)
        }
    },
    computeVertexNormals: function(a) {
        var b, c, e;
        e = Array(this.vertices.length);
        b = 0;
        for (c = this.vertices.length; b < c; b++)
            e[b] = new THREE.Vector3;
        if (a) {
            var d, g, f, k = new THREE.Vector3, h = new THREE.Vector3;
            new THREE.Vector3;
            new THREE.Vector3;
            new THREE.Vector3;
            a = 0;
            for (b = this.faces.length; a < b; a++)
                c = this.faces[a],
                d = this.vertices[c.a],
                g = this.vertices[c.b],
                f = this.vertices[c.c],
                k.subVectors(f, g),
                h.subVectors(d, g),
                k.cross(h),
                e[c.a].add(k),
                e[c.b].add(k),
                e[c.c].add(k)
        } else
            for (a = 
            0,
            b = this.faces.length; a < b; a++)
                c = this.faces[a],
                e[c.a].add(c.normal),
                e[c.b].add(c.normal),
                e[c.c].add(c.normal);
        b = 0;
        for (c = this.vertices.length; b < c; b++)
            e[b].normalize();
        a = 0;
        for (b = this.faces.length; a < b; a++)
            c = this.faces[a],
            c.vertexNormals[0] = e[c.a].clone(),
            c.vertexNormals[1] = e[c.b].clone(),
            c.vertexNormals[2] = e[c.c].clone()
    },
    computeMorphNormals: function() {
        var a, b, c, e, d;
        c = 0;
        for (e = this.faces.length; c < e; c++)
            for (d = this.faces[c],
            d.__originalFaceNormal ? d.__originalFaceNormal.copy(d.normal) : d.__originalFaceNormal = 
            d.normal.clone(),
            d.__originalVertexNormals || (d.__originalVertexNormals = []),
            a = 0,
            b = d.vertexNormals.length; a < b; a++)
                d.__originalVertexNormals[a] ? d.__originalVertexNormals[a].copy(d.vertexNormals[a]) : d.__originalVertexNormals[a] = d.vertexNormals[a].clone();
        var g = new THREE.Geometry;
        g.faces = this.faces;
        a = 0;
        for (b = this.morphTargets.length; a < b; a++) {
            if (!this.morphNormals[a]) {
                this.morphNormals[a] = {};
                this.morphNormals[a].faceNormals = [];
                this.morphNormals[a].vertexNormals = [];
                d = this.morphNormals[a].faceNormals;
                var f = 
                this.morphNormals[a].vertexNormals, k, h;
                c = 0;
                for (e = this.faces.length; c < e; c++)
                    k = new THREE.Vector3,
                    h = {
                        a: new THREE.Vector3,
                        b: new THREE.Vector3,
                        c: new THREE.Vector3
                    },
                    d.push(k),
                    f.push(h)
            }
            f = this.morphNormals[a];
            g.vertices = this.morphTargets[a].vertices;
            g.computeFaceNormals();
            g.computeVertexNormals();
            c = 0;
            for (e = this.faces.length; c < e; c++)
                d = this.faces[c],
                k = f.faceNormals[c],
                h = f.vertexNormals[c],
                k.copy(d.normal),
                h.a.copy(d.vertexNormals[0]),
                h.b.copy(d.vertexNormals[1]),
                h.c.copy(d.vertexNormals[2])
        }
        c = 0;
        for (e = this.faces.length; c < 
        e; c++)
            d = this.faces[c],
            d.normal = d.__originalFaceNormal,
            d.vertexNormals = d.__originalVertexNormals
    },
    computeTangents: function() {
        var a, b, c, e, d, g, f, k, h, l, m, n, p, t, v, r, u, w = [], x = [];
        c = new THREE.Vector3;
        var A = new THREE.Vector3
          , y = new THREE.Vector3
          , z = new THREE.Vector3
          , E = new THREE.Vector3;
        a = 0;
        for (b = this.vertices.length; a < b; a++)
            w[a] = new THREE.Vector3,
            x[a] = new THREE.Vector3;
        a = 0;
        for (b = this.faces.length; a < b; a++)
            d = this.faces[a],
            g = this.faceVertexUvs[0][a],
            e = d.a,
            u = d.b,
            d = d.c,
            f = this.vertices[e],
            k = this.vertices[u],
            h = this.vertices[d],
            l = g[0],
            m = g[1],
            n = g[2],
            g = k.x - f.x,
            p = h.x - f.x,
            t = k.y - f.y,
            v = h.y - f.y,
            k = k.z - f.z,
            f = h.z - f.z,
            h = m.x - l.x,
            r = n.x - l.x,
            m = m.y - l.y,
            l = n.y - l.y,
            n = 1 / (h * l - r * m),
            c.set((l * g - m * p) * n, (l * t - m * v) * n, (l * k - m * f) * n),
            A.set((h * p - r * g) * n, (h * v - r * t) * n, (h * f - r * k) * n),
            w[e].add(c),
            w[u].add(c),
            w[d].add(c),
            x[e].add(A),
            x[u].add(A),
            x[d].add(A);
        A = ["a", "b", "c", "d"];
        a = 0;
        for (b = this.faces.length; a < b; a++)
            for (d = this.faces[a],
            c = 0; c < Math.min(d.vertexNormals.length, 3); c++)
                E.copy(d.vertexNormals[c]),
                e = d[A[c]],
                u = w[e],
                y.copy(u),
                y.sub(E.multiplyScalar(E.dot(u))).normalize(),
                z.crossVectors(d.vertexNormals[c], u),
                e = z.dot(x[e]),
                e = 0 > e ? -1 : 1,
                d.vertexTangents[c] = new THREE.Vector4(y.x,y.y,y.z,e);
        this.hasTangents = !0
    },
    computeLineDistances: function() {
        for (var a = 0, b = this.vertices, c = 0, e = b.length; c < e; c++)
            0 < c && (a += b[c].distanceTo(b[c - 1])),
            this.lineDistances[c] = a
    },
    computeBoundingBox: function() {
        null  === this.boundingBox && (this.boundingBox = new THREE.Box3);
        this.boundingBox.setFromPoints(this.vertices)
    },
    computeBoundingSphere: function() {
        null  === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
        this.boundingSphere.setFromPoints(this.vertices)
    },
    mergeVertices: function() {
        var a = {}, b = [], c = [], e, d = Math.pow(10, 4), g, f;
        g = 0;
        for (f = this.vertices.length; g < f; g++)
            e = this.vertices[g],
            e = Math.round(e.x * d) + "_" + Math.round(e.y * d) + "_" + Math.round(e.z * d),
            void 0 === a[e] ? (a[e] = g,
            b.push(this.vertices[g]),
            c[g] = b.length - 1) : c[g] = c[a[e]];
        a = [];
        g = 0;
        for (f = this.faces.length; g < f; g++)
            for (d = this.faces[g],
            d.a = c[d.a],
            d.b = c[d.b],
            d.c = c[d.c],
            d = [d.a, d.b, d.c],
            e = 0; 3 > e; e++)
                if (d[e] == d[(e + 1) % 3]) {
                    a.push(g);
                    break
                }
        for (g = a.length - 1; 0 <= g; g--)
            for (d = 
            a[g],
            this.faces.splice(d, 1),
            c = 0,
            f = this.faceVertexUvs.length; c < f; c++)
                this.faceVertexUvs[c].splice(d, 1);
        g = this.vertices.length - b.length;
        this.vertices = b;
        return g
    },
    makeGroups: function() {
        var a = 0;
        return function(b) {
            var c, e, d, g, f = {}, k = this.morphTargets.length, h = this.morphNormals.length;
            this.geometryGroups = {};
            c = 0;
            for (e = this.faces.length; c < e; c++)
                d = this.faces[c],
                d = b ? d.materialIndex : 0,
                d in f || (f[d] = {
                    hash: d,
                    counter: 0
                }),
                g = f[d].hash + "_" + f[d].counter,
                g in this.geometryGroups || (this.geometryGroups[g] = {
                    faces3: [],
                    materialIndex: d,
                    vertices: 0,
                    numMorphTargets: k,
                    numMorphNormals: h
                }),
                65535 < this.geometryGroups[g].vertices + 3 && (f[d].counter += 1,
                g = f[d].hash + "_" + f[d].counter,
                g in this.geometryGroups || (this.geometryGroups[g] = {
                    faces3: [],
                    materialIndex: d,
                    vertices: 0,
                    numMorphTargets: k,
                    numMorphNormals: h
                })),
                this.geometryGroups[g].faces3.push(c),
                this.geometryGroups[g].vertices += 3;
            this.geometryGroupsList = [];
            for (var l in this.geometryGroups)
                this.geometryGroups[l].id = a++,
                this.geometryGroupsList.push(this.geometryGroups[l])
        }
    }
    (),
    clone: function() {
        for (var a = 
        new THREE.Geometry, b = this.vertices, c = 0, e = b.length; c < e; c++)
            a.vertices.push(b[c].clone());
        b = this.faces;
        c = 0;
        for (e = b.length; c < e; c++)
            a.faces.push(b[c].clone());
        b = this.faceVertexUvs[0];
        c = 0;
        for (e = b.length; c < e; c++) {
            for (var d = b[c], g = [], f = 0, k = d.length; f < k; f++)
                g.push(new THREE.Vector2(d[f].x,d[f].y));
            a.faceVertexUvs[0].push(g)
        }
        return a
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype);
THREE.GeometryIdCount = 0;
THREE.Geometry2 = function(a) {
    THREE.BufferGeometry.call(this);
    this.vertices = this.addAttribute("position", Float32Array, a, 3).array;
    this.normals = this.addAttribute("normal", Float32Array, a, 3).array;
    this.uvs = this.addAttribute("uv", Float32Array, a, 2).array;
    this.boundingSphere = this.boundingBox = null 
}
;
THREE.Geometry2.prototype = Object.create(THREE.BufferGeometry.prototype);
THREE.Camera = function() {
    THREE.Object3D.call(this);
    this.matrixWorldInverse = new THREE.Matrix4;
    this.projectionMatrix = new THREE.Matrix4
}
;
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype);
THREE.Camera.prototype.lookAt = function() {
    var a = new THREE.Matrix4;
    return function(b) {
        a.lookAt(this.position, b, this.up);
        this.quaternion.setFromRotationMatrix(a)
    }
}
();
THREE.Camera.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.Camera);
    THREE.Object3D.prototype.clone.call(this, a);
    a.matrixWorldInverse.copy(this.matrixWorldInverse);
    a.projectionMatrix.copy(this.projectionMatrix);
    return a
}
;
THREE.OrthographicCamera = function(a, b, c, e, d, g) {
    THREE.Camera.call(this);
    this.left = a;
    this.right = b;
    this.top = c;
    this.bottom = e;
    this.near = void 0 !== d ? d : .1;
    this.far = void 0 !== g ? g : 2E3;
    this.updateProjectionMatrix()
}
;
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
    this.projectionMatrix.makeOrthographic(this.left, this.right, this.top, this.bottom, this.near, this.far)
}
;
THREE.OrthographicCamera.prototype.clone = function() {
    var a = new THREE.OrthographicCamera;
    THREE.Camera.prototype.clone.call(this, a);
    a.left = this.left;
    a.right = this.right;
    a.top = this.top;
    a.bottom = this.bottom;
    a.near = this.near;
    a.far = this.far;
    return a
}
;
THREE.PerspectiveCamera = function(a, b, c, e) {
    THREE.Camera.call(this);
    this.fov = void 0 !== a ? a : 50;
    this.aspect = void 0 !== b ? b : 1;
    this.near = void 0 !== c ? c : .1;
    this.far = void 0 !== e ? e : 2E3;
    this.updateProjectionMatrix()
}
;
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.PerspectiveCamera.prototype.setLens = function(a, b) {
    void 0 === b && (b = 24);
    this.fov = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
    this.updateProjectionMatrix()
}
;
THREE.PerspectiveCamera.prototype.setViewOffset = function(a, b, c, e, d, g) {
    this.fullWidth = a;
    this.fullHeight = b;
    this.x = c;
    this.y = e;
    this.width = d;
    this.height = g;
    this.updateProjectionMatrix()
}
;
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
    if (this.fullWidth) {
        var a = this.fullWidth / this.fullHeight
          , b = Math.tan(THREE.Math.degToRad(.5 * this.fov)) * this.near
          , c = -b
          , e = a * c
          , a = Math.abs(a * b - e)
          , c = Math.abs(b - c);
        this.projectionMatrix.makeFrustum(e + this.x * a / this.fullWidth, e + (this.x + this.width) * a / this.fullWidth, b - (this.y + this.height) * c / this.fullHeight, b - this.y * c / this.fullHeight, this.near, this.far)
    } else
        this.projectionMatrix.makePerspective(this.fov, this.aspect, this.near, this.far)
}
;
THREE.PerspectiveCamera.prototype.clone = function() {
    var a = new THREE.PerspectiveCamera;
    THREE.Camera.prototype.clone.call(this, a);
    a.fov = this.fov;
    a.aspect = this.aspect;
    a.near = this.near;
    a.far = this.far;
    return a
}
;
THREE.Light = function(a) {
    THREE.Object3D.call(this);
    this.color = new THREE.Color(a)
}
;
THREE.Light.prototype = Object.create(THREE.Object3D.prototype);
THREE.Light.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.Light);
    THREE.Object3D.prototype.clone.call(this, a);
    a.color.copy(this.color);
    return a
}
;
THREE.AmbientLight = function(a) {
    THREE.Light.call(this, a)
}
;
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype);
THREE.AmbientLight.prototype.clone = function() {
    var a = new THREE.AmbientLight;
    THREE.Light.prototype.clone.call(this, a);
    return a
}
;
THREE.AreaLight = function(a, b) {
    THREE.Light.call(this, a);
    this.normal = new THREE.Vector3(0,-1,0);
    this.right = new THREE.Vector3(1,0,0);
    this.intensity = void 0 !== b ? b : 1;
    this.height = this.width = 1;
    this.constantAttenuation = 1.5;
    this.linearAttenuation = .5;
    this.quadraticAttenuation = .1
}
;
THREE.AreaLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight = function(a, b) {
    THREE.Light.call(this, a);
    this.position.set(0, 1, 0);
    this.target = new THREE.Object3D;
    this.intensity = void 0 !== b ? b : 1;
    this.onlyShadow = this.castShadow = !1;
    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5E3;
    this.shadowCameraLeft = -500;
    this.shadowCameraTop = this.shadowCameraRight = 500;
    this.shadowCameraBottom = -500;
    this.shadowCameraVisible = !1;
    this.shadowBias = 0;
    this.shadowDarkness = .5;
    this.shadowMapHeight = this.shadowMapWidth = 512;
    this.shadowCascade = !1;
    this.shadowCascadeOffset = new THREE.Vector3(0,
    0,-1E3);
    this.shadowCascadeCount = 2;
    this.shadowCascadeBias = [0, 0, 0];
    this.shadowCascadeWidth = [512, 512, 512];
    this.shadowCascadeHeight = [512, 512, 512];
    this.shadowCascadeNearZ = [-1, .99, .998];
    this.shadowCascadeFarZ = [.99, .998, 1];
    this.shadowCascadeArray = [];
    this.shadowMatrix = this.shadowCamera = this.shadowMapSize = this.shadowMap = null 
}
;
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype);
THREE.DirectionalLight.prototype.clone = function() {
    var a = new THREE.DirectionalLight;
    THREE.Light.prototype.clone.call(this, a);
    a.target = this.target.clone();
    a.intensity = this.intensity;
    a.castShadow = this.castShadow;
    a.onlyShadow = this.onlyShadow;
    return a
}
;
THREE.HemisphereLight = function(a, b, c) {
    THREE.Light.call(this, a);
    this.position.set(0, 100, 0);
    this.groundColor = new THREE.Color(b);
    this.intensity = void 0 !== c ? c : 1
}
;
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype);
THREE.HemisphereLight.prototype.clone = function() {
    var a = new THREE.HemisphereLight;
    THREE.Light.prototype.clone.call(this, a);
    a.groundColor.copy(this.groundColor);
    a.intensity = this.intensity;
    return a
}
;
THREE.PointLight = function(a, b, c) {
    THREE.Light.call(this, a);
    this.intensity = void 0 !== b ? b : 1;
    this.distance = void 0 !== c ? c : 0
}
;
THREE.PointLight.prototype = Object.create(THREE.Light.prototype);
THREE.PointLight.prototype.clone = function() {
    var a = new THREE.PointLight;
    THREE.Light.prototype.clone.call(this, a);
    a.intensity = this.intensity;
    a.distance = this.distance;
    return a
}
;
THREE.SpotLight = function(a, b, c, e, d) {
    THREE.Light.call(this, a);
    this.position.set(0, 1, 0);
    this.target = new THREE.Object3D;
    this.intensity = void 0 !== b ? b : 1;
    this.distance = void 0 !== c ? c : 0;
    this.angle = void 0 !== e ? e : Math.PI / 3;
    this.exponent = void 0 !== d ? d : 10;
    this.onlyShadow = this.castShadow = !1;
    this.shadowCameraNear = 50;
    this.shadowCameraFar = 5E3;
    this.shadowCameraFov = 50;
    this.shadowCameraVisible = !1;
    this.shadowBias = 0;
    this.shadowDarkness = .5;
    this.shadowMapHeight = this.shadowMapWidth = 512;
    this.shadowMatrix = this.shadowCamera = this.shadowMapSize = 
    this.shadowMap = null 
}
;
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype);
THREE.SpotLight.prototype.clone = function() {
    var a = new THREE.SpotLight;
    THREE.Light.prototype.clone.call(this, a);
    a.target = this.target.clone();
    a.intensity = this.intensity;
    a.distance = this.distance;
    a.angle = this.angle;
    a.exponent = this.exponent;
    a.castShadow = this.castShadow;
    a.onlyShadow = this.onlyShadow;
    return a
}
;
THREE.Loader = function(a) {
    this.statusDomElement = (this.showStatus = a) ? THREE.Loader.prototype.addStatusElement() : null ;
    this.onLoadStart = function() {}
    ;
    this.onLoadProgress = function() {}
    ;
    this.onLoadComplete = function() {}
}
;
THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: void 0,
    addStatusElement: function() {
        var a = document.createElement("div");
        a.style.position = "absolute";
        a.style.right = "0px";
        a.style.top = "0px";
        a.style.fontSize = "0.8em";
        a.style.textAlign = "left";
        a.style.background = "rgba(0,0,0,0.25)";
        a.style.color = "#fff";
        a.style.width = "120px";
        a.style.padding = "0.5em 0.5em 0.5em 0.5em";
        a.style.zIndex = 1E3;
        a.innerHTML = "Loading ...";
        return a
    },
    updateProgress: function(a) {
        var b = "Loaded "
          , b = a.total ? b + ((100 * a.loaded / a.total).toFixed(0) + 
        "%") : b + ((a.loaded / 1E3).toFixed(2) + " KB");
        this.statusDomElement.innerHTML = b
    },
    extractUrlBase: function(a) {
        a = a.split("/");
        if (1 === a.length)
            return "./";
        a.pop();
        return a.join("/") + "/"
    },
    initMaterials: function(a, b) {
        for (var c = [], e = 0; e < a.length; ++e)
            c[e] = THREE.Loader.prototype.createMaterial(a[e], b);
        return c
    },
    needsTangents: function(a) {
        for (var b = 0, c = a.length; b < c; b++)
            if (a[b] instanceof THREE.ShaderMaterial)
                return !0;
        return !1
    },
    createMaterial: function(a, b) {
        function c(a) {
            a = Math.log(a) / Math.LN2;
            return Math.floor(a) == 
            a
        }
        function e(a) {
            a = Math.log(a) / Math.LN2;
            return Math.pow(2, Math.round(a))
        }
        function d(a, f) {
            var b = new Image;
            b.onload = function() {
                if (c(this.width) && c(this.height))
                    a.image = this;
                else {
                    var f = e(this.width)
                      , b = e(this.height);
                    a.image.width = f;
                    a.image.height = b;
                    a.image.getContext("2d").drawImage(this, 0, 0, f, b)
                }
                a.needsUpdate = !0
            }
            ;
            void 0 !== k.crossOrigin && (b.crossOrigin = k.crossOrigin);
            b.src = f
        }
        function g(a, f, c, k, e, h, g) {
            var l = /\.dds$/i.test(c)
              , m = b + c;
            if (l) {
                var y = THREE.ImageUtils.loadCompressedTexture(m);
                a[f] = y
            } else
                y = document.createElement("canvas"),
                a[f] = new THREE.Texture(y);
            a[f].sourceFile = c;
            k && (a[f].repeat.set(k[0], k[1]),
            1 !== k[0] && (a[f].wrapS = THREE.RepeatWrapping),
            1 !== k[1] && (a[f].wrapT = THREE.RepeatWrapping));
            e && a[f].offset.set(e[0], e[1]);
            h && (c = {
                repeat: THREE.RepeatWrapping,
                mirror: THREE.MirroredRepeatWrapping
            },
            void 0 !== c[h[0]] && (a[f].wrapS = c[h[0]]),
            void 0 !== c[h[1]] && (a[f].wrapT = c[h[1]]));
            g && (a[f].anisotropy = g);
            l || d(a[f], m)
        }
        function f(a) {
            return (255 * a[0] << 16) + (255 * a[1] << 8) + 255 * a[2]
        }
        var k = this
          , h = "MeshLambertMaterial"
          , l = {
            color: 15658734,
            opacity: 1,
            map: null ,
            lightMap: null ,
            normalMap: null ,
            bumpMap: null ,
            wireframe: !1
        };
        if (a.shading) {
            var m = a.shading.toLowerCase();
            "phong" === m ? h = "MeshPhongMaterial" : "basic" === m && (h = "MeshBasicMaterial")
        }
        void 0 !== a.blending && void 0 !== THREE[a.blending] && (l.blending = THREE[a.blending]);
        if (void 0 !== a.transparent || 1 > a.opacity)
            l.transparent = a.transparent;
        void 0 !== a.depthTest && (l.depthTest = a.depthTest);
        void 0 !== a.depthWrite && (l.depthWrite = a.depthWrite);
        void 0 !== a.visible && (l.visible = a.visible);
        void 0 !== a.flipSided && (l.side = THREE.BackSide);
        void 0 !== a.doubleSided && (l.side = THREE.DoubleSide);
        void 0 !== a.wireframe && (l.wireframe = a.wireframe);
        void 0 !== a.vertexColors && ("face" === a.vertexColors ? l.vertexColors = THREE.FaceColors : a.vertexColors && (l.vertexColors = THREE.VertexColors));
        a.colorDiffuse ? l.color = f(a.colorDiffuse) : a.DbgColor && (l.color = a.DbgColor);
        a.colorSpecular && (l.specular = f(a.colorSpecular));
        a.colorAmbient && (l.ambient = f(a.colorAmbient));
        a.transparency && (l.opacity = a.transparency);
        a.specularCoef && (l.shininess = a.specularCoef);
        a.mapDiffuse && 
        b && g(l, "map", a.mapDiffuse, a.mapDiffuseRepeat, a.mapDiffuseOffset, a.mapDiffuseWrap, a.mapDiffuseAnisotropy);
        a.mapLight && b && g(l, "lightMap", a.mapLight, a.mapLightRepeat, a.mapLightOffset, a.mapLightWrap, a.mapLightAnisotropy);
        a.mapBump && b && g(l, "bumpMap", a.mapBump, a.mapBumpRepeat, a.mapBumpOffset, a.mapBumpWrap, a.mapBumpAnisotropy);
        a.mapNormal && b && g(l, "normalMap", a.mapNormal, a.mapNormalRepeat, a.mapNormalOffset, a.mapNormalWrap, a.mapNormalAnisotropy);
        a.mapSpecular && b && g(l, "specularMap", a.mapSpecular, a.mapSpecularRepeat, 
        a.mapSpecularOffset, a.mapSpecularWrap, a.mapSpecularAnisotropy);
        a.mapBumpScale && (l.bumpScale = a.mapBumpScale);
        a.mapNormal ? (h = THREE.ShaderLib.normalmap,
        m = THREE.UniformsUtils.clone(h.uniforms),
        m.tNormal.value = l.normalMap,
        a.mapNormalFactor && m.uNormalScale.value.set(a.mapNormalFactor, a.mapNormalFactor),
        l.map && (m.tDiffuse.value = l.map,
        m.enableDiffuse.value = !0),
        l.specularMap && (m.tSpecular.value = l.specularMap,
        m.enableSpecular.value = !0),
        l.lightMap && (m.tAO.value = l.lightMap,
        m.enableAO.value = !0),
        m.diffuse.value.setHex(l.color),
        m.specular.value.setHex(l.specular),
        m.ambient.value.setHex(l.ambient),
        m.shininess.value = l.shininess,
        void 0 !== l.opacity && (m.opacity.value = l.opacity),
        h = new THREE.ShaderMaterial({
            fragmentShader: h.fragmentShader,
            vertexShader: h.vertexShader,
            uniforms: m,
            lights: !0,
            fog: !0
        }),
        l.transparent && (h.transparent = !0)) : h = new THREE[h](l);
        void 0 !== a.DbgName && (h.name = a.DbgName);
        return h
    }
};
THREE.XHRLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
}
;
THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function(a, b, c, e) {
        var d = this
          , g = new XMLHttpRequest;
        void 0 !== b && g.addEventListener("load", function(f) {
            b(f.target.responseText);
            d.manager.itemEnd(a)
        }
        , !1);
        void 0 !== c && g.addEventListener("progress", function(a) {
            c(a)
        }
        , !1);
        void 0 !== e && g.addEventListener("error", function(a) {
            e(a)
        }
        , !1);
        void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin);
        g.open("GET", a, !0);
        g.send(null );
        d.manager.itemStart(a)
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a
    }
};
THREE.ImageLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
}
;
THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function(a, b, c, e) {
        var d = this
          , g = document.createElement("img");
        void 0 !== b && g.addEventListener("load", function(f) {
            d.manager.itemEnd(a);
            b(this)
        }
        , !1);
        void 0 !== c && g.addEventListener("progress", function(a) {
            c(a)
        }
        , !1);
        void 0 !== e && g.addEventListener("error", function(a) {
            e(a)
        }
        , !1);
        void 0 !== this.crossOrigin && (g.crossOrigin = this.crossOrigin);
        g.src = a;
        d.manager.itemStart(a);
        return g
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a
    }
};
THREE.LoadingManager = function(a, b, c) {
    var e = this
      , d = 0
      , g = 0;
    this.onLoad = a;
    this.onProgress = b;
    this.onError = c;
    this.itemStart = function(a) {
        g++
    }
    ;
    this.itemEnd = function(a) {
        d++;
        if (void 0 !== e.onProgress)
            e.onProgress(a, d, g);
        if (d === g && void 0 !== e.onLoad)
            e.onLoad()
    }
}
;
THREE.DefaultLoadingManager = new THREE.LoadingManager;
THREE.TextureLoader = function(a) {
    this.manager = void 0 !== a ? a : THREE.DefaultLoadingManager
}
;
THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function(a, b, c, e) {
        c = new THREE.ImageLoader(this.manager);
        c.setCrossOrigin(this.crossOrigin);
        c.load(a, function(a) {
            a = new THREE.Texture(a);
            a.needsUpdate = !0;
            void 0 !== b && b(a)
        }
        )
    },
    setCrossOrigin: function(a) {
        this.crossOrigin = a
    }
};
THREE.Material = function() {
    this.id = THREE.MaterialIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.side = THREE.FrontSide;
    this.opacity = 1;
    this.transparent = !1;
    this.blending = THREE.NormalBlending;
    this.blendSrc = THREE.SrcAlphaFactor;
    this.blendDst = THREE.OneMinusSrcAlphaFactor;
    this.blendEquation = THREE.AddEquation;
    this.depthWrite = this.depthTest = !0;
    this.polygonOffset = !1;
    this.overdraw = this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0;
    this.needsUpdate = this.visible = !0
}
;
THREE.Material.prototype = {
    constructor: THREE.Material,
    setValues: function(a) {
        if (void 0 !== a)
            for (var b in a) {
                var c = a[b];
                if (void 0 === c)
                    console.warn("THREE.Material: '" + b + "' parameter is undefined.");
                else if (b in this) {
                    var e = this[b];
                    e instanceof THREE.Color ? e.set(c) : e instanceof THREE.Vector3 && c instanceof THREE.Vector3 ? e.copy(c) : this[b] = "overdraw" == b ? Number(c) : c
                }
            }
    },
    clone: function(a) {
        void 0 === a && (a = new THREE.Material);
        a.name = this.name;
        a.side = this.side;
        a.opacity = this.opacity;
        a.transparent = this.transparent;
        a.blending = this.blending;
        a.blendSrc = this.blendSrc;
        a.blendDst = this.blendDst;
        a.blendEquation = this.blendEquation;
        a.depthTest = this.depthTest;
        a.depthWrite = this.depthWrite;
        a.polygonOffset = this.polygonOffset;
        a.polygonOffsetFactor = this.polygonOffsetFactor;
        a.polygonOffsetUnits = this.polygonOffsetUnits;
        a.alphaTest = this.alphaTest;
        a.overdraw = this.overdraw;
        a.visible = this.visible;
        return a
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype);
THREE.MaterialIdCount = 0;
THREE.LineBasicMaterial = function(a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.linewidth = 1;
    this.linejoin = this.linecap = "round";
    this.vertexColors = !1;
    this.fog = !0;
    this.setValues(a)
}
;
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineBasicMaterial.prototype.clone = function() {
    var a = new THREE.LineBasicMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.linewidth = this.linewidth;
    a.linecap = this.linecap;
    a.linejoin = this.linejoin;
    a.vertexColors = this.vertexColors;
    a.fog = this.fog;
    return a
}
;
THREE.LineDashedMaterial = function(a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.scale = this.linewidth = 1;
    this.dashSize = 3;
    this.gapSize = 1;
    this.vertexColors = !1;
    this.fog = !0;
    this.setValues(a)
}
;
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.LineDashedMaterial.prototype.clone = function() {
    var a = new THREE.LineDashedMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.linewidth = this.linewidth;
    a.scale = this.scale;
    a.dashSize = this.dashSize;
    a.gapSize = this.gapSize;
    a.vertexColors = this.vertexColors;
    a.fog = this.fog;
    return a
}
;
THREE.MeshBasicMaterial = function(a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.envMap = this.specularMap = this.lightMap = this.map = null ;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.vertexColors = THREE.NoColors;
    this.morphTargets = this.skinning = !1;
    this.setValues(a)
}
;
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshBasicMaterial.prototype.clone = function() {
    var a = new THREE.MeshBasicMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin = 
    this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    return a
}
;
THREE.MeshLambertMaterial = function(a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.ambient = new THREE.Color(16777215);
    this.emissive = new THREE.Color(0);
    this.wrapAround = !1;
    this.wrapRGB = new THREE.Vector3(1,1,1);
    this.envMap = this.specularMap = this.lightMap = this.map = null ;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = .98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = 
    "round";
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
}
;
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshLambertMaterial.prototype.clone = function() {
    var a = new THREE.MeshLambertMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.ambient.copy(this.ambient);
    a.emissive.copy(this.emissive);
    a.wrapAround = this.wrapAround;
    a.wrapRGB.copy(this.wrapRGB);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin = this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
}
;
THREE.MeshPhongMaterial = function(a) {
    THREE.Material.call(this);
    this.color = new THREE.Color(16777215);
    this.ambient = new THREE.Color(16777215);
    this.emissive = new THREE.Color(0);
    this.specular = new THREE.Color(1118481);
    this.shininess = 30;
    this.wrapAround = this.metal = !1;
    this.wrapRGB = new THREE.Vector3(1,1,1);
    this.bumpMap = this.lightMap = this.map = null ;
    this.bumpScale = 1;
    this.normalMap = null ;
    this.normalScale = new THREE.Vector2(1,1);
    this.envMap = this.specularMap = null ;
    this.combine = THREE.MultiplyOperation;
    this.reflectivity = 
    1;
    this.refractionRatio = .98;
    this.fog = !0;
    this.shading = THREE.SmoothShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.wireframeLinejoin = this.wireframeLinecap = "round";
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.setValues(a)
}
;
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshPhongMaterial.prototype.clone = function() {
    var a = new THREE.MeshPhongMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.color.copy(this.color);
    a.ambient.copy(this.ambient);
    a.emissive.copy(this.emissive);
    a.specular.copy(this.specular);
    a.shininess = this.shininess;
    a.metal = this.metal;
    a.wrapAround = this.wrapAround;
    a.wrapRGB.copy(this.wrapRGB);
    a.map = this.map;
    a.lightMap = this.lightMap;
    a.bumpMap = this.bumpMap;
    a.bumpScale = this.bumpScale;
    a.normalMap = this.normalMap;
    a.normalScale.copy(this.normalScale);
    a.specularMap = this.specularMap;
    a.envMap = this.envMap;
    a.combine = this.combine;
    a.reflectivity = this.reflectivity;
    a.refractionRatio = this.refractionRatio;
    a.fog = this.fog;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.wireframeLinecap = this.wireframeLinecap;
    a.wireframeLinejoin = this.wireframeLinejoin;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
}
;
THREE.MeshDepthMaterial = function(a) {
    THREE.Material.call(this);
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.setValues(a)
}
;
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshDepthMaterial.prototype.clone = function() {
    var a = new THREE.MeshDepthMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    return a
}
;
THREE.MeshNormalMaterial = function(a) {
    THREE.Material.call(this, a);
    this.shading = THREE.FlatShading;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.morphTargets = !1;
    this.setValues(a)
}
;
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.MeshNormalMaterial.prototype.clone = function() {
    var a = new THREE.MeshNormalMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    return a
}
;
THREE.MeshFaceMaterial = function(a) {
    this.materials = a instanceof Array ? a : []
}
;
THREE.MeshFaceMaterial.prototype.clone = function() {
    for (var a = new THREE.MeshFaceMaterial, b = 0; b < this.materials.length; b++)
        a.materials.push(this.materials[b].clone());
    return a
}
;
THREE.ShaderMaterial = function(a) {
    THREE.Material.call(this);
    this.vertexShader = this.fragmentShader = "void main() {}";
    this.uniforms = {};
    this.defines = {};
    this.attributes = null ;
    this.shading = THREE.SmoothShading;
    this.linewidth = 1;
    this.wireframe = !1;
    this.wireframeLinewidth = 1;
    this.lights = this.fog = !1;
    this.vertexColors = THREE.NoColors;
    this.morphNormals = this.morphTargets = this.skinning = !1;
    this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
    };
    this.index0AttributeName = "position";
    this.setValues(a)
}
;
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype);
THREE.ShaderMaterial.prototype.clone = function() {
    var a = new THREE.ShaderMaterial;
    THREE.Material.prototype.clone.call(this, a);
    a.fragmentShader = this.fragmentShader;
    a.vertexShader = this.vertexShader;
    a.uniforms = THREE.UniformsUtils.clone(this.uniforms);
    a.attributes = this.attributes;
    a.defines = this.defines;
    a.shading = this.shading;
    a.wireframe = this.wireframe;
    a.wireframeLinewidth = this.wireframeLinewidth;
    a.fog = this.fog;
    a.lights = this.lights;
    a.vertexColors = this.vertexColors;
    a.skinning = this.skinning;
    a.morphTargets = 
    this.morphTargets;
    a.morphNormals = this.morphNormals;
    return a
}
;
THREE.Texture = function(a, b, c, e, d, g, f, k, h) {
    this.id = THREE.TextureIdCount++;
    this.uuid = THREE.Math.generateUUID();
    this.name = "";
    this.image = a;
    this.mipmaps = [];
    this.mapping = void 0 !== b ? b : new THREE.UVMapping;
    this.wrapS = void 0 !== c ? c : THREE.ClampToEdgeWrapping;
    this.wrapT = void 0 !== e ? e : THREE.ClampToEdgeWrapping;
    this.magFilter = void 0 !== d ? d : THREE.LinearFilter;
    this.minFilter = void 0 !== g ? g : THREE.LinearMipMapLinearFilter;
    this.anisotropy = void 0 !== h ? h : 1;
    this.format = void 0 !== f ? f : THREE.RGBAFormat;
    this.type = void 0 !== k ? k : THREE.UnsignedByteType;
    this.offset = new THREE.Vector2(0,0);
    this.repeat = new THREE.Vector2(1,1);
    this.generateMipmaps = !0;
    this.premultiplyAlpha = !1;
    this.flipY = !0;
    this.unpackAlignment = 4;
    this._needsUpdate = !1;
    this.onUpdate = null 
}
;
THREE.Texture.prototype = {
    constructor: THREE.Texture,
    get needsUpdate() {
        return this._needsUpdate
    },
    set needsUpdate(a) {
        !0 === a && this.update();
        this._needsUpdate = a
    },
    clone: function(a) {
        void 0 === a && (a = new THREE.Texture);
        a.image = this.image;
        a.mipmaps = this.mipmaps.slice(0);
        a.mapping = this.mapping;
        a.wrapS = this.wrapS;
        a.wrapT = this.wrapT;
        a.magFilter = this.magFilter;
        a.minFilter = this.minFilter;
        a.anisotropy = this.anisotropy;
        a.format = this.format;
        a.type = this.type;
        a.offset.copy(this.offset);
        a.repeat.copy(this.repeat);
        a.generateMipmaps = 
        this.generateMipmaps;
        a.premultiplyAlpha = this.premultiplyAlpha;
        a.flipY = this.flipY;
        a.unpackAlignment = this.unpackAlignment;
        return a
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        })
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype);
THREE.TextureIdCount = 0;
THREE.CompressedTexture = function(a, b, c, e, d, g, f, k, h, l, m) {
    THREE.Texture.call(this, null , g, f, k, h, l, e, d, m);
    this.image = {
        width: b,
        height: c
    };
    this.mipmaps = a;
    this.generateMipmaps = !1
}
;
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.CompressedTexture.prototype.clone = function() {
    var a = new THREE.CompressedTexture;
    THREE.Texture.prototype.clone.call(this, a);
    return a
}
;
THREE.DataTexture = function(a, b, c, e, d, g, f, k, h, l, m) {
    THREE.Texture.call(this, null , g, f, k, h, l, e, d, m);
    this.image = {
        data: a,
        width: b,
        height: c
    }
}
;
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype);
THREE.DataTexture.prototype.clone = function() {
    var a = new THREE.DataTexture;
    THREE.Texture.prototype.clone.call(this, a);
    return a
}
;
THREE.Line = function(a, b, c) {
    THREE.Object3D.call(this);
    this.geometry = void 0 !== a ? a : new THREE.Geometry;
    this.material = void 0 !== b ? b : new THREE.LineBasicMaterial({
        color: 16777215 * Math.random()
    });
    this.type = void 0 !== c ? c : THREE.LineStrip
}
;
THREE.LineStrip = 0;
THREE.LinePieces = 1;
THREE.Line.prototype = Object.create(THREE.Object3D.prototype);
THREE.Line.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.Line(this.geometry,this.material,this.type));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
}
;
THREE.Mesh = function(a, b, c) {
    THREE.Object3D.call(this, c);
    this.geometry = void 0 !== a ? a : new THREE.Geometry;
    this.material = void 0 !== b ? b : new THREE.MeshBasicMaterial({
        color: 16777215 * Math.random()
    });
    this.updateMorphTargets()
}
;
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype);
THREE.Mesh.prototype.updateMorphTargets = function() {
    if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
        this.morphTargetBase = -1;
        this.morphTargetForcedOrder = [];
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (var a = 0, b = this.geometry.morphTargets.length; a < b; a++)
            this.morphTargetInfluences.push(0),
            this.morphTargetDictionary[this.geometry.morphTargets[a].name] = a
    }
}
;
THREE.Mesh.prototype.getMorphTargetIndexByName = function(a) {
    if (void 0 !== this.morphTargetDictionary[a])
        return this.morphTargetDictionary[a];
    console.log("THREE.Mesh.getMorphTargetIndexByName: morph target " + a + " does not exist. Returning 0.");
    return 0
}
;
THREE.Mesh.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.Mesh(this.geometry,this.material));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
}
;
THREE.Bone = function(a) {
    THREE.Object3D.call(this);
    this.skin = a;
    this.skinMatrix = new THREE.Matrix4
}
;
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype);
THREE.Bone.prototype.update = function(a, b) {
    this.matrixAutoUpdate && (b |= this.updateMatrix());
    if (b || this.matrixWorldNeedsUpdate)
        a ? this.skinMatrix.multiplyMatrices(a, this.matrix) : this.skinMatrix.copy(this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        b = !0;
    var c, e = this.children.length;
    for (c = 0; c < e; c++)
        this.children[c].update(this.skinMatrix, b)
}
;
THREE.LOD = function() {
    THREE.Object3D.call(this);
    this.objects = []
}
;
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype);
THREE.LOD.prototype.addLevel = function(a, b) {
    void 0 === b && (b = 0);
    b = Math.abs(b);
    for (var c = 0; c < this.objects.length && !(b < this.objects[c].distance); c++)
        ;
    this.objects.splice(c, 0, {
        distance: b,
        object: a
    });
    this.add(a)
}
;
THREE.LOD.prototype.getObjectForDistance = function(a) {
    for (var b = 1, c = this.objects.length; b < c && !(a < this.objects[b].distance); b++)
        ;
    return this.objects[b - 1].object
}
;
THREE.LOD.prototype.update = function() {
    var a = new THREE.Vector3
      , b = new THREE.Vector3;
    return function(c) {
        if (1 < this.objects.length) {
            a.setFromMatrixPosition(c.matrixWorld);
            b.setFromMatrixPosition(this.matrixWorld);
            c = a.distanceTo(b);
            this.objects[0].object.visible = !0;
            for (var e = 1, d = this.objects.length; e < d; e++)
                if (c >= this.objects[e].distance)
                    this.objects[e - 1].object.visible = !1,
                    this.objects[e].object.visible = !0;
                else
                    break;
            for (; e < d; e++)
                this.objects[e].object.visible = !1
        }
    }
}
();
THREE.LOD.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.LOD);
    THREE.Object3D.prototype.clone.call(this, a);
    for (var b = 0, c = this.objects.length; b < c; b++) {
        var e = this.objects[b].object.clone();
        e.visible = 0 === b;
        a.addLevel(e, this.objects[b].distance)
    }
    return a
}
;
THREE.Sprite = function() {
    var a = new THREE.Geometry2(3);
    a.vertices.set([-.5, -.5, 0, .5, -.5, 0, .5, .5, 0]);
    return function(b) {
        THREE.Object3D.call(this);
        this.geometry = a;
        this.material = void 0 !== b ? b : new THREE.SpriteMaterial
    }
}
();
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype);
THREE.Sprite.prototype.updateMatrix = function() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = !0
}
;
THREE.Sprite.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.Sprite(this.material));
    THREE.Object3D.prototype.clone.call(this, a);
    return a
}
;
THREE.Particle = THREE.Sprite;
THREE.Scene = function(a) {
    THREE.Object3D.call(this, a);
    this.children = [];
    this.overrideMaterial = this.fog = null ;
    this.autoUpdate = !0;
    this.matrixAutoUpdate = !1;
    this.__lights = [];
    this.__objectsAdded = [];
    this.__objectsRemoved = []
}
;
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype);
THREE.Scene.prototype.__addObject = function(a) {
    if (a instanceof THREE.Light)
        -1 === this.__lights.indexOf(a) && this.__lights.push(a),
        a.target && void 0 === a.target.parent && this.add(a.target);
    else if (!(a instanceof THREE.Camera || a instanceof THREE.Bone)) {
        this.__objectsAdded.push(a);
        var b = this.__objectsRemoved.indexOf(a);
        -1 !== b && this.__objectsRemoved.splice(b, 1)
    }
    this.dispatchEvent({
        type: "objectAdded",
        object: a
    });
    a.dispatchEvent({
        type: "addedToScene",
        scene: this
    });
    if (a.children)
        for (b = 0; b < a.children.length; b++)
            this.__addObject(a.children[b])
}
;
THREE.Scene.prototype.__removeObject = function(a) {
    if (a instanceof THREE.Light) {
        var b = this.__lights.indexOf(a);
        -1 !== b && this.__lights.splice(b, 1);
        if (a.shadowCascadeArray)
            for (b = 0; b < a.shadowCascadeArray.length; b++)
                this.__removeObject(a.shadowCascadeArray[b])
    } else
        a instanceof THREE.Camera || (this.__objectsRemoved.push(a),
        b = this.__objectsAdded.indexOf(a),
        -1 !== b && this.__objectsAdded.splice(b, 1));
    this.dispatchEvent({
        type: "objectRemoved",
        object: a
    });
    a.dispatchEvent({
        type: "removedFromScene",
        scene: this
    });
    if (a.children)
        for (b = 
        0; b < a.children.length; b++)
            this.__removeObject(a.children[b])
}
;
THREE.Scene.prototype.clone = function(a) {
    void 0 === a && (a = new THREE.Scene);
    THREE.Object3D.prototype.clone.call(this, a);
    null  !== this.fog && (a.fog = this.fog.clone());
    null  !== this.overrideMaterial && (a.overrideMaterial = this.overrideMaterial.clone());
    a.autoUpdate = this.autoUpdate;
    a.matrixAutoUpdate = this.matrixAutoUpdate;
    return a
}
;
THREE.Fog = function(a, b, c) {
    this.name = "";
    this.color = new THREE.Color(a);
    this.near = void 0 !== b ? b : 1;
    this.far = void 0 !== c ? c : 1E3
}
;
THREE.Fog.prototype.clone = function() {
    return new THREE.Fog(this.color.getHex(),this.near,this.far)
}
;
THREE.FogExp2 = function(a, b) {
    this.name = "";
    this.color = new THREE.Color(a);
    this.density = void 0 !== b ? b : 2.5E-4
}
;
THREE.FogExp2.prototype.clone = function() {
    return new THREE.FogExp2(this.color.getHex(),this.density)
}
;
THREE.ShaderChunk = {
    fog_pars_fragment: "#ifdef USE_FOG\nuniform vec3 fogColor;\n#ifdef FOG_EXP2\nuniform float fogDensity;\n#else\nuniform float fogNear;\nuniform float fogFar;\n#endif\n#endif",
    fog_fragment: "#ifdef USE_FOG\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n#ifdef FOG_EXP2\nconst float LOG2 = 1.442695;\nfloat fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n#else\nfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n#endif\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n#endif",
    envmap_pars_fragment: "#ifdef USE_ENVMAP\nuniform float reflectivity;\n#ifdef SPHERICAL_ENV\nuniform sampler2D envMap;\n#else\nuniform samplerCube envMap;\n#endif\nuniform float flipEnvMap;\nuniform int combine;\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nuniform bool useRefract;\nuniform float refractionRatio;\n#else\nvarying vec3 vReflect;\n#endif\n#endif",
    envmap_fragment: "#ifdef USE_ENVMAP\nvec3 reflectVec;\n#ifdef DOUBLE_SIDED\nfloat flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#else\nfloat flipNormal = 1.0;\n#endif\n#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nreflectVec = refract( cameraToVertex, normal, refractionRatio );\n} else { \nreflectVec = reflect( cameraToVertex, normal );\n}\n#else\nreflectVec = normalize(vReflect);\n#endif\n#ifdef SPHERICAL_ENV\nfloat r = (1.0 / 3.14159265) * acos(reflectVec.z) / length(reflectVec.xy);\nvec2 uv = (reflectVec.xy * r + 1.0) * 0.5;\nvec4 cubeColor = texture2D(envMap, uv);\n#else\nvec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n#endif\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\nfloat facing = max(0.0, dot( viewPosition, normal ));\nfloat schlickRefl = reflectivity + ( 1.0 - reflectivity ) * pow( max(1.0 - facing, 0.0), 5.0 );\nif ( combine == 1 ) {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * schlickRefl );\n} else if ( combine == 2 ) {\ngl_FragColor.xyz += cubeColor.xyz * specularStrength * schlickRefl;\n} else {\ngl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * schlickRefl );\n}\n#endif",
    envmap_pars_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvarying vec3 vReflect;\nuniform float refractionRatio;\nuniform bool useRefract;\n#endif",
    worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n#ifdef USE_SKINNING\nvec4 worldPosition = modelMatrix * skinned;\n#endif\n#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );\n#endif\n#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n#endif\n#endif",
    envmap_vertex: "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )\nvec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;\nworldNormal = normalize( worldNormal );\nvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, worldNormal );\n}\n#endif",
    map_particle_pars_fragment: "#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
    map_particle_fragment: "#ifdef USE_MAP\ngl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n#endif",
    map_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\nuniform vec4 offsetRepeat;\n#endif",
    map_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\nuniform sampler2D map;\n#endif",
    map_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )\nvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
    map_fragment: "#ifdef USE_MAP\nvec4 texelColor = texture2D( map, vUv );\n#ifdef GAMMA_INPUT\ntexelColor.xyz *= texelColor.xyz;\n#endif\ngl_FragColor = gl_FragColor * texelColor;\n#endif",
    lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\n#endif",
    lightmap_pars_vertex: "#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif",
    lightmap_fragment: "#ifdef USE_LIGHTMAP\ngl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );\n#endif",
    lightmap_vertex: "#ifdef USE_LIGHTMAP\nvUv2 = uv2;\n#endif",
    bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\nuniform sampler2D bumpMap;\nuniform float bumpScale;\nvec2 dHdxy_fwd() {\nvec2 dSTdx = dFdx( vUv );\nvec2 dSTdy = dFdy( vUv );\nfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\nfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\nfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\nreturn vec2( dBx, dBy );\n}\nvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\nvec3 vSigmaX = dFdx( surf_pos );\nvec3 vSigmaY = dFdy( surf_pos );\nvec3 vN = surf_norm;\nvec3 R1 = cross( vSigmaY, vN );\nvec3 R2 = cross( vN, vSigmaX );\nfloat fDet = dot( vSigmaX, R1 );\nvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\nreturn normalize( abs( fDet ) * surf_norm - vGrad );\n}\n#endif",
    normalmap_pars_fragment: "#ifdef USE_NORMALMAP\nuniform sampler2D normalMap;\nuniform vec2 normalScale;\nvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\nvec3 q0 = dFdx( eye_pos.xyz );\nvec3 q1 = dFdy( eye_pos.xyz );\nvec2 st0 = dFdx( vUv.st );\nvec2 st1 = dFdy( vUv.st );\nvec3 S = normalize(  q0 * st1.t - q1 * st0.t );\nvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\nvec3 N = normalize( surf_norm );\nvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\nmapN.xy = normalScale * mapN.xy;\nmat3 tsn = mat3( S, T, N );\nreturn normalize( tsn * mapN );\n}\n#endif",
    specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\nuniform sampler2D specularMap;\n#endif",
    specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\nvec4 texelSpecular = texture2D( specularMap, vUv );\nspecularStrength = texelSpecular.r;\n#else\nspecularStrength = 1.0;\n#endif",
    lights_lambert_pars_vertex: "uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif",
    lights_lambert_vertex: "vLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\nvLightBack = vec3( 0.0 );\n#endif\ntransformedNormal = normalize( transformedNormal );\n#if MAX_DIR_LIGHTS > 0\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, dirVector );\nvec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\ndirectionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\ndirectionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += directionalLightColor[ i ] * directionalLightWeighting;\n#ifdef DOUBLE_SIDED\nvLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;\n#endif\n}\n#endif\n#if MAX_POINT_LIGHTS > 0\nfor( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\npointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\npointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;\n#ifdef DOUBLE_SIDED\nvLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;\n#endif\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nfor( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz - mvPosition.xyz;\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( transformedNormal, lVector );\nvec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );\n#ifdef DOUBLE_SIDED\nvec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );\n#endif\n#endif\n#ifdef WRAP_AROUND\nvec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );\nspotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );\n#ifdef DOUBLE_SIDED\nspotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );\n#endif\n#endif\nvLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;\n#ifdef DOUBLE_SIDED\nvLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;\n#endif\n}\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( transformedNormal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nfloat hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;\nvLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\n#ifdef DOUBLE_SIDED\nvLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );\n#endif\n}\n#endif\nvLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;\n#ifdef DOUBLE_SIDED\nvLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;\n#endif",
    lights_phong_pars_vertex: "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec3 vWorldPosition;\n#endif",
    lights_phong_vertex: "#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvWorldPosition = worldPosition.xyz;\n#endif",
    lights_phong_pars_fragment: "uniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\nvarying vec3 vWorldPosition;\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;",
    lights_phong_fragment: "vec3 normal = normalize( vNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#ifdef DOUBLE_SIDED\nnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n#endif\n#ifdef USE_NORMALMAP\nnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\nnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse  = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dotProduct, 0.0 );\n#endif\npointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( lVector, pointHalfVector ), 0.0), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization ;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse  = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 lVector = lPosition.xyz + vViewPosition.xyz;\nfloat lDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nlDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );\nlVector = normalize( lVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\nfloat dotProduct = dot( normal, lVector );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dotProduct, 0.0 );\n#endif\nspotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;\nvec3 spotHalfVector = normalize( lVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( lVector, spotHalfVector ), 0.0), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse  = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, dirVector );\n#ifdef WRAP_AROUND\nfloat dirDiffuseWeightFull = max( dotProduct, 0.0 );\nfloat dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dotProduct, 0.0 );\n#endif\ndirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = shininess * 0.125 + 0.25;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( max(1.0 - dot( dirVector, dirHalfVector ), 0.0), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif",
    color_pars_fragment: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
    color_fragment: "#ifdef USE_COLOR\ngl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n#endif",
    color_pars_vertex: "#ifdef USE_COLOR\nvarying vec3 vColor;\n#endif",
    color_vertex: "#ifdef USE_COLOR\n#ifdef GAMMA_INPUT\nvColor = color * color;\n#else\nvColor = color;\n#endif\n#endif",
    skinning_pars_vertex: "#ifdef USE_SKINNING\n#ifdef BONE_TEXTURE\nuniform sampler2D boneTexture;\nuniform int boneTextureWidth;\nuniform int boneTextureHeight;\nmat4 getBoneMatrix( const in float i ) {\nfloat j = i * 4.0;\nfloat x = mod( j, float( boneTextureWidth ) );\nfloat y = floor( j / float( boneTextureWidth ) );\nfloat dx = 1.0 / float( boneTextureWidth );\nfloat dy = 1.0 / float( boneTextureHeight );\ny = dy * ( y + 0.5 );\nvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\nvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\nvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\nvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\nmat4 bone = mat4( v1, v2, v3, v4 );\nreturn bone;\n}\n#else\nuniform mat4 boneGlobalMatrices[ MAX_BONES ];\nmat4 getBoneMatrix( const in float i ) {\nmat4 bone = boneGlobalMatrices[ int(i) ];\nreturn bone;\n}\n#endif\n#endif",
    skinbase_vertex: "#ifdef USE_SKINNING\nmat4 boneMatX = getBoneMatrix( skinIndex.x );\nmat4 boneMatY = getBoneMatrix( skinIndex.y );\nmat4 boneMatZ = getBoneMatrix( skinIndex.z );\nmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_vertex: "#ifdef USE_SKINNING\n#ifdef USE_MORPHTARGETS\nvec4 skinVertex = vec4( morphed, 1.0 );\n#else\nvec4 skinVertex = vec4( position, 1.0 );\n#endif\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned      += boneMatY * skinVertex * skinWeight.y;\nskinned      += boneMatZ * skinVertex * skinWeight.z;\nskinned      += boneMatW * skinVertex * skinWeight.w;\n#endif",
    morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n#ifndef USE_MORPHNORMALS\nuniform float morphTargetInfluences[ 8 ];\n#else\nuniform float morphTargetInfluences[ 4 ];\n#endif\n#endif",
    morphtarget_vertex: "#ifdef USE_MORPHTARGETS\nvec3 morphed = vec3( 0.0 );\nmorphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\nmorphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\nmorphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\nmorphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n#ifndef USE_MORPHNORMALS\nmorphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\nmorphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\nmorphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\nmorphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n#endif\nmorphed += position;\n#endif",
    default_vertex: "vec4 mvPosition;\n#ifdef USE_SKINNING\nmvPosition = modelViewMatrix * skinned;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( morphed, 1.0 );\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )\nmvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;",
    morphnormal_vertex: "#ifdef USE_MORPHNORMALS\nvec3 morphedNormal = vec3( 0.0 );\nmorphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\nmorphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\nmorphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\nmorphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\nmorphedNormal += normal;\n#endif",
    skinnormal_vertex: "#ifdef USE_SKINNING\nmat4 skinMatrix = skinWeight.x * boneMatX;\nskinMatrix \t+= skinWeight.y * boneMatY;\n#ifdef USE_MORPHNORMALS\nvec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );\n#else\nvec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );\n#endif\n#endif",
    defaultnormal_vertex: "vec3 objectNormal;\n#ifdef USE_SKINNING\nobjectNormal = skinnedNormal.xyz;\n#endif\n#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )\nobjectNormal = morphedNormal;\n#endif\n#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )\nobjectNormal = normal;\n#endif\n#ifdef FLIP_SIDED\nobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;",
    shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\nuniform sampler2D shadowMap[ MAX_SHADOWS ];\nuniform vec2 shadowMapSize[ MAX_SHADOWS ];\nuniform float shadowDarkness[ MAX_SHADOWS ];\nuniform float shadowBias[ MAX_SHADOWS ];\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nfloat unpackDepth( const in vec4 rgba_depth ) {\nconst vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\nfloat depth = dot( rgba_depth, bit_shift );\nreturn depth;\n}\n#endif",
    shadowmap_fragment: "#ifdef USE_SHADOWMAP\n#ifdef SHADOWMAP_DEBUG\nvec3 frustumColors[3];\nfrustumColors[0] = vec3( 1.0, 0.5, 0.0 );\nfrustumColors[1] = vec3( 0.0, 1.0, 0.8 );\nfrustumColors[2] = vec3( 0.0, 0.5, 1.0 );\n#endif\n#ifdef SHADOWMAP_CASCADE\nint inFrustumCount = 0;\n#endif\nfloat fDepth;\nvec3 shadowColor = vec3( 1.0 );\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;\nbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\nbool inFrustum = all( inFrustumVec );\n#ifdef SHADOWMAP_CASCADE\ninFrustumCount += int( inFrustum );\nbvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );\n#else\nbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n#endif\nbool frustumTest = all( frustumTestVec );\nif ( frustumTest ) {\nshadowCoord.z += shadowBias[ i ];\n#if defined( SHADOWMAP_TYPE_PCF )\nfloat shadow = 0.0;\nconst float shadowDelta = 1.0 / 9.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.25 * xPixelOffset;\nfloat dy0 = -1.25 * yPixelOffset;\nfloat dx1 = 1.25 * xPixelOffset;\nfloat dy1 = 1.25 * yPixelOffset;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nfDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nif ( fDepth < shadowCoord.z ) shadow += shadowDelta;\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\nfloat shadow = 0.0;\nfloat xPixelOffset = 1.0 / shadowMapSize[ i ].x;\nfloat yPixelOffset = 1.0 / shadowMapSize[ i ].y;\nfloat dx0 = -1.0 * xPixelOffset;\nfloat dy0 = -1.0 * yPixelOffset;\nfloat dx1 = 1.0 * xPixelOffset;\nfloat dy1 = 1.0 * yPixelOffset;\nmat3 shadowKernel;\nmat3 depthKernel;\ndepthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );\ndepthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );\ndepthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );\ndepthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );\ndepthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );\ndepthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );\ndepthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );\ndepthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );\ndepthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );\nvec3 shadowZ = vec3( shadowCoord.z );\nshadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));\nshadowKernel[0] *= vec3(0.25);\nshadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));\nshadowKernel[1] *= vec3(0.25);\nshadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));\nshadowKernel[2] *= vec3(0.25);\nvec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );\nshadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );\nshadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );\nvec4 shadowValues;\nshadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );\nshadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );\nshadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );\nshadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );\nshadow = dot( shadowValues, vec4( 1.0 ) );\nshadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );\n#else\nvec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );\nfloat fDepth = unpackDepth( rgbaDepth );\nif ( fDepth < shadowCoord.z )\nshadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );\n#endif\n}\n#ifdef SHADOWMAP_DEBUG\n#ifdef SHADOWMAP_CASCADE\nif ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];\n#else\nif ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];\n#endif\n#endif\n}\n#ifdef GAMMA_OUTPUT\nshadowColor *= shadowColor;\n#endif\ngl_FragColor.xyz = gl_FragColor.xyz * shadowColor;\n#endif",
    shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\nvarying vec4 vShadowCoord[ MAX_SHADOWS ];\nuniform mat4 shadowMatrix[ MAX_SHADOWS ];\n#endif",
    shadowmap_vertex: "#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif",
    alphatest_fragment: "#ifdef ALPHATEST\nif ( gl_FragColor.a < ALPHATEST ) discard;\n#endif",
    linear_to_gamma_fragment: "#ifdef GAMMA_OUTPUT\ngl_FragColor.xyz = sqrt( gl_FragColor.xyz );\n#endif",
    mrt_normals_pars_vertex: "#ifdef MRT_NORMALS\nvarying float depth;\n#endif",
    mrt_normals_vertex: "#ifdef MRT_NORMALS\ndepth = mvPosition.z;\n#endif",
    mrt_normals_pars_fragment: ["#ifdef MRT_NORMALS", "undefined" !== typeof _isIE11 && _isIE11 ? "" : "#extension GL_EXT_draw_buffers : require", "varying float depth;\n#define gl_FragColor gl_FragData[0]\n#endif"].join("\n"),
    mrt_normals_fragment: "#ifdef MRT_NORMALS\ngl_FragData[1] = vec4(normal.x, normal.y, depth, gl_FragColor.a < 1.0 ? 0.0 : 1.0);\n#endif"
};
THREE.UniformsUtils = {
    merge: function(a) {
        var b, c, e, d = {};
        for (b = 0; b < a.length; b++)
            for (c in e = this.clone(a[b]),
            e)
                d[c] = e[c];
        return d
    },
    clone: function(a) {
        var b, c, e, d = {};
        for (b in a)
            for (c in d[b] = {},
            a[b])
                e = a[b][c],
                d[b][c] = e instanceof THREE.Color || e instanceof THREE.Vector2 || e instanceof THREE.Vector3 || e instanceof THREE.Vector4 || e instanceof THREE.Matrix4 || e instanceof THREE.Texture ? e.clone() : e instanceof Array ? e.slice() : e;
        return d
    }
};
THREE.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null 
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0,0,1,1)
        },
        lightMap: {
            type: "t",
            value: null 
        },
        specularMap: {
            type: "t",
            value: null 
        },
        envMap: {
            type: "t",
            value: null 
        },
        flipEnvMap: {
            type: "f",
            value: -1
        },
        useRefract: {
            type: "i",
            value: 0
        },
        reflectivity: {
            type: "f",
            value: 1
        },
        refractionRatio: {
            type: "f",
            value: .98
        },
        combine: {
            type: "i",
            value: 0
        },
        morphTargetInfluences: {
            type: "f",
            value: 0
        }
    },
    bump: {
        bumpMap: {
            type: "t",
            value: null 
        },
        bumpScale: {
            type: "f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null 
        },
        normalScale: {
            type: "v2",
            value: new THREE.Vector2(1,1)
        }
    },
    fog: {
        fogDensity: {
            type: "f",
            value: 2.5E-4
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2E3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "fv",
            value: []
        },
        directionalLightDirection: {
            type: "fv",
            value: []
        },
        directionalLightColor: {
            type: "fv",
            value: []
        },
        hemisphereLightDirection: {
            type: "fv",
            value: []
        },
        hemisphereLightSkyColor: {
            type: "fv",
            value: []
        },
        hemisphereLightGroundColor: {
            type: "fv",
            value: []
        },
        pointLightColor: {
            type: "fv",
            value: []
        },
        pointLightPosition: {
            type: "fv",
            value: []
        },
        pointLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightColor: {
            type: "fv",
            value: []
        },
        spotLightPosition: {
            type: "fv",
            value: []
        },
        spotLightDirection: {
            type: "fv",
            value: []
        },
        spotLightDistance: {
            type: "fv1",
            value: []
        },
        spotLightAngleCos: {
            type: "fv1",
            value: []
        },
        spotLightExponent: {
            type: "fv1",
            value: []
        }
    },
    particle: {
        psColor: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        size: {
            type: "f",
            value: 1
        },
        scale: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null 
        },
        fogDensity: {
            type: "f",
            value: 2.5E-4
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2E3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    shadowmap: {
        shadowMap: {
            type: "tv",
            value: []
        },
        shadowMapSize: {
            type: "v2v",
            value: []
        },
        shadowBias: {
            type: "fv1",
            value: []
        },
        shadowDarkness: {
            type: "fv1",
            value: []
        },
        shadowMatrix: {
            type: "m4v",
            value: []
        }
    }
};
THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.shadowmap]),
        vertexShader: [THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, 
        THREE.ShaderChunk.skinbase_vertex, "#ifdef USE_ENVMAP", THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "#endif", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, 
        THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( diffuse, opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lightmap_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, 
        THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1,1,1)
            }
        }]),
        vertexShader: ["#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", 
        THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_lambert_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, 
        THREE.ShaderChunk.defaultnormal_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_lambert_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
        fragmentShader: ["uniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\nvarying vec3 vLightBack;\n#endif", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, 
        THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, "#ifdef DOUBLE_SIDED\nif ( gl_FrontFacing )\ngl_FragColor.xyz *= vLightFront;\nelse\ngl_FragColor.xyz *= vLightBack;\n#else\ngl_FragColor.xyz *= vLightFront;\n#endif", THREE.ShaderChunk.lightmap_fragment, 
        THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.bump, THREE.UniformsLib.normalmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, THREE.UniformsLib.shadowmap, {
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "f",
                value: 30
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1,1,1)
            }
        }]),
        vertexShader: ["#define PHONG\nvarying vec3 vViewPosition;\nvarying vec3 vNormal;", THREE.ShaderChunk.map_pars_vertex, THREE.ShaderChunk.lightmap_pars_vertex, THREE.ShaderChunk.envmap_pars_vertex, THREE.ShaderChunk.lights_phong_pars_vertex, THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, 
        THREE.ShaderChunk.mrt_normals_pars_vertex, "void main() {", THREE.ShaderChunk.map_vertex, THREE.ShaderChunk.lightmap_vertex, THREE.ShaderChunk.color_vertex, THREE.ShaderChunk.morphnormal_vertex, THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, THREE.ShaderChunk.defaultnormal_vertex, "vNormal = normalize( transformedNormal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "vViewPosition = -mvPosition.xyz;", THREE.ShaderChunk.worldpos_vertex, 
        THREE.ShaderChunk.envmap_vertex, THREE.ShaderChunk.lights_phong_vertex, THREE.ShaderChunk.shadowmap_vertex, THREE.ShaderChunk.mrt_normals_vertex, "}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform vec3 ambient;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_pars_fragment, THREE.ShaderChunk.lightmap_pars_fragment, THREE.ShaderChunk.envmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, 
        THREE.ShaderChunk.lights_phong_pars_fragment, THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.bumpmap_pars_fragment, THREE.ShaderChunk.normalmap_pars_fragment, THREE.ShaderChunk.specularmap_pars_fragment, THREE.ShaderChunk.mrt_normals_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3 ( 1.0 ), opacity );", THREE.ShaderChunk.map_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.specularmap_fragment, THREE.ShaderChunk.lights_phong_fragment, THREE.ShaderChunk.lightmap_fragment, 
        THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.envmap_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, THREE.ShaderChunk.mrt_normals_fragment, "}"].join("\n")
    },
    particle_basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.particle, THREE.UniformsLib.shadowmap]),
        vertexShader: ["uniform float size;\nuniform float scale;", THREE.ShaderChunk.color_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, 
        "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#ifdef USE_SIZEATTENUATION\ngl_PointSize = size * ( scale / length( mvPosition.xyz ) );\n#else\ngl_PointSize = size;\n#endif\ngl_Position = projectionMatrix * mvPosition;", THREE.ShaderChunk.worldpos_vertex, THREE.ShaderChunk.shadowmap_vertex, "}"].join("\n"),
        fragmentShader: ["uniform vec3 psColor;\nuniform float opacity;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.map_particle_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, 
        THREE.ShaderChunk.shadowmap_pars_fragment, "void main() {\ngl_FragColor = vec4( psColor, opacity );", THREE.ShaderChunk.map_particle_fragment, THREE.ShaderChunk.alphatest_fragment, THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
            scale: {
                type: "f",
                value: 1
            },
            dashSize: {
                type: "f",
                value: 1
            },
            totalSize: {
                type: "f",
                value: 2
            }
        }]),
        vertexShader: ["uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;", 
        THREE.ShaderChunk.color_pars_vertex, "void main() {", THREE.ShaderChunk.color_vertex, "vLineDistance = scale * lineDistance;\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\n}"].join("\n"),
        fragmentShader: ["uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;", THREE.ShaderChunk.color_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\nif ( mod( vLineDistance, totalSize ) > dashSize ) {\ndiscard;\n}\ngl_FragColor = vec4( diffuse, opacity );", 
        THREE.ShaderChunk.color_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n")
    },
    depth: {
        uniforms: {
            mNear: {
                type: "f",
                value: 1
            },
            mFar: {
                type: "f",
                value: 2E3
            },
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: "void main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform float mNear;\nuniform float mFar;\nuniform float opacity;\nvoid main() {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat color = 1.0 - smoothstep( mNear, mFar, depth );\ngl_FragColor = vec4( vec3( color ), opacity );\n}"
    },
    normal: {
        uniforms: {
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: ["varying vec3 vNormal;", THREE.ShaderChunk.morphtarget_pars_vertex, "void main() {\nvNormal = normalize( normalMatrix * normal );", THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
        fragmentShader: "uniform float opacity;\nvarying vec3 vNormal;\nvoid main() {\ngl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n}"
    },
    normalmap: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.fog, THREE.UniformsLib.lights, 
        THREE.UniformsLib.shadowmap, {
            enableAO: {
                type: "i",
                value: 0
            },
            enableDiffuse: {
                type: "i",
                value: 0
            },
            enableSpecular: {
                type: "i",
                value: 0
            },
            enableReflection: {
                type: "i",
                value: 0
            },
            enableDisplacement: {
                type: "i",
                value: 0
            },
            tDisplacement: {
                type: "t",
                value: null 
            },
            tDiffuse: {
                type: "t",
                value: null 
            },
            tCube: {
                type: "t",
                value: null 
            },
            tNormal: {
                type: "t",
                value: null 
            },
            tSpecular: {
                type: "t",
                value: null 
            },
            tAO: {
                type: "t",
                value: null 
            },
            uNormalScale: {
                type: "v2",
                value: new THREE.Vector2(1,1)
            },
            uDisplacementBias: {
                type: "f",
                value: 0
            },
            uDisplacementScale: {
                type: "f",
                value: 1
            },
            diffuse: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            ambient: {
                type: "c",
                value: new THREE.Color(16777215)
            },
            shininess: {
                type: "f",
                value: 30
            },
            opacity: {
                type: "f",
                value: 1
            },
            useRefract: {
                type: "i",
                value: 0
            },
            refractionRatio: {
                type: "f",
                value: .98
            },
            reflectivity: {
                type: "f",
                value: .5
            },
            uOffset: {
                type: "v2",
                value: new THREE.Vector2(0,0)
            },
            uRepeat: {
                type: "v2",
                value: new THREE.Vector2(1,1)
            },
            wrapRGB: {
                type: "v3",
                value: new THREE.Vector3(1,1,1)
            }
        }]),
        fragmentShader: ["uniform vec3 ambient;\nuniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse;\nuniform bool enableSpecular;\nuniform bool enableAO;\nuniform bool enableReflection;\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tAO;\nuniform samplerCube tCube;\nuniform vec2 uNormalScale;\nuniform bool useRefract;\nuniform float refractionRatio;\nuniform float reflectivity;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nuniform vec3 ambientLightColor;\n#if MAX_DIR_LIGHTS > 0\nuniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];\nuniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];\n#endif\n#if MAX_HEMI_LIGHTS > 0\nuniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];\nuniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];\n#endif\n#if MAX_POINT_LIGHTS > 0\nuniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];\nuniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];\nuniform float pointLightDistance[ MAX_POINT_LIGHTS ];\n#endif\n#if MAX_SPOT_LIGHTS > 0\nuniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];\nuniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];\nuniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];\nuniform float spotLightExponent[ MAX_SPOT_LIGHTS ];\nuniform float spotLightDistance[ MAX_SPOT_LIGHTS ];\n#endif\n#ifdef WRAP_AROUND\nuniform vec3 wrapRGB;\n#endif\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", 
        THREE.ShaderChunk.shadowmap_pars_fragment, THREE.ShaderChunk.fog_pars_fragment, "void main() {\ngl_FragColor = vec4( vec3( 1.0 ), opacity );\nvec3 specularTex = vec3( 1.0 );\nvec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse ) {\n#ifdef GAMMA_INPUT\nvec4 texelColor = texture2D( tDiffuse, vUv );\ntexelColor.xyz *= texelColor.xyz;\ngl_FragColor = gl_FragColor * texelColor;\n#else\ngl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );\n#endif\n}\nif( enableAO ) {\n#ifdef GAMMA_INPUT\nvec4 aoColor = texture2D( tAO, vUv );\naoColor.xyz *= aoColor.xyz;\ngl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;\n#endif\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, vUv ).xyz;\nmat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );\nvec3 finalNormal = tsb * normalTex;\n#ifdef FLIP_SIDED\nfinalNormal = -finalNormal;\n#endif\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\n#if MAX_POINT_LIGHTS > 0\nvec3 pointDiffuse = vec3( 0.0 );\nvec3 pointSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );\nvec3 pointVector = lPosition.xyz + vViewPosition.xyz;\nfloat pointDistance = 1.0;\nif ( pointLightDistance[ i ] > 0.0 )\npointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );\npointVector = normalize( pointVector );\n#ifdef WRAP_AROUND\nfloat pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );\nfloat pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );\nvec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );\n#else\nfloat pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );\n#endif\npointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;\nvec3 pointHalfVector = normalize( pointVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );\npointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;\n}\n#endif\n#if MAX_SPOT_LIGHTS > 0\nvec3 spotDiffuse = vec3( 0.0 );\nvec3 spotSpecular = vec3( 0.0 );\nfor ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {\nvec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );\nvec3 spotVector = lPosition.xyz + vViewPosition.xyz;\nfloat spotDistance = 1.0;\nif ( spotLightDistance[ i ] > 0.0 )\nspotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );\nspotVector = normalize( spotVector );\nfloat spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );\nif ( spotEffect > spotLightAngleCos[ i ] ) {\nspotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );\n#ifdef WRAP_AROUND\nfloat spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );\nfloat spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );\nvec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );\n#else\nfloat spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );\n#endif\nspotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;\nvec3 spotHalfVector = normalize( spotVector + viewPosition );\nfloat spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );\nfloat spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );\nspotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;\n}\n}\n#endif\n#if MAX_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {\nvec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );\nvec3 dirVector = normalize( lDirection.xyz );\n#ifdef WRAP_AROUND\nfloat directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );\nfloat directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );\nvec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );\n#else\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\n#endif\ndirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );\ndirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;\n}\n#endif\n#if MAX_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {\nvec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );\nvec3 lVector = normalize( lDirection.xyz );\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\nvec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );\nhemiDiffuse += diffuse * hemiColor;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nfloat hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nfloat hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\nfloat dotProductGround = dot( normal, lVectorGround );\nfloat specularNormalization = ( shininess + 2.0001 ) / 8.0;\nvec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );\nvec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );\nhemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );\n}\n#endif\nvec3 totalDiffuse = vec3( 0.0 );\nvec3 totalSpecular = vec3( 0.0 );\n#if MAX_DIR_LIGHTS > 0\ntotalDiffuse += dirDiffuse;\ntotalSpecular += dirSpecular;\n#endif\n#if MAX_HEMI_LIGHTS > 0\ntotalDiffuse += hemiDiffuse;\ntotalSpecular += hemiSpecular;\n#endif\n#if MAX_POINT_LIGHTS > 0\ntotalDiffuse += pointDiffuse;\ntotalSpecular += pointSpecular;\n#endif\n#if MAX_SPOT_LIGHTS > 0\ntotalDiffuse += spotDiffuse;\ntotalSpecular += spotSpecular;\n#endif\n#ifdef METAL\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );\n#else\ngl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;\n#endif\nif ( enableReflection ) {\nvec3 vReflect;\nvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\nif ( useRefract ) {\nvReflect = refract( cameraToVertex, normal, refractionRatio );\n} else {\nvReflect = reflect( cameraToVertex, normal );\n}\nvec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );\n#ifdef GAMMA_INPUT\ncubeColor.xyz *= cubeColor.xyz;\n#endif\ngl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );\n}", 
        THREE.ShaderChunk.shadowmap_fragment, THREE.ShaderChunk.linear_to_gamma_fragment, THREE.ShaderChunk.fog_fragment, "}"].join("\n"),
        vertexShader: ["attribute vec4 tangent;\nuniform vec2 uOffset;\nuniform vec2 uRepeat;\nuniform bool enableDisplacement;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nvarying vec3 vViewPosition;", 
        THREE.ShaderChunk.skinning_pars_vertex, THREE.ShaderChunk.shadowmap_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.skinnormal_vertex, "#ifdef USE_SKINNING\nvNormal = normalize( normalMatrix * skinnedNormal.xyz );\nvec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );\nvTangent = normalize( normalMatrix * skinnedTangent.xyz );\n#else\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\n#endif\nvBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );\nvUv = uv * uRepeat + uOffset;\nvec3 displacedPosition;\n#ifdef VERTEX_TEXTURES\nif ( enableDisplacement ) {\nvec3 dv = texture2D( tDisplacement, uv ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\ndisplacedPosition = position + normalize( normal ) * df;\n} else {\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n}\n#else\n#ifdef USE_SKINNING\nvec4 skinVertex = vec4( position, 1.0 );\nvec4 skinned  = boneMatX * skinVertex * skinWeight.x;\nskinned \t  += boneMatY * skinVertex * skinWeight.y;\ndisplacedPosition  = skinned.xyz;\n#else\ndisplacedPosition = position;\n#endif\n#endif\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\ngl_Position = projectionMatrix * mvPosition;\nvWorldPosition = worldPosition.xyz;\nvViewPosition = -mvPosition.xyz;\n#ifdef USE_SHADOWMAP\nfor( int i = 0; i < MAX_SHADOWS; i ++ ) {\nvShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;\n}\n#endif\n}"].join("\n")
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null 
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: "varying vec3 vWorldPosition;\nvoid main() {\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvWorldPosition = worldPosition.xyz;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
        fragmentShader: "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\nvoid main() {\ngl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n}"
    },
    depthRGBA: {
        uniforms: {},
        vertexShader: [THREE.ShaderChunk.morphtarget_pars_vertex, THREE.ShaderChunk.skinning_pars_vertex, "void main() {", THREE.ShaderChunk.skinbase_vertex, THREE.ShaderChunk.morphtarget_vertex, THREE.ShaderChunk.skinning_vertex, THREE.ShaderChunk.default_vertex, "}"].join("\n"),
        fragmentShader: "vec4 pack_depth( const in float depth ) {\nconst vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\nvec4 res = fract( depth * bit_shift );\nres -= res.xxyz * bit_mask;\nreturn res;\n}\nvoid main() {\ngl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n}"
    }
};
THREE.WebGLRenderTarget = function(a, b, c) {
    this.width = a;
    this.height = b;
    c = c || {};
    this.wrapS = void 0 !== c.wrapS ? c.wrapS : THREE.ClampToEdgeWrapping;
    this.wrapT = void 0 !== c.wrapT ? c.wrapT : THREE.ClampToEdgeWrapping;
    this.magFilter = void 0 !== c.magFilter ? c.magFilter : THREE.LinearFilter;
    this.minFilter = void 0 !== c.minFilter ? c.minFilter : THREE.LinearMipMapLinearFilter;
    this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
    this.offset = new THREE.Vector2(0,0);
    this.repeat = new THREE.Vector2(1,1);
    this.format = void 0 !== c.format ? c.format : 
    THREE.RGBAFormat;
    this.type = void 0 !== c.type ? c.type : THREE.UnsignedByteType;
    this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
    this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
    this.generateMipmaps = !0;
    this.shareDepthFrom = null 
}
;
THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    clone: function() {
        var a = new THREE.WebGLRenderTarget(this.width,this.height);
        a.wrapS = this.wrapS;
        a.wrapT = this.wrapT;
        a.magFilter = this.magFilter;
        a.minFilter = this.minFilter;
        a.anisotropy = this.anisotropy;
        a.offset.copy(this.offset);
        a.repeat.copy(this.repeat);
        a.format = this.format;
        a.type = this.type;
        a.depthBuffer = this.depthBuffer;
        a.stencilBuffer = this.stencilBuffer;
        a.generateMipmaps = this.generateMipmaps;
        a.shareDepthFrom = this.shareDepthFrom;
        return a
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
};
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype);
THREE.GeometryUtils = {
    merge: function(a, b, c) {
        var e, d, g = a.vertices.length, f = b instanceof THREE.Mesh ? b.geometry : b, k = a.vertices, h = f.vertices, l = a.faces, m = f.faces;
        a = a.faceVertexUvs[0];
        f = f.faceVertexUvs[0];
        void 0 === c && (c = 0);
        b instanceof THREE.Mesh && (b.matrixAutoUpdate && b.updateMatrix(),
        e = b.matrix,
        d = (new THREE.Matrix3).getNormalMatrix(e));
        b = 0;
        for (var n = h.length; b < n; b++) {
            var p = h[b].clone();
            e && p.applyMatrix4(e);
            k.push(p)
        }
        b = 0;
        for (n = m.length; b < n; b++) {
            var p = m[b], t, v, r = p.vertexNormals, u = p.vertexColors;
            t = new THREE.Face3(p.a + 
            g,p.b + g,p.c + g);
            t.normal.copy(p.normal);
            d && t.normal.applyMatrix3(d).normalize();
            k = 0;
            for (h = r.length; k < h; k++)
                v = r[k].clone(),
                d && v.applyMatrix3(d).normalize(),
                t.vertexNormals.push(v);
            t.color.copy(p.color);
            k = 0;
            for (h = u.length; k < h; k++)
                v = u[k],
                t.vertexColors.push(v.clone());
            t.materialIndex = p.materialIndex + c;
            t.centroid.copy(p.centroid);
            e && t.centroid.applyMatrix4(e);
            l.push(t)
        }
        b = 0;
        for (n = f.length; b < n; b++) {
            c = f[b];
            e = [];
            k = 0;
            for (h = c.length; k < h; k++)
                e.push(new THREE.Vector2(c[k].x,c[k].y));
            a.push(e)
        }
    },
    randomPointInTriangle: function() {
        var a = 
        new THREE.Vector3;
        return function(b, c, e) {
            var d = new THREE.Vector3
              , g = THREE.Math.random16()
              , f = THREE.Math.random16();
            1 < g + f && (g = 1 - g,
            f = 1 - f);
            var k = 1 - g - f;
            d.copy(b);
            d.multiplyScalar(g);
            a.copy(c);
            a.multiplyScalar(f);
            d.add(a);
            a.copy(e);
            a.multiplyScalar(k);
            d.add(a);
            return d
        }
    }
    (),
    randomPointInFace: function(a, b, c) {
        return THREE.GeometryUtils.randomPointInTriangle(b.vertices[a.a], b.vertices[a.b], b.vertices[a.c])
    },
    randomPointsInGeometry: function(a, b) {
        function c(a) {
            function f(b, d) {
                if (d < b)
                    return b;
                var c = b + Math.floor((d - 
                b) / 2);
                return l[c] > a ? f(b, c - 1) : l[c] < a ? f(c + 1, d) : c
            }
            return f(0, l.length - 1)
        }
        var e, d, g = a.faces, f = a.vertices, k = g.length, h = 0, l = [], m, n, p;
        for (d = 0; d < k; d++)
            e = g[d],
            m = f[e.a],
            n = f[e.b],
            p = f[e.c],
            e._area = THREE.GeometryUtils.triangleArea(m, n, p),
            h += e._area,
            l[d] = h;
        e = [];
        for (d = 0; d < b; d++)
            f = THREE.Math.random16() * h,
            f = c(f),
            e[d] = THREE.GeometryUtils.randomPointInFace(g[f], a, !0);
        return e
    },
    triangleArea: function() {
        var a = new THREE.Vector3
          , b = new THREE.Vector3;
        return function(c, e, d) {
            a.subVectors(e, c);
            b.subVectors(d, c);
            a.cross(b);
            return .5 * 
            a.length()
        }
    }
    (),
    center: function(a) {
        a.computeBoundingBox();
        var b = a.boundingBox
          , c = new THREE.Vector3;
        c.addVectors(b.min, b.max);
        c.multiplyScalar(-.5);
        a.applyMatrix((new THREE.Matrix4).makeTranslation(c.x, c.y, c.z));
        a.computeBoundingBox();
        return c
    },
    triangulateQuads: function(a) {
        var b, c, e, d, g = [], f = [];
        b = 0;
        for (c = a.faceVertexUvs.length; b < c; b++)
            f[b] = [];
        b = 0;
        for (c = a.faces.length; b < c; b++)
            for (g.push(a.faces[b]),
            e = 0,
            d = a.faceVertexUvs.length; e < d; e++)
                f[e].push(a.faceVertexUvs[e][b]);
        a.faces = g;
        a.faceVertexUvs = f;
        a.computeCentroids();
        a.computeFaceNormals();
        a.computeVertexNormals();
        a.hasTangents && a.computeTangents()
    }
};
THREE.ImageUtils = {
    crossOrigin: "",
    loadTexture: function(a, b, c, e) {
        e = new THREE.ImageLoader;
        e.crossOrigin = this.crossOrigin;
        var d = new THREE.Texture(void 0,b);
        b = e.load(a, function() {
            d.needsUpdate = !0;
            c && c(d)
        }
        );
        d.image = b;
        d.sourceFile = a;
        return d
    },
    loadCompressedTexture: function(a, b, c, e) {
        var d = new THREE.CompressedTexture;
        d.mapping = b;
        var g = new XMLHttpRequest;
        g.onload = function() {
            var a = THREE.ImageUtils.parseDDS(g.response, !0);
            d.format = a.format;
            d.mipmaps = a.mipmaps;
            d.image.width = a.width;
            d.image.height = a.height;
            d.generateMipmaps = 
            !1;
            d.needsUpdate = !0;
            c && c(d)
        }
        ;
        g.onerror = e;
        g.open("GET", a, !0);
        g.responseType = "arraybuffer";
        g.send(null );
        return d
    },
    loadTextureCube: function(a, b, c, e) {
        var d = [];
        d.loadCount = 0;
        var g = new THREE.Texture;
        g.image = d;
        void 0 !== b && (g.mapping = b);
        g.flipY = !1;
        b = 0;
        for (var f = a.length; b < f; ++b) {
            var k = new Image;
            d[b] = k;
            k.onload = function() {
                d.loadCount += 1;
                6 === d.loadCount && (g.needsUpdate = !0,
                c && c(g))
            }
            ;
            k.onerror = e;
            k.crossOrigin = this.crossOrigin;
            k.src = a[b]
        }
        return g
    },
    loadCompressedTextureCube: function(a, b, c, e) {
        var d = [];
        d.loadCount = 
        0;
        var g = new THREE.CompressedTexture;
        g.image = d;
        void 0 !== b && (g.mapping = b);
        g.flipY = !1;
        g.generateMipmaps = !1;
        b = function(a, f) {
            return function() {
                var b = THREE.ImageUtils.parseDDS(a.response, !0);
                f.format = b.format;
                f.mipmaps = b.mipmaps;
                f.width = b.width;
                f.height = b.height;
                d.loadCount += 1;
                6 === d.loadCount && (g.format = b.format,
                g.needsUpdate = !0,
                c && c(g))
            }
        }
        ;
        if (a instanceof Array)
            for (var f = 0, k = a.length; f < k; ++f) {
                var h = {};
                d[f] = h;
                var l = new XMLHttpRequest;
                l.onload = b(l, h);
                l.onerror = e;
                h = a[f];
                l.open("GET", h, !0);
                l.responseType = "arraybuffer";
                l.send(null )
            }
        else
            l = new XMLHttpRequest,
            l.onload = function() {
                var a = THREE.ImageUtils.parseDDS(l.response, !0);
                if (a.isCubemap) {
                    for (var f = a.mipmaps.length / a.mipmapCount, b = 0; b < f; b++) {
                        d[b] = {
                            mipmaps: []
                        };
                        for (var k = 0; k < a.mipmapCount; k++)
                            d[b].mipmaps.push(a.mipmaps[b * a.mipmapCount + k]),
                            d[b].format = a.format,
                            d[b].width = a.width,
                            d[b].height = a.height
                    }
                    g.format = a.format;
                    g.needsUpdate = !0;
                    c && c(g)
                }
            }
            ,
            l.onerror = e,
            l.open("GET", a, !0),
            l.responseType = "arraybuffer",
            l.send(null );
        return g
    },
    loadDDSTexture: function(a, b, c, e) {
        var d = 
        [];
        d.loadCount = 0;
        var g = new THREE.CompressedTexture;
        g.image = d;
        void 0 !== b && (g.mapping = b);
        g.flipY = !1;
        g.generateMipmaps = !1;
        var f = new XMLHttpRequest;
        f.onload = function() {
            var a = THREE.ImageUtils.parseDDS(f.response, !0);
            if (a.isCubemap)
                for (var b = a.mipmaps.length / a.mipmapCount, e = 0; e < b; e++) {
                    d[e] = {
                        mipmaps: []
                    };
                    for (var m = 0; m < a.mipmapCount; m++)
                        d[e].mipmaps.push(a.mipmaps[e * a.mipmapCount + m]),
                        d[e].format = a.format,
                        d[e].width = a.width,
                        d[e].height = a.height
                }
            else
                g.image.width = a.width,
                g.image.height = a.height,
                g.mipmaps = a.mipmaps;
            g.format = a.format;
            g.needsUpdate = !0;
            c && c(g)
        }
        ;
        f.onerror = e;
        f.open("GET", a, !0);
        f.responseType = "arraybuffer";
        f.send(null );
        return g
    },
    parseDDS: function(a, b) {
        function c(a) {
            return a.charCodeAt(0) + (a.charCodeAt(1) << 8) + (a.charCodeAt(2) << 16) + (a.charCodeAt(3) << 24)
        }
        function e(a, f, b, d) {
            var c = b * d * 4;
            a = new Uint8Array(a,f,c);
            for (var c = new Uint8Array(c), k = f = 0, e = 0; e < d; e++)
                for (var h = 0; h < b; h++) {
                    var g = a[k];
                    k++;
                    var l = a[k];
                    k++;
                    var m = a[k];
                    k++;
                    var n = a[k];
                    k++;
                    c[f] = m;
                    f++;
                    c[f] = l;
                    f++;
                    c[f] = g;
                    f++;
                    c[f] = n;
                    f++
                }
            return c
        }
        var d = {
            mipmaps: [],
            width: 0,
            height: 0,
            format: null ,
            mipmapCount: 1
        }
          , g = c("DXT1")
          , f = c("DXT3")
          , k = c("DXT5")
          , h = new Int32Array(a,0,31);
        if (542327876 !== h[0])
            return console.error("ImageUtils.parseDDS(): Invalid magic number in DDS header"),
            d;
        if (!h[20] & 4)
            return console.error("ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code"),
            d;
        var l = h[21]
          , m = !1;
        switch (l) {
        case g:
            g = 8;
            d.format = THREE.RGB_S3TC_DXT1_Format;
            break;
        case f:
            g = 16;
            d.format = THREE.RGBA_S3TC_DXT3_Format;
            break;
        case k:
            g = 16;
            d.format = THREE.RGBA_S3TC_DXT5_Format;
            break;
        default:
            if (32 == h[22] && h[23] & 16711680 && h[24] & 65280 && h[25] & 255 && h[26] & 4278190080)
                m = !0,
                g = 64,
                d.format = THREE.RGBAFormat;
            else
                return console.error("ImageUtils.parseDDS(): Unsupported FourCC code: ", String.fromCharCode(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255)),
                d
        }
        d.mipmapCount = 1;
        h[2] & 131072 && !1 !== b && (d.mipmapCount = Math.max(1, h[7]));
        d.isCubemap = h[28] & 512 ? !0 : !1;
        d.width = h[4];
        d.height = h[3];
        for (var h = h[1] + 4, f = d.width, k = d.height, l = d.isCubemap ? 6 : 1, n = 0; n < l; n++) {
            for (var p = 0; p < d.mipmapCount; p++) {
                if (m)
                    var t = e(a, h, 
                    f, k)
                      , v = t.length;
                else
                    v = Math.max(4, f) / 4 * Math.max(4, k) / 4 * g,
                    t = new Uint8Array(a,h,v);
                d.mipmaps.push({
                    data: t,
                    width: f,
                    height: k
                });
                h += v;
                f = Math.max(.5 * f, 1);
                k = Math.max(.5 * k, 1)
            }
            f = d.width;
            k = d.height
        }
        return d
    },
    getNormalMap: function(a, b) {
        var c = function(a) {
            var f = Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);
            return [a[0] / f, a[1] / f, a[2] / f]
        }
        ;
        b |= 1;
        var e = a.width
          , d = a.height
          , g = document.createElement("canvas");
        g.width = e;
        g.height = d;
        var f = g.getContext("2d");
        f.drawImage(a, 0, 0);
        for (var k = f.getImageData(0, 0, e, d).data, h = f.createImageData(e, 
        d), l = h.data, m = 0; m < e; m++)
            for (var n = 0; n < d; n++) {
                var p = 0 > n - 1 ? 0 : n - 1
                  , t = n + 1 > d - 1 ? d - 1 : n + 1
                  , v = 0 > m - 1 ? 0 : m - 1
                  , r = m + 1 > e - 1 ? e - 1 : m + 1
                  , u = []
                  , w = [0, 0, k[4 * (n * e + m)] / 255 * b];
                u.push([-1, 0, k[4 * (n * e + v)] / 255 * b]);
                u.push([-1, -1, k[4 * (p * e + v)] / 255 * b]);
                u.push([0, -1, k[4 * (p * e + m)] / 255 * b]);
                u.push([1, -1, k[4 * (p * e + r)] / 255 * b]);
                u.push([1, 0, k[4 * (n * e + r)] / 255 * b]);
                u.push([1, 1, k[4 * (t * e + r)] / 255 * b]);
                u.push([0, 1, k[4 * (t * e + m)] / 255 * b]);
                u.push([-1, 1, k[4 * (t * e + v)] / 255 * b]);
                p = [];
                v = u.length;
                for (t = 0; t < v; t++) {
                    var r = u[t]
                      , x = u[(t + 1) % v]
                      , r = [r[0] - w[0], r[1] - w[1], r[2] - w[2]]
                      , 
                    x = [x[0] - w[0], x[1] - w[1], x[2] - w[2]];
                    p.push(c([r[1] * x[2] - r[2] * x[1], r[2] * x[0] - r[0] * x[2], r[0] * x[1] - r[1] * x[0]]))
                }
                u = [0, 0, 0];
                for (t = 0; t < p.length; t++)
                    u[0] += p[t][0],
                    u[1] += p[t][1],
                    u[2] += p[t][2];
                u[0] /= p.length;
                u[1] /= p.length;
                u[2] /= p.length;
                w = 4 * (n * e + m);
                l[w] = (u[0] + 1) / 2 * 255 | 0;
                l[w + 1] = (u[1] + 1) / 2 * 255 | 0;
                l[w + 2] = 255 * u[2] | 0;
                l[w + 3] = 255
            }
        f.putImageData(h, 0, 0);
        return g
    },
    generateDataTexture: function(a, b, c) {
        var e = a * b
          , d = new Uint8Array(3 * e)
          , g = Math.floor(255 * c.r)
          , f = Math.floor(255 * c.g);
        c = Math.floor(255 * c.b);
        for (var k = 0; k < e; k++)
            d[3 * 
            k] = g,
            d[3 * k + 1] = f,
            d[3 * k + 2] = c;
        a = new THREE.DataTexture(d,a,b,THREE.RGBFormat);
        a.needsUpdate = !0;
        return a
    }
};
THREE.SceneUtils = {
    createMultiMaterialObject: function(a, b) {
        for (var c = new THREE.Object3D, e = 0, d = b.length; e < d; e++)
            c.add(new THREE.Mesh(a,b[e]));
        return c
    },
    detach: function(a, b, c) {
        a.applyMatrix(b.matrixWorld);
        b.remove(a);
        c.add(a)
    },
    attach: function(a, b, c) {
        var e = new THREE.Matrix4;
        e.getInverse(c.matrixWorld);
        a.applyMatrix(e);
        b.remove(a);
        c.add(a)
    }
};
THREE.FontUtils = {
    faces: {},
    face: "helvetiker",
    weight: "normal",
    style: "normal",
    size: 150,
    divisions: 10,
    getFace: function() {
        return this.faces[this.face][this.weight][this.style]
    },
    loadFace: function(a) {
        var b = a.familyName.toLowerCase();
        this.faces[b] = this.faces[b] || {};
        this.faces[b][a.cssFontWeight] = this.faces[b][a.cssFontWeight] || {};
        this.faces[b][a.cssFontWeight][a.cssFontStyle] = a;
        return this.faces[b][a.cssFontWeight][a.cssFontStyle] = a
    },
    drawText: function(a) {
        var b = this.getFace()
          , c = this.size / b.resolution
          , e = 0
          , d = 
        String(a).split("")
          , g = d.length
          , f = [];
        for (a = 0; a < g; a++) {
            var k = new THREE.Path
              , k = this.extractGlyphPoints(d[a], b, c, e, k)
              , e = e + k.offset;
            f.push(k.path)
        }
        return {
            paths: f,
            offset: e / 2
        }
    },
    extractGlyphPoints: function(a, b, c, e, d) {
        var g = [], f, k, h, l, m, n, p, t, v, r, u, w = b.glyphs[a] || b.glyphs["?"];
        if (w) {
            if (w.o)
                for (b = w._cachedOutline || (w._cachedOutline = w.o.split(" ")),
                l = b.length,
                a = 0; a < l; )
                    switch (h = b[a++],
                    h) {
                    case "m":
                        h = b[a++] * c + e;
                        m = b[a++] * c;
                        d.moveTo(h, m);
                        break;
                    case "l":
                        h = b[a++] * c + e;
                        m = b[a++] * c;
                        d.lineTo(h, m);
                        break;
                    case "q":
                        h = b[a++] * 
                        c + e;
                        m = b[a++] * c;
                        t = b[a++] * c + e;
                        v = b[a++] * c;
                        d.quadraticCurveTo(t, v, h, m);
                        if (f = g[g.length - 1])
                            for (n = f.x,
                            p = f.y,
                            f = 1,
                            k = this.divisions; f <= k; f++) {
                                var x = f / k;
                                THREE.Shape.Utils.b2(x, n, t, h);
                                THREE.Shape.Utils.b2(x, p, v, m)
                            }
                        break;
                    case "b":
                        if (h = b[a++] * c + e,
                        m = b[a++] * c,
                        t = b[a++] * c + e,
                        v = b[a++] * -c,
                        r = b[a++] * c + e,
                        u = b[a++] * -c,
                        d.bezierCurveTo(h, m, t, v, r, u),
                        f = g[g.length - 1])
                            for (n = f.x,
                            p = f.y,
                            f = 1,
                            k = this.divisions; f <= k; f++)
                                x = f / k,
                                THREE.Shape.Utils.b3(x, n, t, r, h),
                                THREE.Shape.Utils.b3(x, p, v, u, m)
                    }
            return {
                offset: w.ha * c,
                path: d
            }
        }
    }
};
THREE.FontUtils.generateShapes = function(a, b) {
    b = b || {};
    var c = void 0 !== b.curveSegments ? b.curveSegments : 4
      , e = void 0 !== b.font ? b.font : "helvetiker"
      , d = void 0 !== b.weight ? b.weight : "normal"
      , g = void 0 !== b.style ? b.style : "normal";
    THREE.FontUtils.size = void 0 !== b.size ? b.size : 100;
    THREE.FontUtils.divisions = c;
    THREE.FontUtils.face = e;
    THREE.FontUtils.weight = d;
    THREE.FontUtils.style = g;
    c = THREE.FontUtils.drawText(a).paths;
    e = [];
    d = 0;
    for (g = c.length; d < g; d++)
        Array.prototype.push.apply(e, c[d].toShapes());
    return e
}
;
(function(a) {
    var b = function(a) {
        for (var b = a.length, d = 0, g = b - 1, f = 0; f < b; g = f++)
            d += a[g].x * a[f].y - a[f].x * a[g].y;
        return .5 * d
    }
    ;
    a.Triangulate = function(a, e) {
        var d = a.length;
        if (3 > d)
            return null ;
        var g = [], f = [], k = [], h, l, m;
        if (0 < b(a))
            for (l = 0; l < d; l++)
                f[l] = l;
        else
            for (l = 0; l < d; l++)
                f[l] = d - 1 - l;
        var n = 2 * d;
        for (l = d - 1; 2 < d; ) {
            if (0 >= n--) {
                console.log("Warning, unable to triangulate polygon!");
                break
            }
            h = l;
            d <= h && (h = 0);
            l = h + 1;
            d <= l && (l = 0);
            m = l + 1;
            d <= m && (m = 0);
            var p;
            a: {
                var t = void 0
                  , v = void 0
                  , r = void 0
                  , u = void 0
                  , w = void 0
                  , x = void 0
                  , A = void 0
                  , y = void 0
                  , 
                t = a[f[h]].x
                  , v = a[f[h]].y
                  , r = a[f[l]].x
                  , u = a[f[l]].y
                  , w = a[f[m]].x
                  , x = a[f[m]].y;
                if (1E-10 > (r - t) * (x - v) - (u - v) * (w - t))
                    p = !1;
                else {
                    var z = void 0
                      , E = void 0
                      , C = void 0
                      , B = void 0
                      , K = void 0
                      , F = void 0
                      , O = void 0
                      , M = void 0
                      , G = void 0
                      , Q = void 0
                      , G = M = O = y = A = void 0
                      , z = w - r
                      , E = x - u
                      , C = t - w
                      , B = v - x
                      , K = r - t
                      , F = u - v;
                    for (p = 0; p < d; p++)
                        if (A = a[f[p]].x,
                        y = a[f[p]].y,
                        !(A === t && y === v || A === r && y === u || A === w && y === x) && (O = A - t,
                        M = y - v,
                        G = A - r,
                        Q = y - u,
                        A -= w,
                        y -= x,
                        G = z * Q - E * G,
                        O = K * M - F * O,
                        M = C * y - B * A,
                        -1E-10 <= G && -1E-10 <= M && -1E-10 <= O)) {
                            p = !1;
                            break a
                        }
                    p = !0
                }
            }
            if (p) {
                g.push([a[f[h]], a[f[l]], a[f[m]]]);
                k.push([f[h], f[l], f[m]]);
                h = l;
                for (m = l + 1; m < d; h++,
                m++)
                    f[h] = f[m];
                d--;
                n = 2 * d
            }
        }
        return e ? k : g
    }
    ;
    a.Triangulate.area = b;
    return a
}
)(THREE.FontUtils);
self._typeface_js = {
    faces: THREE.FontUtils.faces,
    loadFace: THREE.FontUtils.loadFace
};
THREE.typeface_js = self._typeface_js;
THREE.Gyroscope = function() {
    THREE.Object3D.call(this)
}
;
THREE.Gyroscope.prototype = Object.create(THREE.Object3D.prototype);
THREE.Gyroscope.prototype.updateMatrixWorld = function(a) {
    this.matrixAutoUpdate && this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || a)
        this.parent ? (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorld.decompose(this.translationWorld, this.quaternionWorld, this.scaleWorld),
        this.matrix.decompose(this.translationObject, this.quaternionObject, this.scaleObject),
        this.matrixWorld.compose(this.translationWorld, this.quaternionObject, this.scaleWorld)) : this.matrixWorld.copy(this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        a = !0;
    for (var b = 0, c = this.children.length; b < c; b++)
        this.children[b].updateMatrixWorld(a)
}
;
THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3;
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3;
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion;
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion;
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3;
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3;
THREE.AnimationHandler = function() {
    var a = []
      , b = {}
      , c = {
        update: function(b) {
            for (var c = 0; c < a.length; c++)
                a[c].update(b)
        },
        addToUpdate: function(b) {
            -1 === a.indexOf(b) && a.push(b)
        },
        removeFromUpdate: function(b) {
            b = a.indexOf(b);
            -1 !== b && a.splice(b, 1)
        },
        add: function(a) {
            void 0 !== b[a.name] && console.log("THREE.AnimationHandler.add: Warning! " + a.name + " already exists in library. Overwriting.");
            b[a.name] = a;
            if (!0 !== a.initialized) {
                for (var c = 0; c < a.hierarchy.length; c++) {
                    for (var f = 0; f < a.hierarchy[c].keys.length; f++)
                        if (0 > a.hierarchy[c].keys[f].time && 
                        (a.hierarchy[c].keys[f].time = 0),
                        void 0 !== a.hierarchy[c].keys[f].rot && !(a.hierarchy[c].keys[f].rot instanceof THREE.Quaternion)) {
                            var k = a.hierarchy[c].keys[f].rot;
                            a.hierarchy[c].keys[f].rot = new THREE.Quaternion(k[0],k[1],k[2],k[3])
                        }
                    if (a.hierarchy[c].keys.length && void 0 !== a.hierarchy[c].keys[0].morphTargets) {
                        k = {};
                        for (f = 0; f < a.hierarchy[c].keys.length; f++)
                            for (var e = 0; e < a.hierarchy[c].keys[f].morphTargets.length; e++) {
                                var l = a.hierarchy[c].keys[f].morphTargets[e];
                                k[l] = -1
                            }
                        a.hierarchy[c].usedMorphTargets = k;
                        for (f = 0; f < a.hierarchy[c].keys.length; f++) {
                            var m = {};
                            for (l in k) {
                                for (e = 0; e < a.hierarchy[c].keys[f].morphTargets.length; e++)
                                    if (a.hierarchy[c].keys[f].morphTargets[e] === l) {
                                        m[l] = a.hierarchy[c].keys[f].morphTargetsInfluences[e];
                                        break
                                    }
                                e === a.hierarchy[c].keys[f].morphTargets.length && (m[l] = 0)
                            }
                            a.hierarchy[c].keys[f].morphTargetsInfluences = m
                        }
                    }
                    for (f = 1; f < a.hierarchy[c].keys.length; f++)
                        a.hierarchy[c].keys[f].time === a.hierarchy[c].keys[f - 1].time && (a.hierarchy[c].keys.splice(f, 1),
                        f--);
                    for (f = 0; f < a.hierarchy[c].keys.length; f++)
                        a.hierarchy[c].keys[f].index = 
                        f
                }
                a.initialized = !0
            }
        },
        get: function(a) {
            if ("string" === typeof a) {
                if (b[a])
                    return b[a];
                console.log("THREE.AnimationHandler.get: Couldn't find animation " + a);
                return null 
            }
        },
        parse: function(a) {
            var b = [];
            if (a instanceof THREE.SkinnedMesh)
                for (var f = 0; f < a.bones.length; f++)
                    b.push(a.bones[f]);
            else
                e(a, b);
            return b
        }
    }
      , e = function(a, b) {
        b.push(a);
        for (var f = 0; f < a.children.length; f++)
            e(a.children[f], b)
    }
    ;
    c.LINEAR = 0;
    c.CATMULLROM = 1;
    c.CATMULLROM_FORWARD = 2;
    return c
}
();
THREE.Animation = function(a, b) {
    this.root = a;
    this.data = THREE.AnimationHandler.get(b);
    this.hierarchy = THREE.AnimationHandler.parse(a);
    this.currentTime = 0;
    this.timeScale = 1;
    this.isPlaying = !1;
    this.loop = this.isPaused = !0;
    this.interpolationType = THREE.AnimationHandler.LINEAR
}
;
THREE.Animation.prototype.play = function(a) {
    this.currentTime = void 0 !== a ? a : 0;
    !1 === this.isPlaying && (this.isPlaying = !0,
    this.reset(),
    this.update(0));
    this.isPaused = !1;
    THREE.AnimationHandler.addToUpdate(this)
}
;
THREE.Animation.prototype.pause = function() {
    !0 === this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
    this.isPaused = !this.isPaused
}
;
THREE.Animation.prototype.stop = function() {
    this.isPaused = this.isPlaying = !1;
    THREE.AnimationHandler.removeFromUpdate(this)
}
;
THREE.Animation.prototype.reset = function() {
    for (var a = 0, b = this.hierarchy.length; a < b; a++) {
        var c = this.hierarchy[a];
        c.matrixAutoUpdate = !0;
        void 0 === c.animationCache && (c.animationCache = {},
        c.animationCache.prevKey = {
            pos: 0,
            rot: 0,
            scl: 0
        },
        c.animationCache.nextKey = {
            pos: 0,
            rot: 0,
            scl: 0
        },
        c.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix);
        var e = c.animationCache.prevKey
          , c = c.animationCache.nextKey;
        e.pos = this.data.hierarchy[a].keys[0];
        e.rot = this.data.hierarchy[a].keys[0];
        e.scl = this.data.hierarchy[a].keys[0];
        c.pos = this.getNextKeyWith("pos", a, 1);
        c.rot = this.getNextKeyWith("rot", a, 1);
        c.scl = this.getNextKeyWith("scl", a, 1)
    }
}
;
THREE.Animation.prototype.update = function() {
    var a = []
      , b = new THREE.Vector3
      , c = function(a, b) {
        var f = [], c = [], h, l, m, n, p, t;
        h = (a.length - 1) * b;
        l = Math.floor(h);
        h -= l;
        f[0] = 0 === l ? l : l - 1;
        f[1] = l;
        f[2] = l > a.length - 2 ? l : l + 1;
        f[3] = l > a.length - 3 ? l : l + 2;
        l = a[f[0]];
        n = a[f[1]];
        p = a[f[2]];
        t = a[f[3]];
        f = h * h;
        m = h * f;
        c[0] = e(l[0], n[0], p[0], t[0], h, f, m);
        c[1] = e(l[1], n[1], p[1], t[1], h, f, m);
        c[2] = e(l[2], n[2], p[2], t[2], h, f, m);
        return c
    }
      , e = function(a, b, f, c, e, l, m) {
        a = .5 * (f - a);
        c = .5 * (c - b);
        return (2 * (b - f) + a + c) * m + (-3 * (b - f) - 2 * a - c) * l + a * e + b
    }
    ;
    return function(d) {
        if (!1 !== 
        this.isPlaying) {
            this.currentTime += d * this.timeScale;
            var e;
            d = ["pos", "rot", "scl"];
            var f = this.data.length;
            if (!0 === this.loop && this.currentTime > f)
                this.currentTime %= f,
                this.reset();
            else if (!1 === this.loop && this.currentTime > f) {
                this.stop();
                return
            }
            this.currentTime = Math.min(this.currentTime, f);
            for (var f = 0, k = this.hierarchy.length; f < k; f++)
                for (var h = this.hierarchy[f], l = h.animationCache, m = 0; 3 > m; m++) {
                    e = d[m];
                    var n = l.prevKey[e]
                      , p = l.nextKey[e];
                    if (p.time <= this.currentTime) {
                        n = this.data.hierarchy[f].keys[0];
                        for (p = this.getNextKeyWith(e, 
                        f, 1); p.time < this.currentTime && p.index > n.index; )
                            n = p,
                            p = this.getNextKeyWith(e, f, p.index + 1);
                        l.prevKey[e] = n;
                        l.nextKey[e] = p
                    }
                    h.matrixAutoUpdate = !0;
                    h.matrixWorldNeedsUpdate = !0;
                    var t = (this.currentTime - n.time) / (p.time - n.time)
                      , v = n[e]
                      , r = p[e];
                    0 > t && (t = 0);
                    1 < t && (t = 1);
                    if ("pos" === e)
                        if (e = h.position,
                        this.interpolationType === THREE.AnimationHandler.LINEAR)
                            e.x = v[0] + (r[0] - v[0]) * t,
                            e.y = v[1] + (r[1] - v[1]) * t,
                            e.z = v[2] + (r[2] - v[2]) * t;
                        else {
                            if (this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD)
                                a[0] = 
                                this.getPrevKeyWith("pos", f, n.index - 1).pos,
                                a[1] = v,
                                a[2] = r,
                                a[3] = this.getNextKeyWith("pos", f, p.index + 1).pos,
                                t = .33 * t + .33,
                                n = c(a, t),
                                e.x = n[0],
                                e.y = n[1],
                                e.z = n[2],
                                this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD && (t = c(a, 1.01 * t),
                                b.set(t[0], t[1], t[2]),
                                b.sub(e),
                                b.y = 0,
                                b.normalize(),
                                e = Math.atan2(b.x, b.z),
                                h.rotation.set(0, e, 0))
                        }
                    else
                        "rot" === e ? THREE.Quaternion.slerp(v, r, h.quaternion, t) : "scl" === e && (e = h.scale,
                        e.x = v[0] + (r[0] - v[0]) * t,
                        e.y = v[1] + (r[1] - v[1]) * t,
                        e.z = v[2] + (r[2] - v[2]) * t)
                }
        }
    }
}
();
THREE.Animation.prototype.getNextKeyWith = function(a, b, c) {
    var e = this.data.hierarchy[b].keys;
    for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? c < e.length - 1 ? c : e.length - 1 : c % e.length; c < e.length; c++)
        if (void 0 !== e[c][a])
            return e[c];
    return this.data.hierarchy[b].keys[0]
}
;
THREE.Animation.prototype.getPrevKeyWith = function(a, b, c) {
    var e = this.data.hierarchy[b].keys;
    for (c = this.interpolationType === THREE.AnimationHandler.CATMULLROM || this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ? 0 < c ? c : 0 : 0 <= c ? c : c + e.length; 0 <= c; c--)
        if (void 0 !== e[c][a])
            return e[c];
    return this.data.hierarchy[b].keys[e.length - 1]
}
;
THREE.KeyFrameAnimation = function(a, b) {
    this.root = a;
    this.data = THREE.AnimationHandler.get(b);
    this.hierarchy = THREE.AnimationHandler.parse(a);
    this.currentTime = 0;
    this.timeScale = .001;
    this.isPlaying = !1;
    this.loop = this.isPaused = !0;
    for (var c = 0, e = this.hierarchy.length; c < e; c++) {
        var d = this.data.hierarchy[c].sids
          , g = this.hierarchy[c];
        if (this.data.hierarchy[c].keys.length && d) {
            for (var f = 0; f < d.length; f++) {
                var k = d[f]
                  , h = this.getNextKeyWith(k, c, 0);
                h && h.apply(k)
            }
            g.matrixAutoUpdate = !1;
            this.data.hierarchy[c].node.updateMatrix();
            g.matrixWorldNeedsUpdate = !0
        }
    }
}
;
THREE.KeyFrameAnimation.prototype.play = function(a) {
    this.currentTime = void 0 !== a ? a : 0;
    if (!1 === this.isPlaying) {
        this.isPlaying = !0;
        var b = this.hierarchy.length, c, e;
        for (a = 0; a < b; a++)
            c = this.hierarchy[a],
            e = this.data.hierarchy[a],
            void 0 === e.animationCache && (e.animationCache = {},
            e.animationCache.prevKey = null ,
            e.animationCache.nextKey = null ,
            e.animationCache.originalMatrix = c instanceof THREE.Bone ? c.skinMatrix : c.matrix),
            c = this.data.hierarchy[a].keys,
            c.length && (e.animationCache.prevKey = c[0],
            e.animationCache.nextKey = 
            c[1],
            this.startTime = Math.min(c[0].time, this.startTime),
            this.endTime = Math.max(c[c.length - 1].time, this.endTime));
        this.update(0)
    }
    this.isPaused = !1;
    THREE.AnimationHandler.addToUpdate(this)
}
;
THREE.KeyFrameAnimation.prototype.pause = function() {
    this.isPaused ? THREE.AnimationHandler.addToUpdate(this) : THREE.AnimationHandler.removeFromUpdate(this);
    this.isPaused = !this.isPaused
}
;
THREE.KeyFrameAnimation.prototype.stop = function() {
    this.isPaused = this.isPlaying = !1;
    THREE.AnimationHandler.removeFromUpdate(this);
    for (var a = 0; a < this.data.hierarchy.length; a++) {
        var b = this.hierarchy[a]
          , c = this.data.hierarchy[a];
        if (void 0 !== c.animationCache) {
            var e = c.animationCache.originalMatrix;
            b instanceof THREE.Bone ? (e.copy(b.skinMatrix),
            b.skinMatrix = e) : (e.copy(b.matrix),
            b.matrix = e);
            delete c.animationCache
        }
    }
}
;
THREE.KeyFrameAnimation.prototype.update = function(a) {
    if (!1 !== this.isPlaying) {
        this.currentTime += a * this.timeScale;
        a = this.data.length;
        !0 === this.loop && this.currentTime > a && (this.currentTime %= a);
        this.currentTime = Math.min(this.currentTime, a);
        a = 0;
        for (var b = this.hierarchy.length; a < b; a++) {
            var c = this.hierarchy[a]
              , e = this.data.hierarchy[a]
              , d = e.keys
              , e = e.animationCache;
            if (d.length) {
                var g = e.prevKey
                  , f = e.nextKey;
                if (f.time <= this.currentTime) {
                    for (; f.time < this.currentTime && f.index > g.index; )
                        g = f,
                        f = d[g.index + 1];
                    e.prevKey = 
                    g;
                    e.nextKey = f
                }
                f.time >= this.currentTime ? g.interpolate(f, this.currentTime) : g.interpolate(f, f.time);
                this.data.hierarchy[a].node.updateMatrix();
                c.matrixWorldNeedsUpdate = !0
            }
        }
    }
}
;
THREE.KeyFrameAnimation.prototype.getNextKeyWith = function(a, b, c) {
    b = this.data.hierarchy[b].keys;
    for (c %= b.length; c < b.length; c++)
        if (b[c].hasTarget(a))
            return b[c];
    return b[0]
}
;
THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function(a, b, c) {
    b = this.data.hierarchy[b].keys;
    for (c = 0 <= c ? c : c + b.length; 0 <= c; c--)
        if (b[c].hasTarget(a))
            return b[c];
    return b[b.length - 1]
}
;
THREE.CubeCamera = function(a, b, c) {
    THREE.Object3D.call(this);
    var e = new THREE.PerspectiveCamera(90,1,a,b);
    e.up.set(0, -1, 0);
    e.lookAt(new THREE.Vector3(1,0,0));
    this.add(e);
    var d = new THREE.PerspectiveCamera(90,1,a,b);
    d.up.set(0, -1, 0);
    d.lookAt(new THREE.Vector3(-1,0,0));
    this.add(d);
    var g = new THREE.PerspectiveCamera(90,1,a,b);
    g.up.set(0, 0, 1);
    g.lookAt(new THREE.Vector3(0,1,0));
    this.add(g);
    var f = new THREE.PerspectiveCamera(90,1,a,b);
    f.up.set(0, 0, -1);
    f.lookAt(new THREE.Vector3(0,-1,0));
    this.add(f);
    var k = new THREE.PerspectiveCamera(90,
    1,a,b);
    k.up.set(0, -1, 0);
    k.lookAt(new THREE.Vector3(0,0,1));
    this.add(k);
    var h = new THREE.PerspectiveCamera(90,1,a,b);
    h.up.set(0, -1, 0);
    h.lookAt(new THREE.Vector3(0,0,-1));
    this.add(h);
    this.renderTarget = new THREE.WebGLRenderTargetCube(c,c,{
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    });
    this.updateCubeMap = function(a, b) {
        var c = this.renderTarget
          , p = c.generateMipmaps;
        c.generateMipmaps = !1;
        c.activeCubeFace = 0;
        a.render(b, e, c);
        c.activeCubeFace = 1;
        a.render(b, d, c);
        c.activeCubeFace = 
        2;
        a.render(b, g, c);
        c.activeCubeFace = 3;
        a.render(b, f, c);
        c.activeCubeFace = 4;
        a.render(b, k, c);
        c.generateMipmaps = p;
        c.activeCubeFace = 5;
        a.render(b, h, c)
    }
}
;
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype);
THREE.CombinedCamera = function(a, b, c, e, d, g, f) {
    THREE.Camera.call(this);
    this.fov = c;
    this.left = -a / 2;
    this.right = a / 2;
    this.top = b / 2;
    this.bottom = -b / 2;
    this.cameraO = new THREE.OrthographicCamera(a / -2,a / 2,b / 2,b / -2,g,f);
    this.cameraP = new THREE.PerspectiveCamera(c,a / b,e,d);
    this.zoom = 1;
    this.toPerspective()
}
;
THREE.CombinedCamera.prototype = Object.create(THREE.Camera.prototype);
THREE.CombinedCamera.prototype.toPerspective = function() {
    this.near = this.cameraP.near;
    this.far = this.cameraP.far;
    this.cameraP.fov = this.fov / this.zoom;
    this.cameraP.updateProjectionMatrix();
    this.projectionMatrix = this.cameraP.projectionMatrix;
    this.inPerspectiveMode = !0;
    this.inOrthographicMode = !1
}
;
THREE.CombinedCamera.prototype.toOrthographic = function() {
    var a = this.cameraP.aspect
      , b = (this.cameraP.near + this.cameraP.far) / 2
      , b = Math.tan(this.fov / 2) * b
      , a = 2 * b * a / 2
      , b = b / this.zoom
      , a = a / this.zoom;
    this.cameraO.left = -a;
    this.cameraO.right = a;
    this.cameraO.top = b;
    this.cameraO.bottom = -b;
    this.cameraO.updateProjectionMatrix();
    this.near = this.cameraO.near;
    this.far = this.cameraO.far;
    this.projectionMatrix = this.cameraO.projectionMatrix;
    this.inPerspectiveMode = !1;
    this.inOrthographicMode = !0
}
;
THREE.CombinedCamera.prototype.setSize = function(a, b) {
    this.cameraP.aspect = a / b;
    this.left = -a / 2;
    this.right = a / 2;
    this.top = b / 2;
    this.bottom = -b / 2
}
;
THREE.CombinedCamera.prototype.setFov = function(a) {
    this.fov = a;
    this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
}
;
THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {
    this.inPerspectiveMode ? this.toPerspective() : (this.toPerspective(),
    this.toOrthographic())
}
;
THREE.CombinedCamera.prototype.setLens = function(a, b) {
    void 0 === b && (b = 24);
    var c = 2 * THREE.Math.radToDeg(Math.atan(b / (2 * a)));
    this.setFov(c);
    return c
}
;
THREE.CombinedCamera.prototype.setZoom = function(a) {
    this.zoom = a;
    this.inPerspectiveMode ? this.toPerspective() : this.toOrthographic()
}
;
THREE.CombinedCamera.prototype.toFrontView = function() {
    this.rotation.x = 0;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
}
;
THREE.CombinedCamera.prototype.toBackView = function() {
    this.rotation.x = 0;
    this.rotation.y = Math.PI;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
}
;
THREE.CombinedCamera.prototype.toLeftView = function() {
    this.rotation.x = 0;
    this.rotation.y = -Math.PI / 2;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
}
;
THREE.CombinedCamera.prototype.toRightView = function() {
    this.rotation.x = 0;
    this.rotation.y = Math.PI / 2;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
}
;
THREE.CombinedCamera.prototype.toTopView = function() {
    this.rotation.x = -Math.PI / 2;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
}
;
THREE.CombinedCamera.prototype.toBottomView = function() {
    this.rotation.x = Math.PI / 2;
    this.rotation.y = 0;
    this.rotation.z = 0;
    this.rotationAutoUpdate = !1
}
;
THREE.BoxGeometry = function(a, b, c, e, d, g) {
    function f(a, f, b, d, c, e, g, r) {
        var u, w = k.widthSegments, x = k.heightSegments, A = c / 2, y = e / 2, z = k.vertices.length;
        if ("x" === a && "y" === f || "y" === a && "x" === f)
            u = "z";
        else if ("x" === a && "z" === f || "z" === a && "x" === f)
            u = "y",
            x = k.depthSegments;
        else if ("z" === a && "y" === f || "y" === a && "z" === f)
            u = "x",
            w = k.depthSegments;
        var E = w + 1
          , C = x + 1
          , B = c / w
          , K = e / x
          , F = new THREE.Vector3;
        F[u] = 0 < g ? 1 : -1;
        for (c = 0; c < C; c++)
            for (e = 0; e < E; e++) {
                var O = new THREE.Vector3;
                O[a] = (e * B - A) * b;
                O[f] = (c * K - y) * d;
                O[u] = g;
                k.vertices.push(O)
            }
        for (c = 
        0; c < x; c++)
            for (e = 0; e < w; e++)
                y = e + E * c,
                a = e + E * (c + 1),
                f = e + 1 + E * (c + 1),
                b = e + 1 + E * c,
                d = new THREE.Vector2(e / w,1 - c / x),
                g = new THREE.Vector2(e / w,1 - (c + 1) / x),
                u = new THREE.Vector2((e + 1) / w,1 - (c + 1) / x),
                A = new THREE.Vector2((e + 1) / w,1 - c / x),
                y = new THREE.Face3(y + z,a + z,b + z),
                y.normal.copy(F),
                y.vertexNormals.push(F.clone(), F.clone(), F.clone()),
                y.materialIndex = r,
                k.faces.push(y),
                k.faceVertexUvs[0].push([d, g, A]),
                y = new THREE.Face3(a + z,f + z,b + z),
                y.normal.copy(F),
                y.vertexNormals.push(F.clone(), F.clone(), F.clone()),
                y.materialIndex = r,
                k.faces.push(y),
                k.faceVertexUvs[0].push([g.clone(), u, A.clone()])
    }
    THREE.Geometry.call(this);
    var k = this;
    this.width = a;
    this.height = b;
    this.depth = c;
    this.widthSegments = e || 1;
    this.heightSegments = d || 1;
    this.depthSegments = g || 1;
    a = this.width / 2;
    b = this.height / 2;
    c = this.depth / 2;
    f("z", "y", -1, -1, this.depth, this.height, a, 0);
    f("z", "y", 1, -1, this.depth, this.height, -a, 1);
    f("x", "z", 1, 1, this.width, this.depth, b, 2);
    f("x", "z", 1, -1, this.width, this.depth, -b, 3);
    f("x", "y", 1, -1, this.width, this.height, c, 4);
    f("x", "y", -1, -1, this.width, this.height, -c, 
    5);
    this.computeCentroids();
    this.mergeVertices()
}
;
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CircleGeometry = function(a, b, c, e) {
    THREE.Geometry.call(this);
    this.radius = a = a || 50;
    this.segments = b = void 0 !== b ? Math.max(3, b) : 8;
    this.thetaStart = c = void 0 !== c ? c : 0;
    this.thetaLength = e = void 0 !== e ? e : 2 * Math.PI;
    var d, g = [];
    d = new THREE.Vector3;
    var f = new THREE.Vector2(.5,.5);
    this.vertices.push(d);
    g.push(f);
    for (d = 0; d <= b; d++) {
        var k = new THREE.Vector3
          , h = c + d / b * e;
        k.x = a * Math.cos(h);
        k.y = a * Math.sin(h);
        this.vertices.push(k);
        g.push(new THREE.Vector2((k.x / a + 1) / 2,(k.y / a + 1) / 2))
    }
    c = new THREE.Vector3(0,0,1);
    for (d = 1; d <= b; d++)
        this.faces.push(new THREE.Face3(d,
        d + 1,0,[c.clone(), c.clone(), c.clone()])),
        this.faceVertexUvs[0].push([g[d].clone(), g[d + 1].clone(), f.clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3,a)
}
;
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.CylinderGeometry = function(a, b, c, e, d, g) {
    THREE.Geometry.call(this);
    this.radiusTop = a = void 0 !== a ? a : 20;
    this.radiusBottom = b = void 0 !== b ? b : 20;
    this.height = c = void 0 !== c ? c : 100;
    this.radialSegments = e = e || 8;
    this.heightSegments = d = d || 1;
    this.openEnded = g = void 0 !== g ? g : !1;
    var f = c / 2, k, h, l = [], m = [];
    for (h = 0; h <= d; h++) {
        var n = []
          , p = []
          , t = h / d
          , v = t * (b - a) + a;
        for (k = 0; k <= e; k++) {
            var r = k / e
              , u = new THREE.Vector3;
            u.x = v * Math.sin(r * Math.PI * 2);
            u.y = -t * c + f;
            u.z = v * Math.cos(r * Math.PI * 2);
            this.vertices.push(u);
            n.push(this.vertices.length - 1);
            p.push(new THREE.Vector2(r,
            1 - t))
        }
        l.push(n);
        m.push(p)
    }
    c = (b - a) / c;
    for (k = 0; k < e; k++)
        for (0 !== a ? (n = this.vertices[l[0][k]].clone(),
        p = this.vertices[l[0][k + 1]].clone()) : (n = this.vertices[l[1][k]].clone(),
        p = this.vertices[l[1][k + 1]].clone()),
        n.setY(Math.sqrt(n.x * n.x + n.z * n.z) * c).normalize(),
        p.setY(Math.sqrt(p.x * p.x + p.z * p.z) * c).normalize(),
        h = 0; h < d; h++) {
            var t = l[h][k]
              , v = l[h + 1][k]
              , r = l[h + 1][k + 1]
              , u = l[h][k + 1]
              , w = n.clone()
              , x = n.clone()
              , A = p.clone()
              , y = p.clone()
              , z = m[h][k].clone()
              , E = m[h + 1][k].clone()
              , C = m[h + 1][k + 1].clone()
              , B = m[h][k + 1].clone();
            this.faces.push(new THREE.Face3(t,
            v,u,[w, x, y]));
            this.faceVertexUvs[0].push([z, E, B]);
            this.faces.push(new THREE.Face3(v,r,u,[x.clone(), A, y.clone()]));
            this.faceVertexUvs[0].push([E.clone(), C, B.clone()])
        }
    if (!1 === g && 0 < a)
        for (this.vertices.push(new THREE.Vector3(0,f,0)),
        k = 0; k < e; k++)
            t = l[0][k],
            v = l[0][k + 1],
            r = this.vertices.length - 1,
            w = new THREE.Vector3(0,1,0),
            x = new THREE.Vector3(0,1,0),
            A = new THREE.Vector3(0,1,0),
            z = m[0][k].clone(),
            E = m[0][k + 1].clone(),
            C = new THREE.Vector2(E.x,0),
            this.faces.push(new THREE.Face3(t,v,r,[w, x, A])),
            this.faceVertexUvs[0].push([z, 
            E, C]);
    if (!1 === g && 0 < b)
        for (this.vertices.push(new THREE.Vector3(0,-f,0)),
        k = 0; k < e; k++)
            t = l[h][k + 1],
            v = l[h][k],
            r = this.vertices.length - 1,
            w = new THREE.Vector3(0,-1,0),
            x = new THREE.Vector3(0,-1,0),
            A = new THREE.Vector3(0,-1,0),
            z = m[h][k + 1].clone(),
            E = m[h][k].clone(),
            C = new THREE.Vector2(E.x,1),
            this.faces.push(new THREE.Face3(t,v,r,[w, x, A])),
            this.faceVertexUvs[0].push([z, E, C]);
    this.computeCentroids();
    this.computeFaceNormals()
}
;
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry = function(a, b) {
    "undefined" !== typeof a && (THREE.Geometry.call(this),
    a = a instanceof Array ? a : [a],
    this.shapebb = a[a.length - 1].getBoundingBox(),
    this.addShapeList(a, b),
    this.computeCentroids(),
    this.computeFaceNormals())
}
;
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ExtrudeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = a.length, e = 0; e < c; e++)
        this.addShape(a[e], b)
}
;
THREE.ExtrudeGeometry.prototype.addShape = function(a, b) {
    function c(a, f, b) {
        f || console.log("die");
        return f.clone().multiplyScalar(b).add(a)
    }
    function e(a, f, b) {
        var d = THREE.Math.sign
          , c = 1
          , c = a.x - f.x
          , k = a.y - f.y
          , e = b.x - a.x
          , h = b.y - a.y
          , g = c * c + k * k;
        if (1E-10 < Math.abs(c * h - k * e)) {
            var l = Math.sqrt(g)
              , d = Math.sqrt(e * e + h * h)
              , g = f.x - k / l;
            f = f.y + c / l;
            e = ((b.x - h / d - g) * h - (b.y + e / d - f) * e) / (c * h - k * e);
            b = g + c * e - a.x;
            a = f + k * e - a.y;
            c = b * b + a * a;
            if (2 >= c)
                return new THREE.Vector2(b,a);
            c = Math.sqrt(c / 2)
        } else
            a = !1,
            1E-10 < c ? 1E-10 < e && (a = !0) : -1E-10 > c ? -1E-10 > e && 
            (a = !0) : d(k) == d(h) && (a = !0),
            a ? (b = -k,
            a = c,
            c = Math.sqrt(g)) : (b = c,
            a = k,
            c = Math.sqrt(g / 2));
        return new THREE.Vector2(b / c,a / c)
    }
    function d(f, d) {
        var c, k;
        for (P = f.length; 0 <= --P; ) {
            c = P;
            k = P - 1;
            0 > k && (k = f.length - 1);
            for (var e = 0, h = t + 2 * m, e = 0; e < h; e++) {
                var g = ca * e
                  , l = ca * (e + 1)
                  , n = d + c + g
                  , g = d + k + g
                  , p = d + k + l
                  , l = d + c + l
                  , r = f
                  , Z = e
                  , u = h
                  , w = c
                  , v = k
                  , n = n + M
                  , g = g + M
                  , p = p + M
                  , l = l + M;
                O.faces.push(new THREE.Face3(n,g,l,null ,null ,x));
                O.faces.push(new THREE.Face3(g,p,l,null ,null ,x));
                n = A.generateSideWallUV(O, a, r, b, n, g, p, l, Z, u, w, v);
                O.faceVertexUvs[0].push([n[0], n[1], 
                n[3]]);
                O.faceVertexUvs[0].push([n[1], n[2], n[3]])
            }
        }
    }
    function g(a, f, b) {
        O.vertices.push(new THREE.Vector3(a,f,b))
    }
    function f(f, d, c, k) {
        f += M;
        d += M;
        c += M;
        O.faces.push(new THREE.Face3(f,d,c,null ,null ,w));
        f = k ? A.generateBottomUV(O, a, b, f, d, c) : A.generateTopUV(O, a, b, f, d, c);
        O.faceVertexUvs[0].push(f)
    }
    var k = void 0 !== b.amount ? b.amount : 100, h = void 0 !== b.bevelThickness ? b.bevelThickness : 6, l = void 0 !== b.bevelSize ? b.bevelSize : h - 2, m = void 0 !== b.bevelSegments ? b.bevelSegments : 3, n = void 0 !== b.bevelEnabled ? b.bevelEnabled : !0, p = 
    void 0 !== b.curveSegments ? b.curveSegments : 12, t = void 0 !== b.steps ? b.steps : 1, v = b.extrudePath, r, u = !1, w = b.material, x = b.extrudeMaterial, A = void 0 !== b.UVGenerator ? b.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator, y, z, E, C;
    v && (r = v.getSpacedPoints(t),
    u = !0,
    n = !1,
    y = void 0 !== b.frames ? b.frames : new THREE.TubeGeometry.FrenetFrames(v,t,!1),
    z = new THREE.Vector3,
    E = new THREE.Vector3,
    C = new THREE.Vector3);
    n || (l = h = m = 0);
    var B, K, F, O = this, M = this.vertices.length, v = a.extractPoints(p), p = v.shape, G = v.holes;
    if (v = !THREE.Shape.Utils.isClockWise(p)) {
        p = 
        p.reverse();
        K = 0;
        for (F = G.length; K < F; K++)
            B = G[K],
            THREE.Shape.Utils.isClockWise(B) && (G[K] = B.reverse());
        v = !1
    }
    var Q = THREE.Shape.Utils.triangulateShape(p, G)
      , R = p;
    K = 0;
    for (F = G.length; K < F; K++)
        B = G[K],
        p = p.concat(B);
    var S, U, H, Z, N, ca = p.length, J, Y = Q.length, v = [], P = 0;
    H = R.length;
    S = H - 1;
    for (U = P + 1; P < H; P++,
    S++,
    U++)
        S === H && (S = 0),
        U === H && (U = 0),
        v[P] = e(R[P], R[S], R[U]);
    var fa = [], ia, aa = v.concat();
    K = 0;
    for (F = G.length; K < F; K++) {
        B = G[K];
        ia = [];
        P = 0;
        H = B.length;
        S = H - 1;
        for (U = P + 1; P < H; P++,
        S++,
        U++)
            S === H && (S = 0),
            U === H && (U = 0),
            ia[P] = e(B[P], B[S], 
            B[U]);
        fa.push(ia);
        aa = aa.concat(ia)
    }
    for (S = 0; S < m; S++) {
        H = S / m;
        Z = h * (1 - H);
        U = l * Math.sin(H * Math.PI / 2);
        P = 0;
        for (H = R.length; P < H; P++)
            N = c(R[P], v[P], U),
            g(N.x, N.y, -Z);
        K = 0;
        for (F = G.length; K < F; K++)
            for (B = G[K],
            ia = fa[K],
            P = 0,
            H = B.length; P < H; P++)
                N = c(B[P], ia[P], U),
                g(N.x, N.y, -Z)
    }
    U = l;
    for (P = 0; P < ca; P++)
        N = n ? c(p[P], aa[P], U) : p[P],
        u ? (E.copy(y.normals[0]).multiplyScalar(N.x),
        z.copy(y.binormals[0]).multiplyScalar(N.y),
        C.copy(r[0]).add(E).add(z),
        g(C.x, C.y, C.z)) : g(N.x, N.y, 0);
    for (H = 1; H <= t; H++)
        for (P = 0; P < ca; P++)
            N = n ? c(p[P], aa[P], U) : p[P],
            u ? (E.copy(y.normals[H]).multiplyScalar(N.x),
            z.copy(y.binormals[H]).multiplyScalar(N.y),
            C.copy(r[H]).add(E).add(z),
            g(C.x, C.y, C.z)) : g(N.x, N.y, k / t * H);
    for (S = m - 1; 0 <= S; S--) {
        H = S / m;
        Z = h * (1 - H);
        U = l * Math.sin(H * Math.PI / 2);
        P = 0;
        for (H = R.length; P < H; P++)
            N = c(R[P], v[P], U),
            g(N.x, N.y, k + Z);
        K = 0;
        for (F = G.length; K < F; K++)
            for (B = G[K],
            ia = fa[K],
            P = 0,
            H = B.length; P < H; P++)
                N = c(B[P], ia[P], U),
                u ? g(N.x, N.y + r[t - 1].y, r[t - 1].x + Z) : g(N.x, N.y, k + Z)
    }
    (function() {
        if (n) {
            var a;
            a = 0 * ca;
            for (P = 0; P < Y; P++)
                J = Q[P],
                f(J[2] + a, J[1] + a, J[0] + a, !0);
            a = t + 2 * m;
            a *= ca;
            for (P = 
            0; P < Y; P++)
                J = Q[P],
                f(J[0] + a, J[1] + a, J[2] + a, !1)
        } else {
            for (P = 0; P < Y; P++)
                J = Q[P],
                f(J[2], J[1], J[0], !0);
            for (P = 0; P < Y; P++)
                J = Q[P],
                f(J[0] + ca * t, J[1] + ca * t, J[2] + ca * t, !1)
        }
    }
    )();
    (function() {
        var a = 0;
        d(R, a);
        a += R.length;
        K = 0;
        for (F = G.length; K < F; K++)
            B = G[K],
            d(B, a),
            a += B.length
    }
    )()
}
;
THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function(a, b, c, e, d, g) {
        b = a.vertices[d].x;
        d = a.vertices[d].y;
        c = a.vertices[g].x;
        g = a.vertices[g].y;
        return [new THREE.Vector2(a.vertices[e].x,a.vertices[e].y), new THREE.Vector2(b,d), new THREE.Vector2(c,g)]
    },
    generateBottomUV: function(a, b, c, e, d, g) {
        return this.generateTopUV(a, b, c, e, d, g)
    },
    generateSideWallUV: function(a, b, c, e, d, g, f, k, h, l, m, n) {
        b = a.vertices[d].x;
        c = a.vertices[d].y;
        d = a.vertices[d].z;
        e = a.vertices[g].x;
        h = a.vertices[g].y;
        g = a.vertices[g].z;
        l = a.vertices[f].x;
        m = a.vertices[f].y;
        f = a.vertices[f].z;
        n = a.vertices[k].x;
        var p = a.vertices[k].y;
        a = a.vertices[k].z;
        return .01 > Math.abs(c - h) ? [new THREE.Vector2(b,1 - d), new THREE.Vector2(e,1 - g), new THREE.Vector2(l,1 - f), new THREE.Vector2(n,1 - a)] : [new THREE.Vector2(c,1 - d), new THREE.Vector2(h,1 - g), new THREE.Vector2(m,1 - f), new THREE.Vector2(p,1 - a)]
    }
};
THREE.ExtrudeGeometry.__v1 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2;
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2;
THREE.ShapeGeometry = function(a, b) {
    THREE.Geometry.call(this);
    !1 === a instanceof Array && (a = [a]);
    this.shapebb = a[a.length - 1].getBoundingBox();
    this.addShapeList(a, b);
    this.computeCentroids();
    this.computeFaceNormals()
}
;
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.ShapeGeometry.prototype.addShapeList = function(a, b) {
    for (var c = 0, e = a.length; c < e; c++)
        this.addShape(a[c], b);
    return this
}
;
THREE.ShapeGeometry.prototype.addShape = function(a, b) {
    void 0 === b && (b = {});
    var c = b.material, e = void 0 === b.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator : b.UVGenerator, d, g, f, k = this.vertices.length;
    d = a.extractPoints(void 0 !== b.curveSegments ? b.curveSegments : 12);
    var h = d.shape
      , l = d.holes;
    if (!THREE.Shape.Utils.isClockWise(h))
        for (h = h.reverse(),
        d = 0,
        g = l.length; d < g; d++)
            f = l[d],
            THREE.Shape.Utils.isClockWise(f) && (l[d] = f.reverse());
    var m = THREE.Shape.Utils.triangulateShape(h, l);
    d = 0;
    for (g = l.length; d < g; d++)
        f = l[d],
        h = h.concat(f);
    l = h.length;
    g = m.length;
    for (d = 0; d < l; d++)
        f = h[d],
        this.vertices.push(new THREE.Vector3(f.x,f.y,0));
    for (d = 0; d < g; d++)
        l = m[d],
        h = l[0] + k,
        f = l[1] + k,
        l = l[2] + k,
        this.faces.push(new THREE.Face3(h,f,l,null ,null ,c)),
        this.faceVertexUvs[0].push(e.generateBottomUV(this, a, b, h, f, l))
}
;
THREE.LatheGeometry = function(a, b, c, e) {
    THREE.Geometry.call(this);
    b = b || 12;
    c = c || 0;
    e = e || 2 * Math.PI;
    for (var d = 1 / (a.length - 1), g = 1 / b, f = 0, k = b; f <= k; f++)
        for (var h = c + f * g * e, l = Math.cos(h), m = Math.sin(h), h = 0, n = a.length; h < n; h++) {
            var p = a[h]
              , t = new THREE.Vector3;
            t.x = l * p.x - m * p.y;
            t.y = m * p.x + l * p.y;
            t.z = p.z;
            this.vertices.push(t)
        }
    c = a.length;
    f = 0;
    for (k = b; f < k; f++)
        for (h = 0,
        n = a.length - 1; h < n; h++) {
            b = m = h + c * f;
            e = m + c;
            var l = m + 1 + c
              , m = m + 1
              , p = f * g
              , t = h * d
              , v = p + g
              , r = t + d;
            this.faces.push(new THREE.Face3(b,e,m));
            this.faceVertexUvs[0].push([new THREE.Vector2(p,
            t), new THREE.Vector2(v,t), new THREE.Vector2(p,r)]);
            this.faces.push(new THREE.Face3(e,l,m));
            this.faceVertexUvs[0].push([new THREE.Vector2(v,t), new THREE.Vector2(v,r), new THREE.Vector2(p,r)])
        }
    this.mergeVertices();
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
}
;
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.PlaneGeometry = function(a, b, c, e) {
    THREE.Geometry.call(this);
    this.width = a;
    this.height = b;
    this.widthSegments = c || 1;
    this.heightSegments = e || 1;
    var d = a / 2
      , g = b / 2;
    c = this.widthSegments;
    e = this.heightSegments;
    var f = c + 1
      , k = e + 1
      , h = this.width / c
      , l = this.height / e
      , m = new THREE.Vector3(0,0,1);
    for (a = 0; a < k; a++)
        for (b = 0; b < f; b++)
            this.vertices.push(new THREE.Vector3(b * h - d,-(a * l - g),0));
    for (a = 0; a < e; a++)
        for (b = 0; b < c; b++) {
            var n = b + f * a
              , d = b + f * (a + 1)
              , g = b + 1 + f * (a + 1)
              , k = b + 1 + f * a
              , h = new THREE.Vector2(b / c,1 - a / e)
              , l = new THREE.Vector2(b / c,1 - (a + 
            1) / e)
              , p = new THREE.Vector2((b + 1) / c,1 - (a + 1) / e)
              , t = new THREE.Vector2((b + 1) / c,1 - a / e)
              , n = new THREE.Face3(n,d,k);
            n.normal.copy(m);
            n.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(n);
            this.faceVertexUvs[0].push([h, l, t]);
            n = new THREE.Face3(d,g,k);
            n.normal.copy(m);
            n.vertexNormals.push(m.clone(), m.clone(), m.clone());
            this.faces.push(n);
            this.faceVertexUvs[0].push([l.clone(), p, t.clone()])
        }
    this.computeCentroids()
}
;
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.RingGeometry = function(a, b, c, e, d, g) {
    THREE.Geometry.call(this);
    a = a || 0;
    b = b || 50;
    d = void 0 !== d ? d : 0;
    g = void 0 !== g ? g : 2 * Math.PI;
    c = void 0 !== c ? Math.max(3, c) : 8;
    e = void 0 !== e ? Math.max(3, e) : 8;
    var f, k = [], h = a, l = (b - a) / e;
    for (a = 0; a <= e; a++) {
        for (f = 0; f <= c; f++) {
            var m = new THREE.Vector3
              , n = d + f / c * g;
            m.x = h * Math.cos(n);
            m.y = h * Math.sin(n);
            this.vertices.push(m);
            k.push(new THREE.Vector2((m.x / b + 1) / 2,(m.y / b + 1) / 2))
        }
        h += l
    }
    b = new THREE.Vector3(0,0,1);
    for (a = 0; a < e; a++)
        for (d = a * c,
        f = 0; f <= c; f++)
            n = f + d,
            g = n + a,
            l = n + c + a,
            m = n + c + 1 + a,
            this.faces.push(new THREE.Face3(g,
            l,m,[b.clone(), b.clone(), b.clone()])),
            this.faceVertexUvs[0].push([k[g].clone(), k[l].clone(), k[m].clone()]),
            g = n + a,
            l = n + c + 1 + a,
            m = n + 1 + a,
            this.faces.push(new THREE.Face3(g,l,m,[b.clone(), b.clone(), b.clone()])),
            this.faceVertexUvs[0].push([k[g].clone(), k[l].clone(), k[m].clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3,h)
}
;
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.SphereGeometry = function(a, b, c, e, d, g, f) {
    THREE.Geometry.call(this);
    this.radius = a = a || 50;
    this.widthSegments = b = Math.max(3, Math.floor(b) || 8);
    this.heightSegments = c = Math.max(2, Math.floor(c) || 6);
    this.phiStart = e = void 0 !== e ? e : 0;
    this.phiLength = d = void 0 !== d ? d : 2 * Math.PI;
    this.thetaStart = g = void 0 !== g ? g : 0;
    this.thetaLength = f = void 0 !== f ? f : Math.PI;
    var k, h, l = [], m = [];
    for (h = 0; h <= c; h++) {
        var n = []
          , p = [];
        for (k = 0; k <= b; k++) {
            var t = k / b
              , v = h / c
              , r = new THREE.Vector3;
            r.x = -a * Math.cos(e + t * d) * Math.sin(g + v * f);
            r.y = a * Math.cos(g + v * f);
            r.z = a * Math.sin(e + t * d) * Math.sin(g + v * f);
            this.vertices.push(r);
            n.push(this.vertices.length - 1);
            p.push(new THREE.Vector2(t,1 - v))
        }
        l.push(n);
        m.push(p)
    }
    for (h = 0; h < this.heightSegments; h++)
        for (k = 0; k < this.widthSegments; k++) {
            b = l[h][k + 1];
            c = l[h][k];
            e = l[h + 1][k];
            d = l[h + 1][k + 1];
            g = this.vertices[b].clone().normalize();
            f = this.vertices[c].clone().normalize();
            var n = this.vertices[e].clone().normalize()
              , p = this.vertices[d].clone().normalize()
              , t = m[h][k + 1].clone()
              , v = m[h][k].clone()
              , r = m[h + 1][k].clone()
              , u = m[h + 1][k + 1].clone();
            Math.abs(this.vertices[b].y) === 
            this.radius ? (t.x = (t.x + v.x) / 2,
            this.faces.push(new THREE.Face3(b,e,d,[g, n, p])),
            this.faceVertexUvs[0].push([t, r, u])) : Math.abs(this.vertices[e].y) === this.radius ? (r.x = (r.x + u.x) / 2,
            this.faces.push(new THREE.Face3(b,c,e,[g, f, n])),
            this.faceVertexUvs[0].push([t, v, r])) : (this.faces.push(new THREE.Face3(b,c,d,[g, f, p])),
            this.faceVertexUvs[0].push([t, v, u]),
            this.faces.push(new THREE.Face3(c,e,d,[f.clone(), n, p.clone()])),
            this.faceVertexUvs[0].push([v.clone(), r, u.clone()]))
        }
    this.computeCentroids();
    this.computeFaceNormals();
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3,a)
}
;
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TextGeometry = function(a, b) {
    b = b || {};
    var c = THREE.FontUtils.generateShapes(a, b);
    b.amount = void 0 !== b.height ? b.height : 50;
    void 0 === b.bevelThickness && (b.bevelThickness = 10);
    void 0 === b.bevelSize && (b.bevelSize = 8);
    void 0 === b.bevelEnabled && (b.bevelEnabled = !1);
    THREE.ExtrudeGeometry.call(this, c, b)
}
;
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype);
THREE.TorusGeometry = function(a, b, c, e, d) {
    THREE.Geometry.call(this);
    this.radius = a || 100;
    this.tube = b || 40;
    this.radialSegments = c || 8;
    this.tubularSegments = e || 6;
    this.arc = d || 2 * Math.PI;
    d = new THREE.Vector3;
    a = [];
    b = [];
    for (c = 0; c <= this.radialSegments; c++)
        for (e = 0; e <= this.tubularSegments; e++) {
            var g = e / this.tubularSegments * this.arc
              , f = c / this.radialSegments * Math.PI * 2;
            d.x = this.radius * Math.cos(g);
            d.y = this.radius * Math.sin(g);
            var k = new THREE.Vector3;
            k.x = (this.radius + this.tube * Math.cos(f)) * Math.cos(g);
            k.y = (this.radius + this.tube * 
            Math.cos(f)) * Math.sin(g);
            k.z = this.tube * Math.sin(f);
            this.vertices.push(k);
            a.push(new THREE.Vector2(e / this.tubularSegments,c / this.radialSegments));
            b.push(k.clone().sub(d).normalize())
        }
    for (c = 1; c <= this.radialSegments; c++)
        for (e = 1; e <= this.tubularSegments; e++) {
            d = (this.tubularSegments + 1) * c + e - 1;
            var g = (this.tubularSegments + 1) * (c - 1) + e - 1
              , f = (this.tubularSegments + 1) * (c - 1) + e
              , k = (this.tubularSegments + 1) * c + e
              , h = new THREE.Face3(d,g,k,[b[d].clone(), b[g].clone(), b[k].clone()]);
            this.faces.push(h);
            this.faceVertexUvs[0].push([a[d].clone(), 
            a[g].clone(), a[k].clone()]);
            h = new THREE.Face3(g,f,k,[b[g].clone(), b[f].clone(), b[k].clone()]);
            this.faces.push(h);
            this.faceVertexUvs[0].push([a[g].clone(), a[f].clone(), a[k].clone()])
        }
    this.computeCentroids();
    this.computeFaceNormals()
}
;
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry = function(a, b, c, e, d) {
    THREE.Geometry.call(this);
    this.path = a;
    this.segments = b || 64;
    this.radius = c || 1;
    this.radialSegments = e || 8;
    this.closed = d || !1;
    this.grid = [];
    var g, f;
    e = this.segments + 1;
    var k, h, l;
    d = new THREE.Vector3;
    var m, n;
    b = new THREE.TubeGeometry.FrenetFrames(this.path,this.segments,this.closed);
    m = b.normals;
    n = b.binormals;
    this.tangents = b.tangents;
    this.normals = m;
    this.binormals = n;
    for (b = 0; b < e; b++)
        for (this.grid[b] = [],
        c = b / (e - 1),
        l = a.getPointAt(c),
        g = m[b],
        f = n[b],
        c = 0; c < this.radialSegments; c++)
            k = 
            c / this.radialSegments * 2 * Math.PI,
            h = -this.radius * Math.cos(k),
            k = this.radius * Math.sin(k),
            d.copy(l),
            d.x += h * g.x + k * f.x,
            d.y += h * g.y + k * f.y,
            d.z += h * g.z + k * f.z,
            this.grid[b][c] = this.vertices.push(new THREE.Vector3(d.x,d.y,d.z)) - 1;
    for (b = 0; b < this.segments; b++)
        for (c = 0; c < this.radialSegments; c++)
            d = this.closed ? (b + 1) % this.segments : b + 1,
            m = (c + 1) % this.radialSegments,
            a = this.grid[b][c],
            e = this.grid[d][c],
            d = this.grid[d][m],
            m = this.grid[b][m],
            n = new THREE.Vector2(b / this.segments,c / this.radialSegments),
            g = new THREE.Vector2((b + 1) / this.segments,
            c / this.radialSegments),
            f = new THREE.Vector2((b + 1) / this.segments,(c + 1) / this.radialSegments),
            h = new THREE.Vector2(b / this.segments,(c + 1) / this.radialSegments),
            this.faces.push(new THREE.Face3(a,e,m)),
            this.faceVertexUvs[0].push([n, g, h]),
            this.faces.push(new THREE.Face3(e,d,m)),
            this.faceVertexUvs[0].push([g.clone(), f, h.clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
}
;
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.TubeGeometry.FrenetFrames = function(a, b, c) {
    new THREE.Vector3;
    var e = new THREE.Vector3;
    new THREE.Vector3;
    var d = []
      , g = []
      , f = []
      , k = new THREE.Vector3
      , h = new THREE.Matrix4;
    b += 1;
    var l, m, n;
    this.tangents = d;
    this.normals = g;
    this.binormals = f;
    for (l = 0; l < b; l++)
        m = l / (b - 1),
        d[l] = a.getTangentAt(m),
        d[l].normalize();
    g[0] = new THREE.Vector3;
    f[0] = new THREE.Vector3;
    a = Number.MAX_VALUE;
    l = Math.abs(d[0].x);
    m = Math.abs(d[0].y);
    n = Math.abs(d[0].z);
    l <= a && (a = l,
    e.set(1, 0, 0));
    m <= a && (a = m,
    e.set(0, 1, 0));
    n <= a && e.set(0, 0, 1);
    k.crossVectors(d[0], 
    e).normalize();
    g[0].crossVectors(d[0], k);
    f[0].crossVectors(d[0], g[0]);
    for (l = 1; l < b; l++)
        g[l] = g[l - 1].clone(),
        f[l] = f[l - 1].clone(),
        k.crossVectors(d[l - 1], d[l]),
        1E-4 < k.length() && (k.normalize(),
        e = Math.acos(THREE.Math.clamp(d[l - 1].dot(d[l]), -1, 1)),
        g[l].applyMatrix4(h.makeRotationAxis(k, e))),
        f[l].crossVectors(d[l], g[l]);
    if (c)
        for (e = Math.acos(THREE.Math.clamp(g[0].dot(g[b - 1]), -1, 1)),
        e /= b - 1,
        0 < d[0].dot(k.crossVectors(g[0], g[b - 1])) && (e = -e),
        l = 1; l < b; l++)
            g[l].applyMatrix4(h.makeRotationAxis(d[l], e * l)),
            f[l].crossVectors(d[l], 
            g[l])
}
;
THREE.ParametricGeometry = function(a, b, c) {
    THREE.Geometry.call(this);
    var e = this.vertices, d = this.faces, g = this.faceVertexUvs[0], f, k, h, l, m = b + 1;
    for (f = 0; f <= c; f++)
        for (l = f / c,
        k = 0; k <= b; k++)
            h = k / b,
            h = a(h, l),
            e.push(h);
    var n, p, t, v;
    for (f = 0; f < c; f++)
        for (k = 0; k < b; k++)
            a = f * m + k,
            e = f * m + k + 1,
            l = (f + 1) * m + k + 1,
            h = (f + 1) * m + k,
            n = new THREE.Vector2(k / b,f / c),
            p = new THREE.Vector2((k + 1) / b,f / c),
            t = new THREE.Vector2((k + 1) / b,(f + 1) / c),
            v = new THREE.Vector2(k / b,(f + 1) / c),
            d.push(new THREE.Face3(a,e,h)),
            g.push([n, p, v]),
            d.push(new THREE.Face3(e,l,h)),
            g.push([p.clone(), t, v.clone()]);
    this.computeCentroids();
    this.computeFaceNormals();
    this.computeVertexNormals()
}
;
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype);
THREE.AxisHelper = function(a) {
    a = a || 1;
    var b = new THREE.Geometry;
    b.vertices.push(new THREE.Vector3, new THREE.Vector3(a,0,0), new THREE.Vector3, new THREE.Vector3(0,a,0), new THREE.Vector3, new THREE.Vector3(0,0,a));
    b.colors.push(new THREE.Color(16711680), new THREE.Color(16755200), new THREE.Color(65280), new THREE.Color(11206400), new THREE.Color(255), new THREE.Color(43775));
    a = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    THREE.Line.call(this, b, a, THREE.LinePieces)
}
;
THREE.AxisHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ArrowHelper = function(a, b, c, e, d, g) {
    THREE.Object3D.call(this);
    void 0 === e && (e = 16776960);
    void 0 === c && (c = 1);
    void 0 === d && (d = .2 * c);
    void 0 === g && (g = .2 * d);
    this.position = b;
    b = new THREE.Geometry;
    b.vertices.push(new THREE.Vector3(0,0,0));
    b.vertices.push(new THREE.Vector3(0,1,0));
    this.line = new THREE.Line(b,new THREE.LineBasicMaterial({
        color: e
    }));
    this.line.matrixAutoUpdate = !1;
    this.add(this.line);
    b = new THREE.CylinderGeometry(0,.5,1,5,1);
    b.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
    this.cone = new THREE.Mesh(b,
    new THREE.MeshBasicMaterial({
        color: e
    }));
    this.cone.matrixAutoUpdate = !1;
    this.add(this.cone);
    this.setDirection(a);
    this.setLength(c, d, g)
}
;
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.ArrowHelper.prototype.setDirection = function() {
    var a = new THREE.Vector3, b;
    return function(c) {
        .99999 < c.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > c.y ? this.quaternion.set(1, 0, 0, 0) : (a.set(c.z, 0, -c.x).normalize(),
        b = Math.acos(c.y),
        this.quaternion.setFromAxisAngle(a, b))
    }
}
();
THREE.ArrowHelper.prototype.setLength = function(a, b, c) {
    void 0 === b && (b = .2 * a);
    void 0 === c && (c = .2 * b);
    this.line.scale.set(1, a, 1);
    this.line.updateMatrix();
    this.cone.scale.set(c, b, c);
    this.cone.position.y = a;
    this.cone.updateMatrix()
}
;
THREE.ArrowHelper.prototype.setColor = function(a) {
    this.line.material.color.setHex(a);
    this.cone.material.color.setHex(a)
}
;
THREE.BoxHelper = function(a) {
    var b = [new THREE.Vector3(1,1,1), new THREE.Vector3(-1,1,1), new THREE.Vector3(-1,-1,1), new THREE.Vector3(1,-1,1), new THREE.Vector3(1,1,-1), new THREE.Vector3(-1,1,-1), new THREE.Vector3(-1,-1,-1), new THREE.Vector3(1,-1,-1)];
    this.vertices = b;
    var c = new THREE.Geometry;
    c.vertices.push(b[0], b[1], b[1], b[2], b[2], b[3], b[3], b[0], b[4], b[5], b[5], b[6], b[6], b[7], b[7], b[4], b[0], b[4], b[1], b[5], b[2], b[6], b[3], b[7]);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: 16776960
    }), THREE.LinePieces);
    void 0 !== a && this.update(a)
}
;
THREE.BoxHelper.prototype = Object.create(THREE.Line.prototype);
THREE.BoxHelper.prototype.update = function(a) {
    var b = a.geometry;
    null  === b.boundingBox && b.computeBoundingBox();
    var c = b.boundingBox.min
      , b = b.boundingBox.max
      , e = this.vertices;
    e[0].set(b.x, b.y, b.z);
    e[1].set(c.x, b.y, b.z);
    e[2].set(c.x, c.y, b.z);
    e[3].set(b.x, c.y, b.z);
    e[4].set(b.x, b.y, c.z);
    e[5].set(c.x, b.y, c.z);
    e[6].set(c.x, c.y, c.z);
    e[7].set(b.x, c.y, c.z);
    this.geometry.computeBoundingSphere();
    this.geometry.verticesNeedUpdate = !0;
    this.matrixAutoUpdate = !1;
    this.matrixWorld = a.matrixWorld
}
;
THREE.BoundingBoxHelper = function(a, b) {
    var c = void 0 !== b ? b : 8947848;
    this.object = a;
    this.box = new THREE.Box3;
    THREE.Mesh.call(this, new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({
        color: c,
        wireframe: !0
    }))
}
;
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.BoundingBoxHelper.prototype.update = function() {
    this.box.setFromObject(this.object);
    this.box.size(this.scale);
    this.box.center(this.position)
}
;
THREE.CameraHelper = function(a) {
    function b(a, b, d) {
        c(a, d);
        c(b, d)
    }
    function c(a, b) {
        e.vertices.push(new THREE.Vector3);
        e.colors.push(new THREE.Color(b));
        void 0 === g[a] && (g[a] = []);
        g[a].push(e.vertices.length - 1)
    }
    var e = new THREE.Geometry
      , d = new THREE.LineBasicMaterial({
        color: 16777215,
        vertexColors: THREE.FaceColors
    })
      , g = {};
    b("n1", "n2", 16755200);
    b("n2", "n4", 16755200);
    b("n4", "n3", 16755200);
    b("n3", "n1", 16755200);
    b("f1", "f2", 16755200);
    b("f2", "f4", 16755200);
    b("f4", "f3", 16755200);
    b("f3", "f1", 16755200);
    b("n1", "f1", 16755200);
    b("n2", "f2", 16755200);
    b("n3", "f3", 16755200);
    b("n4", "f4", 16755200);
    b("p", "n1", 16711680);
    b("p", "n2", 16711680);
    b("p", "n3", 16711680);
    b("p", "n4", 16711680);
    b("u1", "u2", 43775);
    b("u2", "u3", 43775);
    b("u3", "u1", 43775);
    b("c", "t", 16777215);
    b("p", "c", 3355443);
    b("cn1", "cn2", 3355443);
    b("cn3", "cn4", 3355443);
    b("cf1", "cf2", 3355443);
    b("cf3", "cf4", 3355443);
    THREE.Line.call(this, e, d, THREE.LinePieces);
    this.camera = a;
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.pointMap = g;
    this.update()
}
;
THREE.CameraHelper.prototype = Object.create(THREE.Line.prototype);
THREE.CameraHelper.prototype.update = function() {
    var a = new THREE.Vector3
      , b = new THREE.Camera
      , c = new THREE.Projector;
    return function() {
        function e(e, f, k, h) {
            a.set(f, k, h);
            c.unprojectVector(a, b);
            e = d.pointMap[e];
            if (void 0 !== e)
                for (f = 0,
                k = e.length; f < k; f++)
                    d.geometry.vertices[e[f]].copy(a)
        }
        var d = this;
        b.projectionMatrix.copy(this.camera.projectionMatrix);
        e("c", 0, 0, -1);
        e("t", 0, 0, 1);
        e("n1", -1, -1, -1);
        e("n2", 1, -1, -1);
        e("n3", -1, 1, -1);
        e("n4", 1, 1, -1);
        e("f1", -1, -1, 1);
        e("f2", 1, -1, 1);
        e("f3", -1, 1, 1);
        e("f4", 1, 1, 1);
        e("u1", .7, 
        1.1, -1);
        e("u2", -.7, 1.1, -1);
        e("u3", 0, 2, -1);
        e("cf1", -1, 0, 1);
        e("cf2", 1, 0, 1);
        e("cf3", 0, -1, 1);
        e("cf4", 0, 1, 1);
        e("cn1", -1, 0, -1);
        e("cn2", 1, 0, -1);
        e("cn3", 0, -1, -1);
        e("cn4", 0, 1, -1);
        this.geometry.verticesNeedUpdate = !0
    }
}
();
THREE.DirectionalLightHelper = function(a, b) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    b = b || 1;
    var c = new THREE.PlaneGeometry(b,b)
      , e = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.lightPlane = new THREE.Mesh(c,e);
    this.add(this.lightPlane);
    c = new THREE.Geometry;
    c.vertices.push(new THREE.Vector3);
    c.vertices.push(new THREE.Vector3);
    e = new THREE.LineBasicMaterial({
        fog: !1
    });
    e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    this.targetLine = new THREE.Line(c,e);
    this.add(this.targetLine);
    this.update()
}
;
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose();
    this.lightPlane.material.dispose();
    this.targetLine.geometry.dispose();
    this.targetLine.material.dispose()
}
;
THREE.DirectionalLightHelper.prototype.update = function() {
    var a = new THREE.Vector3
      , b = new THREE.Vector3
      , c = new THREE.Vector3;
    return function() {
        a.setFromMatrixPosition(this.light.matrixWorld);
        b.setFromMatrixPosition(this.light.target.matrixWorld);
        c.subVectors(b, a);
        this.lightPlane.lookAt(c);
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
        this.targetLine.geometry.vertices[1].copy(c);
        this.targetLine.geometry.verticesNeedUpdate = !0;
        this.targetLine.material.color.copy(this.lightPlane.material.color)
    }
}
();
THREE.EdgesHelper = function(a, b) {
    var c = void 0 !== b ? b : 16777215
      , e = [0, 0]
      , d = {}
      , g = function(a, f) {
        return a - f
    }
      , f = ["a", "b", "c"]
      , k = new THREE.BufferGeometry
      , h = a.geometry.clone();
    h.mergeVertices();
    h.computeFaceNormals();
    for (var l = h.vertices, h = h.faces, m = 0, n = 0, p = h.length; n < p; n++)
        for (var t = h[n], v = 0; 3 > v; v++) {
            e[0] = t[f[v]];
            e[1] = t[f[(v + 1) % 3]];
            e.sort(g);
            var r = e.toString();
            void 0 === d[r] ? (d[r] = {
                vert1: e[0],
                vert2: e[1],
                face1: n,
                face2: void 0
            },
            m++) : d[r].face2 = n
        }
    k.addAttribute("position", Float32Array, 2 * m, 3);
    e = k.attributes.position.array;
    g = 0;
    for (r in d)
        if (f = d[r],
        void 0 === f.face2 || .9999 > h[f.face1].normal.dot(h[f.face2].normal))
            m = l[f.vert1],
            e[g++] = m.x,
            e[g++] = m.y,
            e[g++] = m.z,
            m = l[f.vert2],
            e[g++] = m.x,
            e[g++] = m.y,
            e[g++] = m.z;
    THREE.Line.call(this, k, new THREE.LineBasicMaterial({
        color: c
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.matrixWorld = a.matrixWorld
}
;
THREE.EdgesHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper = function(a, b, c, e) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    a = void 0 !== c ? c : 16776960;
    e = void 0 !== e ? e : 1;
    b = new THREE.Geometry;
    c = 0;
    for (var d = this.object.geometry.faces.length; c < d; c++)
        b.vertices.push(new THREE.Vector3),
        b.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, b, new THREE.LineBasicMaterial({
        color: a,
        linewidth: e
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.normalMatrix = new THREE.Matrix3;
    this.update()
}
;
THREE.FaceNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.FaceNormalsHelper.prototype.update = function(a) {
    var b = new THREE.Vector3;
    return function(a) {
        this.object.updateMatrixWorld(!0);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        a = this.geometry.vertices;
        for (var e = this.object.geometry.faces, d = this.object.matrixWorld, g = 0, f = e.length; g < f; g++) {
            var k = e[g];
            b.copy(k.normal).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
            var h = 2 * g;
            a[h].copy(k.centroid).applyMatrix4(d);
            a[h + 1].addVectors(a[h], b)
        }
        this.geometry.verticesNeedUpdate = 
        !0;
        return this
    }
}
();
THREE.GridHelper = function(a, b) {
    var c = new THREE.Geometry
      , e = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    this.color1 = new THREE.Color(4473924);
    this.color2 = new THREE.Color(8947848);
    for (var d = -a; d <= a; d += b) {
        c.vertices.push(new THREE.Vector3(-a,0,d), new THREE.Vector3(a,0,d), new THREE.Vector3(d,0,-a), new THREE.Vector3(d,0,a));
        var g = 0 === d ? this.color1 : this.color2;
        c.colors.push(g, g, g, g)
    }
    THREE.Line.call(this, c, e, THREE.LinePieces)
}
;
THREE.GridHelper.prototype = Object.create(THREE.Line.prototype);
THREE.GridHelper.prototype.setColors = function(a, b) {
    this.color1.set(a);
    this.color2.set(b);
    this.geometry.colorsNeedUpdate = !0
}
;
THREE.HemisphereLightHelper = function(a, b, c, e) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    this.colors = [new THREE.Color, new THREE.Color];
    a = new THREE.SphereGeometry(b,4,2);
    a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
    for (b = 0; 8 > b; b++)
        a.faces[b].color = this.colors[4 > b ? 0 : 1];
    b = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: !0
    });
    this.lightSphere = new THREE.Mesh(a,b);
    this.add(this.lightSphere);
    this.update()
}
;
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.HemisphereLightHelper.prototype.dispose = function() {
    this.lightSphere.geometry.dispose();
    this.lightSphere.material.dispose()
}
;
THREE.HemisphereLightHelper.prototype.update = function() {
    var a = new THREE.Vector3;
    return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity);
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity);
        this.lightSphere.lookAt(a.setFromMatrixPosition(this.light.matrixWorld).negate());
        this.lightSphere.geometry.colorsNeedUpdate = !0
    }
}
();
THREE.PointLightHelper = function(a, b) {
    this.light = a;
    this.light.updateMatrixWorld();
    var c = new THREE.SphereGeometry(b,4,2)
      , e = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    e.color.copy(this.light.color).multiplyScalar(this.light.intensity);
    THREE.Mesh.call(this, c, e);
    this.matrixWorld = this.light.matrixWorld;
    this.matrixAutoUpdate = !1
}
;
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype);
THREE.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose();
    this.material.dispose()
}
;
THREE.PointLightHelper.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
}
;
THREE.SpotLightHelper = function(a) {
    THREE.Object3D.call(this);
    this.light = a;
    this.light.updateMatrixWorld();
    this.matrixWorld = a.matrixWorld;
    this.matrixAutoUpdate = !1;
    a = new THREE.CylinderGeometry(0,1,1,8,1,!0);
    a.applyMatrix((new THREE.Matrix4).makeTranslation(0, -.5, 0));
    a.applyMatrix((new THREE.Matrix4).makeRotationX(-Math.PI / 2));
    var b = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    this.cone = new THREE.Mesh(a,b);
    this.add(this.cone);
    this.update()
}
;
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype);
THREE.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose();
    this.cone.material.dispose()
}
;
THREE.SpotLightHelper.prototype.update = function() {
    var a = new THREE.Vector3
      , b = new THREE.Vector3;
    return function() {
        var c = this.light.distance ? this.light.distance : 1E4
          , e = c * Math.tan(this.light.angle);
        this.cone.scale.set(e, e, c);
        a.setFromMatrixPosition(this.light.matrixWorld);
        b.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(b.sub(a));
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    }
}
();
THREE.VertexNormalsHelper = function(a, b, c, e) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    b = void 0 !== c ? c : 16711680;
    e = void 0 !== e ? e : 1;
    c = new THREE.Geometry;
    a = a.geometry.faces;
    for (var d = 0, g = a.length; d < g; d++)
        for (var f = 0, k = a[d].vertexNormals.length; f < k; f++)
            c.vertices.push(new THREE.Vector3),
            c.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: e
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.normalMatrix = new THREE.Matrix3;
    this.update()
}
;
THREE.VertexNormalsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexNormalsHelper.prototype.update = function(a) {
    var b = new THREE.Vector3;
    return function(a) {
        a = ["a", "b", "c", "d"];
        this.object.updateMatrixWorld(!0);
        this.normalMatrix.getNormalMatrix(this.object.matrixWorld);
        for (var e = this.geometry.vertices, d = this.object.geometry.vertices, g = this.object.geometry.faces, f = this.object.matrixWorld, k = 0, h = 0, l = g.length; h < l; h++)
            for (var m = g[h], n = 0, p = m.vertexNormals.length; n < p; n++) {
                var t = m.vertexNormals[n];
                e[k].copy(d[m[a[n]]]).applyMatrix4(f);
                b.copy(t).applyMatrix3(this.normalMatrix).normalize().multiplyScalar(this.size);
                b.add(e[k]);
                k += 1;
                e[k].copy(b);
                k += 1
            }
        this.geometry.verticesNeedUpdate = !0;
        return this
    }
}
();
THREE.VertexTangentsHelper = function(a, b, c, e) {
    this.object = a;
    this.size = void 0 !== b ? b : 1;
    b = void 0 !== c ? c : 255;
    e = void 0 !== e ? e : 1;
    c = new THREE.Geometry;
    a = a.geometry.faces;
    for (var d = 0, g = a.length; d < g; d++)
        for (var f = 0, k = a[d].vertexTangents.length; f < k; f++)
            c.vertices.push(new THREE.Vector3),
            c.vertices.push(new THREE.Vector3);
    THREE.Line.call(this, c, new THREE.LineBasicMaterial({
        color: b,
        linewidth: e
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.update()
}
;
THREE.VertexTangentsHelper.prototype = Object.create(THREE.Line.prototype);
THREE.VertexTangentsHelper.prototype.update = function(a) {
    var b = new THREE.Vector3;
    return function(a) {
        a = ["a", "b", "c", "d"];
        this.object.updateMatrixWorld(!0);
        for (var e = this.geometry.vertices, d = this.object.geometry.vertices, g = this.object.geometry.faces, f = this.object.matrixWorld, k = 0, h = 0, l = g.length; h < l; h++)
            for (var m = g[h], n = 0, p = m.vertexTangents.length; n < p; n++) {
                var t = m.vertexTangents[n];
                e[k].copy(d[m[a[n]]]).applyMatrix4(f);
                b.copy(t).transformDirection(f).multiplyScalar(this.size);
                b.add(e[k]);
                k += 1;
                e[k].copy(b);
                k += 1
            }
        this.geometry.verticesNeedUpdate = !0;
        return this
    }
}
();
THREE.WireframeHelper = function(a, b) {
    var c = void 0 !== b ? b : 16777215
      , e = [0, 0]
      , d = {}
      , g = function(a, f) {
        return a - f
    }
      , f = ["a", "b", "c"]
      , k = new THREE.BufferGeometry;
    if (a.geometry instanceof THREE.Geometry) {
        for (var h = a.geometry.vertices, l = a.geometry.faces, m = 0, n = new Uint32Array(6 * l.length), p = 0, t = l.length; p < t; p++)
            for (var v = l[p], r = 0; 3 > r; r++) {
                e[0] = v[f[r]];
                e[1] = v[f[(r + 1) % 3]];
                e.sort(g);
                var u = e.toString();
                void 0 === d[u] && (n[2 * m] = e[0],
                n[2 * m + 1] = e[1],
                d[u] = !0,
                m++)
            }
        k.addAttribute("position", Float32Array, 2 * m, 3);
        e = k.attributes.position.array;
        p = 0;
        for (t = m; p < t; p++)
            for (r = 0; 2 > r; r++)
                m = h[n[2 * p + r]],
                f = 6 * p + 3 * r,
                e[f + 0] = m.x,
                e[f + 1] = m.y,
                e[f + 2] = m.z
    } else if (a.geometry instanceof THREE.BufferGeometry && void 0 !== a.geometry.attributes.index) {
        for (var h = a.geometry.attributes.position.array, t = a.geometry.attributes.index.array, l = a.geometry.offsets, m = 0, n = new Uint32Array(2 * t.length), v = 0, w = l.length; v < w; ++v)
            for (var r = l[v].start, u = l[v].count, f = l[v].index, p = r, x = r + u; p < x; p += 3)
                for (r = 0; 3 > r; r++)
                    e[0] = f + t[p + r],
                    e[1] = f + t[p + (r + 1) % 3],
                    e.sort(g),
                    u = e.toString(),
                    void 0 === d[u] && (n[2 * 
                    m] = e[0],
                    n[2 * m + 1] = e[1],
                    d[u] = !0,
                    m++);
        k.addAttribute("position", Float32Array, 2 * m, 3);
        e = k.attributes.position.array;
        p = 0;
        for (t = m; p < t; p++)
            for (r = 0; 2 > r; r++)
                f = 6 * p + 3 * r,
                m = 3 * n[2 * p + r],
                e[f + 0] = h[m],
                e[f + 1] = h[m + 1],
                e[f + 2] = h[m + 2]
    } else if (a.geometry instanceof THREE.BufferGeometry)
        for (h = a.geometry.attributes.position.array,
        m = h.length / 3,
        n = m / 3,
        k.addAttribute("position", Float32Array, 2 * m, 3),
        e = k.attributes.position.array,
        p = 0,
        t = n; p < t; p++)
            for (r = 0; 3 > r; r++)
                f = 18 * p + 6 * r,
                n = 9 * p + 3 * r,
                e[f + 0] = h[n],
                e[f + 1] = h[n + 1],
                e[f + 2] = h[n + 2],
                m = 9 * p + (r + 
                1) % 3 * 3,
                e[f + 3] = h[m],
                e[f + 4] = h[m + 1],
                e[f + 5] = h[m + 2];
    THREE.Line.call(this, k, new THREE.LineBasicMaterial({
        color: c
    }), THREE.LinePieces);
    this.matrixAutoUpdate = !1;
    this.matrixWorld = a.matrixWorld
}
;
THREE.WireframeHelper.prototype = Object.create(THREE.Line.prototype);
THREE.ShadowMapPlugin = function() {
    var a, b, c, e, d, g, f = new THREE.Frustum, k = new THREE.Matrix4, h = new THREE.Vector3, l = new THREE.Vector3, m = new THREE.Vector3;
    this.init = function(f) {
        a = f.context;
        b = f;
        f = THREE.ShaderLib.depthRGBA;
        var k = THREE.UniformsUtils.clone(f.uniforms);
        c = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k
        });
        e = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            morphTargets: !0
        });
        d = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            skinning: !0
        });
        g = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            morphTargets: !0,
            skinning: !0
        });
        c._shadowPass = !0;
        e._shadowPass = !0;
        d._shadowPass = !0;
        g._shadowPass = !0
    }
    ;
    this.render = function(a, f) {
        b.shadowMapEnabled && b.shadowMapAutoUpdate && this.update(a, f)
    }
    ;
    this.update = function(n, p) {
        var t, v, r, u, w, x, A, y, z, E = [];
        u = 0;
        a.clearColor(1, 1, 1, 1);
        a.disable(a.BLEND);
        a.enable(a.CULL_FACE);
        a.frontFace(a.CCW);
        b.shadowMapCullFace === THREE.CullFaceFront ? 
        a.cullFace(a.FRONT) : a.cullFace(a.BACK);
        b.setDepthTest(!0);
        t = 0;
        for (v = n.__lights.length; t < v; t++)
            if (r = n.__lights[t],
            r.castShadow)
                if (r instanceof THREE.DirectionalLight && r.shadowCascade)
                    for (w = 0; w < r.shadowCascadeCount; w++) {
                        var C;
                        if (r.shadowCascadeArray[w])
                            C = r.shadowCascadeArray[w];
                        else {
                            z = r;
                            A = w;
                            C = new THREE.DirectionalLight;
                            C.isVirtual = !0;
                            C.onlyShadow = !0;
                            C.castShadow = !0;
                            C.shadowCameraNear = z.shadowCameraNear;
                            C.shadowCameraFar = z.shadowCameraFar;
                            C.shadowCameraLeft = z.shadowCameraLeft;
                            C.shadowCameraRight = z.shadowCameraRight;
                            C.shadowCameraBottom = z.shadowCameraBottom;
                            C.shadowCameraTop = z.shadowCameraTop;
                            C.shadowCameraVisible = z.shadowCameraVisible;
                            C.shadowDarkness = z.shadowDarkness;
                            C.shadowBias = z.shadowCascadeBias[A];
                            C.shadowMapWidth = z.shadowCascadeWidth[A];
                            C.shadowMapHeight = z.shadowCascadeHeight[A];
                            C.pointsWorld = [];
                            C.pointsFrustum = [];
                            y = C.pointsWorld;
                            x = C.pointsFrustum;
                            for (var B = 0; 8 > B; B++)
                                y[B] = new THREE.Vector3,
                                x[B] = new THREE.Vector3;
                            y = z.shadowCascadeNearZ[A];
                            z = z.shadowCascadeFarZ[A];
                            x[0].set(-1, -1, y);
                            x[1].set(1, -1, y);
                            x[2].set(-1, 
                            1, y);
                            x[3].set(1, 1, y);
                            x[4].set(-1, -1, z);
                            x[5].set(1, -1, z);
                            x[6].set(-1, 1, z);
                            x[7].set(1, 1, z);
                            C.originalCamera = p;
                            x = new THREE.Gyroscope;
                            x.position = r.shadowCascadeOffset;
                            x.add(C);
                            x.add(C.target);
                            p.add(x);
                            r.shadowCascadeArray[w] = C;
                            console.log("Created virtualLight", C)
                        }
                        A = r;
                        y = w;
                        z = A.shadowCascadeArray[y];
                        z.position.copy(A.position);
                        z.target.position.copy(A.target.position);
                        z.lookAt(z.target);
                        z.shadowCameraVisible = A.shadowCameraVisible;
                        z.shadowDarkness = A.shadowDarkness;
                        z.shadowBias = A.shadowCascadeBias[y];
                        x = A.shadowCascadeNearZ[y];
                        A = A.shadowCascadeFarZ[y];
                        z = z.pointsFrustum;
                        z[0].z = x;
                        z[1].z = x;
                        z[2].z = x;
                        z[3].z = x;
                        z[4].z = A;
                        z[5].z = A;
                        z[6].z = A;
                        z[7].z = A;
                        E[u] = C;
                        u++
                    }
                else
                    E[u] = r,
                    u++;
        t = 0;
        for (v = E.length; t < v; t++) {
            r = E[t];
            r.shadowMap || (w = THREE.LinearFilter,
            b.shadowMapType === THREE.PCFSoftShadowMap && (w = THREE.NearestFilter),
            r.shadowMap = new THREE.WebGLRenderTarget(r.shadowMapWidth,r.shadowMapHeight,{
                minFilter: w,
                magFilter: w,
                format: THREE.RGBAFormat
            }),
            r.shadowMapSize = new THREE.Vector2(r.shadowMapWidth,r.shadowMapHeight),
            r.shadowMatrix = new THREE.Matrix4);
            if (!r.shadowCamera) {
                if (r instanceof THREE.SpotLight)
                    r.shadowCamera = new THREE.PerspectiveCamera(r.shadowCameraFov,r.shadowMapWidth / r.shadowMapHeight,r.shadowCameraNear,r.shadowCameraFar);
                else if (r instanceof THREE.DirectionalLight)
                    r.shadowCamera = new THREE.OrthographicCamera(r.shadowCameraLeft,r.shadowCameraRight,r.shadowCameraTop,r.shadowCameraBottom,r.shadowCameraNear,r.shadowCameraFar);
                else {
                    console.error("Unsupported light type for shadow");
                    continue
                }
                n.add(r.shadowCamera);
                !0 === n.autoUpdate && n.updateMatrixWorld()
            }
            r.shadowCameraVisible && 
            !r.cameraHelper && (r.cameraHelper = new THREE.CameraHelper(r.shadowCamera),
            r.shadowCamera.add(r.cameraHelper));
            if (r.isVirtual && C.originalCamera == p) {
                w = p;
                u = r.shadowCamera;
                x = r.pointsFrustum;
                z = r.pointsWorld;
                h.set(Infinity, Infinity, Infinity);
                l.set(-Infinity, -Infinity, -Infinity);
                for (A = 0; 8 > A; A++)
                    y = z[A],
                    y.copy(x[A]),
                    THREE.ShadowMapPlugin.__projector.unprojectVector(y, w),
                    y.applyMatrix4(u.matrixWorldInverse),
                    y.x < h.x && (h.x = y.x),
                    y.x > l.x && (l.x = y.x),
                    y.y < h.y && (h.y = y.y),
                    y.y > l.y && (l.y = y.y),
                    y.z < h.z && (h.z = y.z),
                    y.z > l.z && 
                    (l.z = y.z);
                u.left = h.x;
                u.right = l.x;
                u.top = l.y;
                u.bottom = h.y;
                u.updateProjectionMatrix()
            }
            u = r.shadowMap;
            x = r.shadowMatrix;
            w = r.shadowCamera;
            w.position.setFromMatrixPosition(r.matrixWorld);
            m.setFromMatrixPosition(r.target.matrixWorld);
            w.lookAt(m);
            w.updateMatrixWorld();
            w.matrixWorldInverse.getInverse(w.matrixWorld);
            r.cameraHelper && (r.cameraHelper.visible = r.shadowCameraVisible);
            r.shadowCameraVisible && r.cameraHelper.update();
            x.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1);
            x.multiply(w.projectionMatrix);
            x.multiply(w.matrixWorldInverse);
            k.multiplyMatrices(w.projectionMatrix, w.matrixWorldInverse);
            f.setFromMatrix(k);
            b.setRenderTarget(u);
            b.clear();
            z = n.__webglObjects;
            r = 0;
            for (u = z.length; r < u; r++)
                A = z[r],
                x = A.object,
                A.render = !1,
                !x.visible || !x.castShadow || (x instanceof THREE.Mesh || x instanceof THREE.ParticleSystem) && x.frustumCulled && !f.intersectsObject(x) || (x._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, x.matrixWorld),
                A.render = !0);
            r = 0;
            for (u = z.length; r < u; r++)
                A = z[r],
                A.render && (x = A.object,
                A = A.buffer,
                B = x.material instanceof THREE.MeshFaceMaterial ? 
                x.material.materials[0] : x.material,
                y = void 0 !== x.geometry.morphTargets && 0 < x.geometry.morphTargets.length && B.morphTargets,
                B = x instanceof THREE.SkinnedMesh && B.skinning,
                y = x.customDepthMaterial ? x.customDepthMaterial : B ? y ? g : d : y ? e : c,
                A instanceof THREE.BufferGeometry ? b.renderBufferDirect(w, n.__lights, null , y, A, x) : b.renderBuffer(w, n.__lights, null , y, A, x));
            z = n.__webglObjectsImmediate;
            r = 0;
            for (u = z.length; r < u; r++)
                A = z[r],
                x = A.object,
                x.visible && x.castShadow && (x._modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, 
                x.matrixWorld),
                b.renderImmediateObject(w, n.__lights, null , c, x))
        }
        t = b.getClearColor();
        v = b.getClearAlpha();
        a.clearColor(t.r, t.g, t.b, v);
        a.enable(a.BLEND);
        b.shadowMapCullFace === THREE.CullFaceFront && a.cullFace(a.BACK)
    }
}
;
THREE.ShadowMapPlugin.__projector = new THREE.Projector;
THREE.DepthPassPlugin = function() {
    this.enabled = !1;
    this.renderTarget = null ;
    var a, b, c, e, d, g, f = new THREE.Frustum, k = new THREE.Matrix4;
    this.init = function(f) {
        a = f.context;
        b = f;
        f = THREE.ShaderLib.depthRGBA;
        var k = THREE.UniformsUtils.clone(f.uniforms);
        c = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k
        });
        e = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            morphTargets: !0
        });
        d = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            skinning: !0
        });
        g = new THREE.ShaderMaterial({
            fragmentShader: f.fragmentShader,
            vertexShader: f.vertexShader,
            uniforms: k,
            morphTargets: !0,
            skinning: !0
        });
        c._shadowPass = !0;
        e._shadowPass = !0;
        d._shadowPass = !0;
        g._shadowPass = !0
    }
    ;
    this.render = function(a, f) {
        this.enabled && this.update(a, f)
    }
    ;
    this.update = function(h, l) {
        var m, n, p, t, v, r;
        a.clearColor(1, 1, 1, 1);
        a.disable(a.BLEND);
        b.setDepthTest(!0);
        !0 === h.autoUpdate && h.updateMatrixWorld();
        l.matrixWorldInverse.getInverse(l.matrixWorld);
        k.multiplyMatrices(l.projectionMatrix, 
        l.matrixWorldInverse);
        f.setFromMatrix(k);
        b.setRenderTarget(this.renderTarget);
        b.clear();
        r = h.__webglObjects;
        m = 0;
        for (n = r.length; m < n; m++)
            p = r[m],
            v = p.object,
            p.render = !1,
            !v.visible || (v instanceof THREE.Mesh || v instanceof THREE.ParticleSystem) && v.frustumCulled && !f.intersectsObject(v) || (v._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, v.matrixWorld),
            p.render = !0);
        var u;
        m = 0;
        for (n = r.length; m < n; m++)
            p = r[m],
            p.render && (v = p.object,
            p = p.buffer,
            v instanceof THREE.ParticleSystem && !v.customDepthMaterial || ((u = 
            v.material instanceof THREE.MeshFaceMaterial ? v.material.materials[0] : v.material) && b.setMaterialFaces(v.material),
            t = 0 < v.geometry.morphTargets.length && u.morphTargets,
            u = v instanceof THREE.SkinnedMesh && u.skinning,
            t = v.customDepthMaterial ? v.customDepthMaterial : u ? t ? g : d : t ? e : c,
            p instanceof THREE.BufferGeometry ? b.renderBufferDirect(l, h.__lights, null , t, p, v) : b.renderBuffer(l, h.__lights, null , t, p, v)));
        r = h.__webglObjectsImmediate;
        m = 0;
        for (n = r.length; m < n; m++)
            p = r[m],
            v = p.object,
            v.visible && (v._modelViewMatrix.multiplyMatrices(l.matrixWorldInverse, 
            v.matrixWorld),
            b.renderImmediateObject(l, h.__lights, null , c, v));
        m = b.getClearColor();
        n = b.getClearAlpha();
        a.clearColor(m.r, m.g, m.b, n);
        a.enable(a.BLEND)
    }
}
;
/*
 zlib.js 2012 - imaya [ https://github.com/imaya/zlib.js ] The MIT License */
(function() {
    function a(a) {
        throw a;
    }
    function b(a, f) {
        var b = a.split(".")
          , d = v;
        b[0] in d || !d.execScript || d.execScript("var " + b[0]);
        for (var c; b.length && (c = b.shift()); )
            b.length || void 0 === f ? d = d[c] ? d[c] : d[c] = {} : d[c] = f
    }
    function c(a) {
        var f = a.length, b = 0, d = Number.POSITIVE_INFINITY, c, k, e, h, g, l, m, n, p;
        for (n = 0; n < f; ++n)
            a[n] > b && (b = a[n]),
            a[n] < d && (d = a[n]);
        c = 1 << b;
        k = new (r ? Uint32Array : Array)(c);
        e = 1;
        h = 0;
        for (g = 2; e <= b; ) {
            for (n = 0; n < f; ++n)
                if (a[n] === e) {
                    l = 0;
                    m = h;
                    for (p = 0; p < e; ++p)
                        l = l << 1 | m & 1,
                        m >>= 1;
                    for (p = l; p < c; p += g)
                        k[p] = e << 16 | n;
                    ++h
                }
            ++e;
            h <<= 1;
            g <<= 1
        }
        return [k, b, d]
    }
    function e(f, b) {
        this.l = [];
        this.m = 32768;
        this.d = this.f = this.c = this.t = 0;
        this.input = r ? new Uint8Array(f) : f;
        this.u = !1;
        this.n = y;
        this.K = !1;
        if (b || !(b = {}))
            b.index && (this.c = b.index),
            b.bufferSize && (this.m = b.bufferSize),
            b.bufferType && (this.n = b.bufferType),
            b.resize && (this.K = b.resize);
        switch (this.n) {
        case A:
            this.a = 32768;
            this.b = new (r ? Uint8Array : Array)(32768 + this.m + 258);
            break;
        case y:
            this.a = 0;
            this.b = new (r ? Uint8Array : Array)(this.m);
            this.e = this.W;
            this.B = this.R;
            this.q = this.V;
            break;
        default:
            a(Error("invalid inflate mode"))
        }
    }
    function d(f, b) {
        for (var d = f.f, c = f.d, k = f.input, e = f.c, h; c < b; )
            h = k[e++],
            void 0 === h && a(Error("input buffer is broken")),
            d |= h << c,
            c += 8;
        f.f = d >>> b;
        f.d = c - b;
        f.c = e;
        return d & (1 << b) - 1
    }
    function g(a, f) {
        for (var b = a.f, d = a.d, c = a.input, k = a.c, e = f[0], h = f[1], g; d < h; ) {
            g = c[k++];
            if (void 0 === g)
                break;
            b |= g << d;
            d += 8
        }
        c = e[b & (1 << h) - 1];
        e = c >>> 16;
        a.f = b >> e;
        a.d = d - e;
        a.c = k;
        return c & 65535
    }
    function f(a) {
        function f(a, b, c) {
            var k, e, h, l;
            for (l = 0; l < a; )
                switch (k = g(this, b),
                k) {
                case 16:
                    for (h = 3 + d(this, 2); h--; )
                        c[l++] = e;
                    break;
                case 17:
                    for (h = 3 + d(this, 3); h--; )
                        c[l++] = 
                        0;
                    e = 0;
                    break;
                case 18:
                    for (h = 11 + d(this, 7); h--; )
                        c[l++] = 0;
                    e = 0;
                    break;
                default:
                    e = c[l++] = k
                }
            return c
        }
        var b = d(a, 5) + 257, k = d(a, 5) + 1, e = d(a, 4) + 4, h = new (r ? Uint8Array : Array)(z.length), l;
        for (l = 0; l < e; ++l)
            h[z[l]] = d(a, 3);
        e = c(h);
        h = new (r ? Uint8Array : Array)(b);
        l = new (r ? Uint8Array : Array)(k);
        a.q(c(f.call(a, b, e, h)), c(f.call(a, k, e, l)))
    }
    function k(a) {
        a = a || {};
        this.files = [];
        this.v = a.comment
    }
    function h(a, f) {
        f = f || {};
        this.input = r && a instanceof Array ? new Uint8Array(a) : a;
        this.c = 0;
        this.ba = f.verify || !1;
        this.j = f.password
    }
    function l(a, 
    f) {
        this.input = a;
        this.offset = f
    }
    function m(a, f) {
        this.input = a;
        this.offset = f
    }
    function n(f) {
        var b = [], d = {}, c, k, e, h;
        if (!f.i) {
            if (void 0 === f.o) {
                c = f.input;
                if (!f.D)
                    a: {
                        k = f.input;
                        for (e = k.length - 12; 0 < e; --e)
                            if (k[e] === Q[0] && k[e + 1] === Q[1] && k[e + 2] === Q[2] && k[e + 3] === Q[3]) {
                                f.D = e;
                                break a
                            }
                        a(Error("End of Central Directory Record not found"))
                    }
                k = f.D;
                c[k++] === Q[0] && c[k++] === Q[1] && c[k++] === Q[2] && c[k++] === Q[3] || a(Error("invalid signature"));
                f.ha = c[k++] | c[k++] << 8;
                f.ja = c[k++] | c[k++] << 8;
                f.ka = c[k++] | c[k++] << 8;
                f.aa = c[k++] | c[k++] << 
                8;
                f.Q = (c[k++] | c[k++] << 8 | c[k++] << 16 | c[k++] << 24) >>> 0;
                f.o = (c[k++] | c[k++] << 8 | c[k++] << 16 | c[k++] << 24) >>> 0;
                f.w = c[k++] | c[k++] << 8;
                f.v = r ? c.subarray(k, k + f.w) : c.slice(k, k + f.w)
            }
            c = f.o;
            e = 0;
            for (h = f.aa; e < h; ++e)
                k = new l(f.input,c),
                k.parse(),
                c += k.length,
                b[e] = k,
                d[k.filename] = e;
            f.Q < c - f.o && a(Error("invalid file header size"));
            f.i = b;
            f.G = d
        }
    }
    function p(a, f, b) {
        b ^= a.s(f);
        a.k(f, b);
        return b
    }
    var t, v = this, r = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
    new (r ? Uint8Array : Array)(256);
    for (t = 0; 256 > t; ++t)
        for (var u = t, w = 7, u = u >>> 1; u; u >>>= 1)
            --w;
    t = [0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 
    3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 
    314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 
    3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 
    1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 
    1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    var x = r ? new Uint32Array(t) : t;
    t = [];
    for (u = 0; 288 > u; u++)
        switch (!0) {
        case 143 >= u:
            t.push([u + 48, 8]);
            break;
        case 255 >= u:
            t.push([u - 144 + 400, 9]);
            break;
        case 279 >= u:
            t.push([u - 256 + 0, 7]);
            break;
        case 287 >= u:
            t.push([u - 280 + 192, 8]);
            break;
        default:
            a("invalid literal: " + 
            u)
        }
    t = function() {
        function f(b) {
            switch (!0) {
            case 3 === b:
                return [257, b - 3, 0];
            case 4 === b:
                return [258, b - 4, 0];
            case 5 === b:
                return [259, b - 5, 0];
            case 6 === b:
                return [260, b - 6, 0];
            case 7 === b:
                return [261, b - 7, 0];
            case 8 === b:
                return [262, b - 8, 0];
            case 9 === b:
                return [263, b - 9, 0];
            case 10 === b:
                return [264, b - 10, 0];
            case 12 >= b:
                return [265, b - 11, 1];
            case 14 >= b:
                return [266, b - 13, 1];
            case 16 >= b:
                return [267, b - 15, 1];
            case 18 >= b:
                return [268, b - 17, 1];
            case 22 >= b:
                return [269, b - 19, 2];
            case 26 >= b:
                return [270, b - 23, 2];
            case 30 >= b:
                return [271, b - 27, 2];
            case 34 >= b:
                return [272, 
                b - 31, 2];
            case 42 >= b:
                return [273, b - 35, 3];
            case 50 >= b:
                return [274, b - 43, 3];
            case 58 >= b:
                return [275, b - 51, 3];
            case 66 >= b:
                return [276, b - 59, 3];
            case 82 >= b:
                return [277, b - 67, 4];
            case 98 >= b:
                return [278, b - 83, 4];
            case 114 >= b:
                return [279, b - 99, 4];
            case 130 >= b:
                return [280, b - 115, 4];
            case 162 >= b:
                return [281, b - 131, 5];
            case 194 >= b:
                return [282, b - 163, 5];
            case 226 >= b:
                return [283, b - 195, 5];
            case 257 >= b:
                return [284, b - 227, 5];
            case 258 === b:
                return [285, b - 258, 0];
            default:
                a("invalid length: " + b)
            }
        }
        var b = [], d, c;
        for (d = 3; 258 >= d; d++)
            c = f(d),
            b[d] = c[2] << 24 | c[1] << 
            16 | c[0];
        return b
    }
    ();
    r && new Uint32Array(t);
    var A = 0
      , y = 1;
    e.prototype.r = function() {
        for (; !this.u; ) {
            var b = d(this, 3);
            b & 1 && (this.u = !0);
            b >>>= 1;
            switch (b) {
            case 0:
                var b = this.input
                  , c = this.c
                  , k = this.b
                  , e = this.a
                  , h = void 0
                  , g = void 0
                  , l = void 0
                  , m = k.length
                  , h = void 0;
                this.d = this.f = 0;
                h = b[c++];
                void 0 === h && a(Error("invalid uncompressed block header: LEN (first byte)"));
                g = h;
                h = b[c++];
                void 0 === h && a(Error("invalid uncompressed block header: LEN (second byte)"));
                g |= h << 8;
                h = b[c++];
                void 0 === h && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                l = h;
                h = b[c++];
                void 0 === h && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                l |= h << 8;
                g === ~l && a(Error("invalid uncompressed block header: length verify"));
                c + g > b.length && a(Error("input buffer is broken"));
                switch (this.n) {
                case A:
                    for (; e + g > k.length; ) {
                        h = m - e;
                        g -= h;
                        if (r)
                            k.set(b.subarray(c, c + h), e),
                            e += h,
                            c += h;
                        else
                            for (; h--; )
                                k[e++] = b[c++];
                        this.a = e;
                        k = this.e();
                        e = this.a
                    }
                    break;
                case y:
                    for (; e + g > k.length; )
                        k = this.e({
                            H: 2
                        });
                    break;
                default:
                    a(Error("invalid inflate mode"))
                }
                if (r)
                    k.set(b.subarray(c, c + g), e),
                    e += g,
                    c += g;
                else
                    for (; g--; )
                        k[e++] = b[c++];
                this.c = c;
                this.a = e;
                this.b = k;
                break;
            case 1:
                this.q(F, O);
                break;
            case 2:
                f(this);
                break;
            default:
                a(Error("unknown BTYPE: " + b))
            }
        }
        return this.B()
    }
    ;
    t = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var z = r ? new Uint16Array(t) : t;
    t = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    var E = r ? new Uint16Array(t) : t;
    t = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var C = r ? new Uint8Array(t) : t;
    t = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 
    65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var B = r ? new Uint16Array(t) : t;
    t = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var K = r ? new Uint8Array(t) : t;
    t = new (r ? Uint8Array : Array)(288);
    u = 0;
    for (w = t.length; u < w; ++u)
        t[u] = 143 >= u ? 8 : 255 >= u ? 9 : 279 >= u ? 7 : 8;
    var F = c(t);
    t = new (r ? Uint8Array : Array)(30);
    u = 0;
    for (w = t.length; u < w; ++u)
        t[u] = 5;
    var O = c(t);
    t = e.prototype;
    t.q = function(a, f) {
        var b = this.b
          , c = this.a;
        this.C = a;
        for (var k = b.length - 258, e, h, l; 256 !== (e = g(this, 
        a)); )
            if (256 > e)
                c >= k && (this.a = c,
                b = this.e(),
                c = this.a),
                b[c++] = e;
            else
                for (e -= 257,
                l = E[e],
                0 < C[e] && (l += d(this, C[e])),
                e = g(this, f),
                h = B[e],
                0 < K[e] && (h += d(this, K[e])),
                c >= k && (this.a = c,
                b = this.e(),
                c = this.a); l--; )
                    b[c] = b[c++ - h];
        for (; 8 <= this.d; )
            this.d -= 8,
            this.c--;
        this.a = c
    }
    ;
    t.V = function(a, f) {
        var b = this.b
          , c = this.a;
        this.C = a;
        for (var k = b.length, e, h, l; 256 !== (e = g(this, a)); )
            if (256 > e)
                c >= k && (b = this.e(),
                k = b.length),
                b[c++] = e;
            else
                for (e -= 257,
                l = E[e],
                0 < C[e] && (l += d(this, C[e])),
                e = g(this, f),
                h = B[e],
                0 < K[e] && (h += d(this, K[e])),
                c + l > k && (b = 
                this.e(),
                k = b.length); l--; )
                    b[c] = b[c++ - h];
        for (; 8 <= this.d; )
            this.d -= 8,
            this.c--;
        this.a = c
    }
    ;
    t.e = function() {
        var a = new (r ? Uint8Array : Array)(this.a - 32768), f = this.a - 32768, b, c, d = this.b;
        if (r)
            a.set(d.subarray(32768, a.length));
        else
            for (b = 0,
            c = a.length; b < c; ++b)
                a[b] = d[b + 32768];
        this.l.push(a);
        this.t += a.length;
        if (r)
            d.set(d.subarray(f, f + 32768));
        else
            for (b = 0; 32768 > b; ++b)
                d[b] = d[f + b];
        this.a = 32768;
        return d
    }
    ;
    t.W = function(a) {
        var f, b = this.input.length / this.c + 1 | 0, d, c, k, e = this.input, h = this.b;
        a && ("number" === typeof a.H && (b = a.H),
        "number" === typeof a.P && (b += a.P));
        2 > b ? (d = (e.length - this.c) / this.C[2],
        k = d / 2 * 258 | 0,
        c = k < h.length ? h.length + k : h.length << 1) : c = h.length * b;
        r ? (f = new Uint8Array(c),
        f.set(h)) : f = h;
        return this.b = f
    }
    ;
    t.B = function() {
        var a = 0, f = this.b, b = this.l, d, c = new (r ? Uint8Array : Array)(this.t + (this.a - 32768)), k, e, h, g;
        if (0 === b.length)
            return r ? this.b.subarray(32768, this.a) : this.b.slice(32768, this.a);
        k = 0;
        for (e = b.length; k < e; ++k)
            for (d = b[k],
            h = 0,
            g = d.length; h < g; ++h)
                c[a++] = d[h];
        k = 32768;
        for (e = this.a; k < e; ++k)
            c[a++] = f[k];
        this.l = [];
        return this.buffer = 
        c
    }
    ;
    t.R = function() {
        var a, f = this.a;
        r ? this.K ? (a = new Uint8Array(f),
        a.set(this.b.subarray(0, f))) : a = this.b.subarray(0, f) : (this.b.length > f && (this.b.length = f),
        a = this.b);
        return this.buffer = a
    }
    ;
    k.prototype.L = function(a) {
        this.j = a
    }
    ;
    k.prototype.s = function(a) {
        a = a[2] & 65535 | 2;
        return a * (a ^ 1) >> 8 & 255
    }
    ;
    k.prototype.k = function(a, f) {
        a[0] = (x[(a[0] ^ f) & 255] ^ a[0] >>> 8) >>> 0;
        a[1] = (6681 * (20173 * (a[1] + (a[0] & 255)) >>> 0) >>> 0) + 1 >>> 0;
        a[2] = (x[(a[2] ^ a[1] >>> 24) & 255] ^ a[2] >>> 8) >>> 0
    }
    ;
    k.prototype.T = function(a) {
        var f = [305419896, 591751049, 878082192], 
        b, d;
        r && (f = new Uint32Array(f));
        b = 0;
        for (d = a.length; b < d; ++b)
            this.k(f, a[b] & 255);
        return f
    }
    ;
    var M = [80, 75, 1, 2]
      , G = [80, 75, 3, 4]
      , Q = [80, 75, 5, 6];
    l.prototype.parse = function() {
        var f = this.input
          , b = this.offset;
        f[b++] === M[0] && f[b++] === M[1] && f[b++] === M[2] && f[b++] === M[3] || a(Error("invalid file header signature"));
        this.version = f[b++];
        this.ia = f[b++];
        this.Z = f[b++] | f[b++] << 8;
        this.I = f[b++] | f[b++] << 8;
        this.A = f[b++] | f[b++] << 8;
        this.time = f[b++] | f[b++] << 8;
        this.U = f[b++] | f[b++] << 8;
        this.p = (f[b++] | f[b++] << 8 | f[b++] << 16 | f[b++] << 24) >>> 
        0;
        this.z = (f[b++] | f[b++] << 8 | f[b++] << 16 | f[b++] << 24) >>> 0;
        this.J = (f[b++] | f[b++] << 8 | f[b++] << 16 | f[b++] << 24) >>> 0;
        this.h = f[b++] | f[b++] << 8;
        this.g = f[b++] | f[b++] << 8;
        this.F = f[b++] | f[b++] << 8;
        this.ea = f[b++] | f[b++] << 8;
        this.ga = f[b++] | f[b++] << 8;
        this.fa = f[b++] | f[b++] << 8 | f[b++] << 16 | f[b++] << 24;
        this.$ = (f[b++] | f[b++] << 8 | f[b++] << 16 | f[b++] << 24) >>> 0;
        this.filename = String.fromCharCode.apply(null , r ? f.subarray(b, b += this.h) : f.slice(b, b += this.h));
        this.X = r ? f.subarray(b, b += this.g) : f.slice(b, b += this.g);
        this.v = r ? f.subarray(b, b + this.F) : 
        f.slice(b, b + this.F);
        this.length = b - this.offset
    }
    ;
    m.prototype.parse = function() {
        var f = this.input
          , b = this.offset;
        f[b++] === G[0] && f[b++] === G[1] && f[b++] === G[2] && f[b++] === G[3] || a(Error("invalid local file header signature"));
        this.Z = f[b++] | f[b++] << 8;
        this.I = f[b++] | f[b++] << 8;
        this.A = f[b++] | f[b++] << 8;
        this.time = f[b++] | f[b++] << 8;
        this.U = f[b++] | f[b++] << 8;
        this.p = (f[b++] | f[b++] << 8 | f[b++] << 16 | f[b++] << 24) >>> 0;
        this.z = (f[b++] | f[b++] << 8 | f[b++] << 16 | f[b++] << 24) >>> 0;
        this.J = (f[b++] | f[b++] << 8 | f[b++] << 16 | f[b++] << 24) >>> 0;
        this.h = 
        f[b++] | f[b++] << 8;
        this.g = f[b++] | f[b++] << 8;
        this.filename = String.fromCharCode.apply(null , r ? f.subarray(b, b += this.h) : f.slice(b, b += this.h));
        this.X = r ? f.subarray(b, b += this.g) : f.slice(b, b += this.g);
        this.length = b - this.offset
    }
    ;
    t = h.prototype;
    t.Y = function() {
        var a = [], f, b, d;
        this.i || n(this);
        d = this.i;
        f = 0;
        for (b = d.length; f < b; ++f)
            a[f] = d[f].filename;
        return a
    }
    ;
    t.r = function(f, b) {
        var d;
        this.G || n(this);
        d = this.G[f];
        void 0 === d && a(Error(f + " not found"));
        var c;
        c = b || {};
        var k = this.input, h = this.i, g, l, t, u;
        h || n(this);
        void 0 === h[d] && 
        a(Error("wrong index"));
        h = h[d].$;
        d = new m(this.input,h);
        d.parse();
        h += d.length;
        g = d.z;
        if (0 !== (d.I & 1)) {
            c.password || this.j || a(Error("please set password"));
            c = this.S(c.password || this.j);
            t = h;
            for (u = h + 12; t < u; ++t)
                p(this, c, k[t]);
            h += 12;
            g -= 12;
            t = h;
            for (u = h + g; t < u; ++t)
                k[t] = p(this, c, k[t])
        }
        switch (d.A) {
        case 0:
            l = r ? this.input.subarray(h, h + g) : this.input.slice(h, h + g);
            break;
        case 8:
            l = (new e(this.input,{
                index: h,
                bufferSize: d.J
            })).r();
            break;
        default:
            a(Error("unknown compression type"))
        }
        if (this.ba) {
            k = void 0;
            g = "number" === typeof k ? 
            k : k = 0;
            c = l.length;
            h = -1;
            for (g = c & 7; g--; ++k)
                h = h >>> 8 ^ x[(h ^ l[k]) & 255];
            for (g = c >> 3; g--; k += 8)
                h = h >>> 8 ^ x[(h ^ l[k]) & 255],
                h = h >>> 8 ^ x[(h ^ l[k + 1]) & 255],
                h = h >>> 8 ^ x[(h ^ l[k + 2]) & 255],
                h = h >>> 8 ^ x[(h ^ l[k + 3]) & 255],
                h = h >>> 8 ^ x[(h ^ l[k + 4]) & 255],
                h = h >>> 8 ^ x[(h ^ l[k + 5]) & 255],
                h = h >>> 8 ^ x[(h ^ l[k + 6]) & 255],
                h = h >>> 8 ^ x[(h ^ l[k + 7]) & 255];
            k = (h ^ 4294967295) >>> 0;
            d.p !== k && a(Error("wrong crc: file=0x" + d.p.toString(16) + ", data=0x" + k.toString(16)))
        }
        return l
    }
    ;
    t.L = function(a) {
        this.j = a
    }
    ;
    t.k = k.prototype.k;
    t.S = k.prototype.T;
    t.s = k.prototype.s;
    b("Zlib.Unzip", h);
    b("Zlib.Unzip.prototype.decompress", h.prototype.r);
    b("Zlib.Unzip.prototype.getFilenames", h.prototype.Y);
    b("Zlib.Unzip.prototype.setPassword", h.prototype.L)
}
).call(this);
(function() {
    function a(a) {
        throw a;
    }
    function b(a, f) {
        var b = a.split(".")
          , d = m;
        b[0] in d || !d.execScript || d.execScript("var " + b[0]);
        for (var c; b.length && (c = b.shift()); )
            b.length || void 0 === f ? d = d[c] ? d[c] : d[c] = {} : d[c] = f
    }
    function c(a, f, b) {
        var d = "number" === typeof f ? f : f = 0
          , c = "number" === typeof b ? b : a.length;
        b = -1;
        for (d = c & 7; d--; ++f)
            b = b >>> 8 ^ r[(b ^ a[f]) & 255];
        for (d = c >> 3; d--; f += 8)
            b = b >>> 8 ^ r[(b ^ a[f]) & 255],
            b = b >>> 8 ^ r[(b ^ a[f + 1]) & 255],
            b = b >>> 8 ^ r[(b ^ a[f + 2]) & 255],
            b = b >>> 8 ^ r[(b ^ a[f + 3]) & 255],
            b = b >>> 8 ^ r[(b ^ a[f + 4]) & 255],
            b = b >>> 8 ^ r[(b ^ a[f + 
            5]) & 255],
            b = b >>> 8 ^ r[(b ^ a[f + 6]) & 255],
            b = b >>> 8 ^ r[(b ^ a[f + 7]) & 255];
        return (b ^ 4294967295) >>> 0
    }
    function e() {}
    function d(a) {
        var f = a.length, b = 0, d = Number.POSITIVE_INFINITY, c, k, e, h, g, l, m, p, r;
        for (p = 0; p < f; ++p)
            a[p] > b && (b = a[p]),
            a[p] < d && (d = a[p]);
        c = 1 << b;
        k = new (n ? Uint32Array : Array)(c);
        e = 1;
        h = 0;
        for (g = 2; e <= b; ) {
            for (p = 0; p < f; ++p)
                if (a[p] === e) {
                    l = 0;
                    m = h;
                    for (r = 0; r < e; ++r)
                        l = l << 1 | m & 1,
                        m >>= 1;
                    for (r = l; r < c; r += g)
                        k[r] = e << 16 | p;
                    ++h
                }
            ++e;
            h <<= 1;
            g <<= 1
        }
        return [k, b, d]
    }
    function g(f, b) {
        this.i = [];
        this.j = 32768;
        this.d = this.f = this.c = this.n = 0;
        this.input = 
        n ? new Uint8Array(f) : f;
        this.o = !1;
        this.k = w;
        this.w = !1;
        if (b || !(b = {}))
            b.index && (this.c = b.index),
            b.bufferSize && (this.j = b.bufferSize),
            b.bufferType && (this.k = b.bufferType),
            b.resize && (this.w = b.resize);
        switch (this.k) {
        case u:
            this.a = 32768;
            this.b = new (n ? Uint8Array : Array)(32768 + this.j + 258);
            break;
        case w:
            this.a = 0;
            this.b = new (n ? Uint8Array : Array)(this.j);
            this.e = this.D;
            this.q = this.A;
            this.l = this.C;
            break;
        default:
            a(Error("invalid inflate mode"))
        }
    }
    function f(f, b) {
        for (var d = f.f, c = f.d, k = f.input, e = f.c, h; c < b; )
            h = k[e++],
            void 0 === 
            h && a(Error("input buffer is broken")),
            d |= h << c,
            c += 8;
        f.f = d >>> b;
        f.d = c - b;
        f.c = e;
        return d & (1 << b) - 1
    }
    function k(a, f) {
        for (var b = a.f, d = a.d, c = a.input, k = a.c, e = f[0], h = f[1], g; d < h; ) {
            g = c[k++];
            if (void 0 === g)
                break;
            b |= g << d;
            d += 8
        }
        c = e[b & (1 << h) - 1];
        e = c >>> 16;
        a.f = b >> e;
        a.d = d - e;
        a.c = k;
        return c & 65535
    }
    function h(a) {
        function b(a, d, c) {
            var e, h, g, l;
            for (l = 0; l < a; )
                switch (e = k(this, d),
                e) {
                case 16:
                    for (g = 3 + f(this, 2); g--; )
                        c[l++] = h;
                    break;
                case 17:
                    for (g = 3 + f(this, 3); g--; )
                        c[l++] = 0;
                    h = 0;
                    break;
                case 18:
                    for (g = 11 + f(this, 7); g--; )
                        c[l++] = 0;
                    h = 0;
                    break;
                default:
                    h = 
                    c[l++] = e
                }
            return c
        }
        var c = f(a, 5) + 257, e = f(a, 5) + 1, h = f(a, 4) + 4, g = new (n ? Uint8Array : Array)(x.length), l;
        for (l = 0; l < h; ++l)
            g[x[l]] = f(a, 3);
        h = d(g);
        g = new (n ? Uint8Array : Array)(c);
        l = new (n ? Uint8Array : Array)(e);
        a.l(d(b.call(a, c, h, g)), d(b.call(a, e, h, l)))
    }
    function l(a) {
        this.input = a;
        this.c = 0;
        this.m = [];
        this.s = !1
    }
    var m = this
      , n = "undefined" !== typeof Uint8Array && "undefined" !== typeof Uint16Array && "undefined" !== typeof Uint32Array;
    new (n ? Uint8Array : Array)(256);
    var p;
    for (p = 0; 256 > p; ++p)
        for (var t = p, v = 7, t = t >>> 1; t; t >>>= 1)
            --v;
    p = [0, 
    1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 
    651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 
    4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 
    167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 
    3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918E3, 
    2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117];
    var r = n ? new Uint32Array(p) : p;
    e.prototype.getName = function() {
        return this.name
    }
    ;
    e.prototype.getData = function() {
        return this.data
    }
    ;
    e.prototype.G = function() {
        return this.H
    }
    ;
    b("Zlib.GunzipMember", e);
    b("Zlib.GunzipMember.prototype.getName", e.prototype.getName);
    b("Zlib.GunzipMember.prototype.getData", 
    e.prototype.getData);
    b("Zlib.GunzipMember.prototype.getMtime", e.prototype.G);
    p = [];
    for (t = 0; 288 > t; t++)
        switch (!0) {
        case 143 >= t:
            p.push([t + 48, 8]);
            break;
        case 255 >= t:
            p.push([t - 144 + 400, 9]);
            break;
        case 279 >= t:
            p.push([t - 256 + 0, 7]);
            break;
        case 287 >= t:
            p.push([t - 280 + 192, 8]);
            break;
        default:
            a("invalid literal: " + t)
        }
    p = function() {
        function f(b) {
            switch (!0) {
            case 3 === b:
                return [257, b - 3, 0];
            case 4 === b:
                return [258, b - 4, 0];
            case 5 === b:
                return [259, b - 5, 0];
            case 6 === b:
                return [260, b - 6, 0];
            case 7 === b:
                return [261, b - 7, 0];
            case 8 === b:
                return [262, 
                b - 8, 0];
            case 9 === b:
                return [263, b - 9, 0];
            case 10 === b:
                return [264, b - 10, 0];
            case 12 >= b:
                return [265, b - 11, 1];
            case 14 >= b:
                return [266, b - 13, 1];
            case 16 >= b:
                return [267, b - 15, 1];
            case 18 >= b:
                return [268, b - 17, 1];
            case 22 >= b:
                return [269, b - 19, 2];
            case 26 >= b:
                return [270, b - 23, 2];
            case 30 >= b:
                return [271, b - 27, 2];
            case 34 >= b:
                return [272, b - 31, 2];
            case 42 >= b:
                return [273, b - 35, 3];
            case 50 >= b:
                return [274, b - 43, 3];
            case 58 >= b:
                return [275, b - 51, 3];
            case 66 >= b:
                return [276, b - 59, 3];
            case 82 >= b:
                return [277, b - 67, 4];
            case 98 >= b:
                return [278, b - 83, 4];
            case 114 >= b:
                return [279, 
                b - 99, 4];
            case 130 >= b:
                return [280, b - 115, 4];
            case 162 >= b:
                return [281, b - 131, 5];
            case 194 >= b:
                return [282, b - 163, 5];
            case 226 >= b:
                return [283, b - 195, 5];
            case 257 >= b:
                return [284, b - 227, 5];
            case 258 === b:
                return [285, b - 258, 0];
            default:
                a("invalid length: " + b)
            }
        }
        var b = [], d, c;
        for (d = 3; 258 >= d; d++)
            c = f(d),
            b[d] = c[2] << 24 | c[1] << 16 | c[0];
        return b
    }
    ();
    n && new Uint32Array(p);
    var u = 0
      , w = 1;
    g.prototype.g = function() {
        for (; !this.o; ) {
            var b = f(this, 3);
            b & 1 && (this.o = !0);
            b >>>= 1;
            switch (b) {
            case 0:
                var b = this.input
                  , d = this.c
                  , c = this.b
                  , k = this.a
                  , e = void 0
                  , g = void 0
                  , 
                l = void 0
                  , m = c.length
                  , e = void 0;
                this.d = this.f = 0;
                e = b[d++];
                void 0 === e && a(Error("invalid uncompressed block header: LEN (first byte)"));
                g = e;
                e = b[d++];
                void 0 === e && a(Error("invalid uncompressed block header: LEN (second byte)"));
                g |= e << 8;
                e = b[d++];
                void 0 === e && a(Error("invalid uncompressed block header: NLEN (first byte)"));
                l = e;
                e = b[d++];
                void 0 === e && a(Error("invalid uncompressed block header: NLEN (second byte)"));
                l |= e << 8;
                g === ~l && a(Error("invalid uncompressed block header: length verify"));
                d + g > b.length && a(Error("input buffer is broken"));
                switch (this.k) {
                case u:
                    for (; k + g > c.length; ) {
                        e = m - k;
                        g -= e;
                        if (n)
                            c.set(b.subarray(d, d + e), k),
                            k += e,
                            d += e;
                        else
                            for (; e--; )
                                c[k++] = b[d++];
                        this.a = k;
                        c = this.e();
                        k = this.a
                    }
                    break;
                case w:
                    for (; k + g > c.length; )
                        c = this.e({
                            t: 2
                        });
                    break;
                default:
                    a(Error("invalid inflate mode"))
                }
                if (n)
                    c.set(b.subarray(d, d + g), k),
                    k += g,
                    d += g;
                else
                    for (; g--; )
                        c[k++] = b[d++];
                this.c = d;
                this.a = k;
                this.b = c;
                break;
            case 1:
                this.l(C, B);
                break;
            case 2:
                h(this);
                break;
            default:
                a(Error("unknown BTYPE: " + b))
            }
        }
        return this.q()
    }
    ;
    p = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 
    15];
    var x = n ? new Uint16Array(p) : p;
    p = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 258, 258];
    var A = n ? new Uint16Array(p) : p;
    p = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0];
    var y = n ? new Uint8Array(p) : p;
    p = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
    var z = n ? new Uint16Array(p) : p;
    p = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var E = n ? new Uint8Array(p) : p;
    p = 
    new (n ? Uint8Array : Array)(288);
    t = 0;
    for (v = p.length; t < v; ++t)
        p[t] = 143 >= t ? 8 : 255 >= t ? 9 : 279 >= t ? 7 : 8;
    var C = d(p);
    p = new (n ? Uint8Array : Array)(30);
    t = 0;
    for (v = p.length; t < v; ++t)
        p[t] = 5;
    var B = d(p);
    g.prototype.l = function(a, b) {
        var d = this.b
          , c = this.a;
        this.r = a;
        for (var e = d.length - 258, h, g, l; 256 !== (h = k(this, a)); )
            if (256 > h)
                c >= e && (this.a = c,
                d = this.e(),
                c = this.a),
                d[c++] = h;
            else
                for (h -= 257,
                l = A[h],
                0 < y[h] && (l += f(this, y[h])),
                h = k(this, b),
                g = z[h],
                0 < E[h] && (g += f(this, E[h])),
                c >= e && (this.a = c,
                d = this.e(),
                c = this.a); l--; )
                    d[c] = d[c++ - g];
        for (; 8 <= this.d; )
            this.d -= 
            8,
            this.c--;
        this.a = c
    }
    ;
    g.prototype.C = function(a, b) {
        var d = this.b
          , c = this.a;
        this.r = a;
        for (var e = d.length, h, g, l; 256 !== (h = k(this, a)); )
            if (256 > h)
                c >= e && (d = this.e(),
                e = d.length),
                d[c++] = h;
            else
                for (h -= 257,
                l = A[h],
                0 < y[h] && (l += f(this, y[h])),
                h = k(this, b),
                g = z[h],
                0 < E[h] && (g += f(this, E[h])),
                c + l > e && (d = this.e(),
                e = d.length); l--; )
                    d[c] = d[c++ - g];
        for (; 8 <= this.d; )
            this.d -= 8,
            this.c--;
        this.a = c
    }
    ;
    g.prototype.e = function() {
        var a = new (n ? Uint8Array : Array)(this.a - 32768), b = this.a - 32768, f, d, c = this.b;
        if (n)
            a.set(c.subarray(32768, a.length));
        else
            for (f = 
            0,
            d = a.length; f < d; ++f)
                a[f] = c[f + 32768];
        this.i.push(a);
        this.n += a.length;
        if (n)
            c.set(c.subarray(b, b + 32768));
        else
            for (f = 0; 32768 > f; ++f)
                c[f] = c[b + f];
        this.a = 32768;
        return c
    }
    ;
    g.prototype.D = function(a) {
        var b, f = this.input.length / this.c + 1 | 0, d, c, k, e = this.input, h = this.b;
        a && ("number" === typeof a.t && (f = a.t),
        "number" === typeof a.z && (f += a.z));
        2 > f ? (d = (e.length - this.c) / this.r[2],
        k = d / 2 * 258 | 0,
        c = k < h.length ? h.length + k : h.length << 1) : c = h.length * f;
        n ? (b = new Uint8Array(c),
        b.set(h)) : b = h;
        return this.b = b
    }
    ;
    g.prototype.q = function() {
        var a = 
        0, b = this.b, f = this.i, d, c = new (n ? Uint8Array : Array)(this.n + (this.a - 32768)), k, e, h, g;
        if (0 === f.length)
            return n ? this.b.subarray(32768, this.a) : this.b.slice(32768, this.a);
        k = 0;
        for (e = f.length; k < e; ++k)
            for (d = f[k],
            h = 0,
            g = d.length; h < g; ++h)
                c[a++] = d[h];
        k = 32768;
        for (e = this.a; k < e; ++k)
            c[a++] = b[k];
        this.i = [];
        return this.buffer = c
    }
    ;
    g.prototype.A = function() {
        var a, b = this.a;
        n ? this.w ? (a = new Uint8Array(b),
        a.set(this.b.subarray(0, b))) : a = this.b.subarray(0, b) : (this.b.length > b && (this.b.length = b),
        a = this.b);
        return this.buffer = a
    }
    ;
    l.prototype.F = 
    function() {
        this.s || this.g();
        return this.m.slice()
    }
    ;
    l.prototype.g = function() {
        for (var b = this.input.length; this.c < b; ) {
            var f = new e
              , d = void 0
              , k = void 0
              , h = void 0
              , l = d = h = void 0
              , m = void 0
              , d = d = void 0
              , p = this.input
              , k = this.c;
            f.u = p[k++];
            f.v = p[k++];
            31 === f.u && 139 === f.v || a(Error("invalid file signature:" + f.u + "," + f.v));
            f.p = p[k++];
            switch (f.p) {
            case 8:
                break;
            default:
                a(Error("unknown compression method: " + f.p))
            }
            f.h = p[k++];
            d = p[k++] | p[k++] << 8 | p[k++] << 16 | p[k++] << 24;
            f.H = new Date(1E3 * d);
            f.N = p[k++];
            f.M = p[k++];
            0 < (f.h & 4) && (f.I = p[k++] | 
            p[k++] << 8,
            k += f.I);
            if (0 < (f.h & 8)) {
                m = [];
                for (l = 0; 0 < (d = p[k++]); )
                    m[l++] = String.fromCharCode(d);
                f.name = m.join("")
            }
            if (0 < (f.h & 16)) {
                m = [];
                for (l = 0; 0 < (d = p[k++]); )
                    m[l++] = String.fromCharCode(d);
                f.J = m.join("")
            }
            0 < (f.h & 2) && (f.B = c(p, 0, k) & 65535,
            f.B !== (p[k++] | p[k++] << 8) && a(Error("invalid header crc16")));
            d = p[p.length - 4] | p[p.length - 3] << 8 | p[p.length - 2] << 16 | p[p.length - 1] << 24;
            p.length - k - 4 - 4 < 512 * d && (h = d);
            k = new g(p,{
                index: k,
                bufferSize: h
            });
            f.data = h = k.g();
            k = k.c;
            f.K = d = (p[k++] | p[k++] << 8 | p[k++] << 16 | p[k++] << 24) >>> 0;
            c(h, void 0, void 0) !== 
            d && a(Error("invalid CRC-32 checksum: 0x" + c(h, void 0, void 0).toString(16) + " / 0x" + d.toString(16)));
            f.L = d = (p[k++] | p[k++] << 8 | p[k++] << 16 | p[k++] << 24) >>> 0;
            (h.length & 4294967295) !== d && a(Error("invalid input size: " + (h.length & 4294967295) + " / " + d));
            this.m.push(f);
            this.c = k
        }
        this.s = !0;
        b = this.m;
        f = h = k = 0;
        for (p = b.length; f < p; ++f)
            h += b[f].data.length;
        if (n)
            for (h = new Uint8Array(h),
            f = 0; f < p; ++f)
                h.set(b[f].data, k),
                k += b[f].data.length;
        else {
            h = [];
            for (f = 0; f < p; ++f)
                h[f] = b[f].data;
            h = Array.prototype.concat.apply([], h)
        }
        return h
    }
    ;
    b("Zlib.Gunzip", l);
    b("Zlib.Gunzip.prototype.decompress", l.prototype.g);
    b("Zlib.Gunzip.prototype.getMembers", l.prototype.F)
}
).call(this);
"undefined" !== typeof window && !function(a, b, c) {
    var e = a.L
      , d = {
        version: "0.7.2"
    };
    "object" == typeof module && "object" == typeof module.exports ? module.exports = d : "function" == typeof define && define.amd && define(d);
    d.noConflict = function() {
        return a.L = e,
        this
    }
    ;
    a.L = d;
    d.Util = {
        extend: function(a) {
            var b, d, c, e, g = Array.prototype.slice.call(arguments, 1);
            d = 0;
            for (c = g.length; c > d; d++)
                for (b in e = g[d] || {},
                e)
                    e.hasOwnProperty(b) && (a[b] = e[b]);
            return a
        },
        bind: function(a, b) {
            var d = 2 < arguments.length ? Array.prototype.slice.call(arguments, 
            2) : null ;
            return function() {
                return a.apply(b, d || arguments)
            }
        },
        stamp: function() {
            var a = 0;
            return function(b) {
                return b._leaflet_id = b._leaflet_id || ++a,
                b._leaflet_id
            }
        }
        (),
        invokeEach: function(a, b, d) {
            var c, e;
            if ("object" == typeof a) {
                e = Array.prototype.slice.call(arguments, 3);
                for (c in a)
                    b.apply(d, [c, a[c]].concat(e));
                return !0
            }
            return !1
        },
        limitExecByInterval: function(a, b, d) {
            var c, e;
            return function p() {
                var g = arguments;
                return c ? void (e = !0) : (c = !0,
                setTimeout(function() {
                    c = !1;
                    e && (p.apply(d, g),
                    e = !1)
                }
                , b),
                void a.apply(d, g))
            }
        },
        falseFn: function() {
            return !1
        },
        formatNum: function(a, b) {
            var d = Math.pow(10, b || 5);
            return Math.round(a * d) / d
        },
        trim: function(a) {
            return a.trim ? a.trim() : a.replace(/^\s+|\s+$/g, "")
        },
        splitWords: function(a) {
            return d.Util.trim(a).split(/\s+/)
        },
        setOptions: function(a, b) {
            return a.options = d.extend({}, a.options, b),
            a.options
        },
        getParamString: function(a, b, d) {
            var c = [], e;
            for (e in a)
                c.push(encodeURIComponent(d ? e.toUpperCase() : e) + "=" + encodeURIComponent(a[e]));
            return (b && -1 !== b.indexOf("?") ? "&" : "?") + c.join("&")
        },
        template: function(a, 
        b) {
            return a.replace(/\{ *([\w_]+) *\}/g, function(a, f) {
                var d = b[f];
                if (d === c)
                    throw Error("No value provided for variable " + a);
                return "function" == typeof d && (d = d(b)),
                d
            }
            )
        },
        isArray: Array.isArray || function(a) {
            return "[object Array]" === Object.prototype.toString.call(a)
        }
        ,
        emptyImageUrl: "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs="
    };
    (function() {
        function b(f) {
            var d, c, k = ["webkit", "moz", "o", "ms"];
            for (d = 0; d < k.length && !c; d++)
                c = a[k[d] + f];
            return c
        }
        function c(b) {
            var f = +new Date
              , d = Math.max(0, 16 - (f - e));
            return e = 
            f + d,
            a.setTimeout(b, d)
        }
        var e = 0
          , g = a.requestAnimationFrame || b("RequestAnimationFrame") || c
          , m = a.cancelAnimationFrame || b("CancelAnimationFrame") || b("CancelRequestAnimationFrame") || function(b) {
            a.clearTimeout(b)
        }
        ;
        d.Util.requestAnimFrame = function(b, f, e, h) {
            return b = d.bind(b, f),
            e && g === c ? void b() : g.call(a, b, h)
        }
        ;
        d.Util.cancelAnimFrame = function(b) {
            b && m.call(a, b)
        }
    }
    )();
    d.extend = d.Util.extend;
    d.bind = d.Util.bind;
    d.stamp = d.Util.stamp;
    d.setOptions = d.Util.setOptions;
    d.Class = function() {}
    ;
    d.Class.extend = function(a) {
        var b = 
        function() {
            this.initialize && this.initialize.apply(this, arguments);
            this._initHooks && this.callInitHooks()
        }
          , c = function() {}
        ;
        c.prototype = this.prototype;
        var e = new c;
        e.constructor = b;
        b.prototype = e;
        for (var g in this)
            this.hasOwnProperty(g) && "prototype" !== g && (b[g] = this[g]);
        a.statics && (d.extend(b, a.statics),
        delete a.statics);
        a.includes && (d.Util.extend.apply(null , [e].concat(a.includes)),
        delete a.includes);
        a.options && e.options && (a.options = d.extend({}, e.options, a.options));
        d.extend(e, a);
        e._initHooks = [];
        var n = this;
        return b.__super__ = n.prototype,
        e.callInitHooks = function() {
            if (!this._initHooksCalled) {
                n.prototype.callInitHooks && n.prototype.callInitHooks.call(this);
                this._initHooksCalled = !0;
                for (var a = 0, b = e._initHooks.length; b > a; a++)
                    e._initHooks[a].call(this)
            }
        }
        ,
        b
    }
    ;
    d.Class.include = function(a) {
        d.extend(this.prototype, a)
    }
    ;
    d.Class.mergeOptions = function(a) {
        d.extend(this.prototype.options, a)
    }
    ;
    d.Class.addInitHook = function(a) {
        var b = Array.prototype.slice.call(arguments, 1);
        this.prototype._initHooks = this.prototype._initHooks || 
        [];
        this.prototype._initHooks.push("function" == typeof a ? a : function() {
            this[a].apply(this, b)
        }
        )
    }
    ;
    d.Mixin = {};
    d.Mixin.Events = {
        addEventListener: function(a, b, c) {
            if (d.Util.invokeEach(a, this.addEventListener, this, b, c))
                return this;
            var e, g, n, p, t, v, r, u = this._leaflet_events = this._leaflet_events || {}, w = c && c !== this && d.stamp(c);
            a = d.Util.splitWords(a);
            e = 0;
            for (g = a.length; g > e; e++)
                n = {
                    action: b,
                    context: c || this
                },
                p = a[e],
                w ? (t = p + "_idx",
                v = t + "_len",
                r = u[t] = u[t] || {},
                r[w] || (r[w] = [],
                u[v] = (u[v] || 0) + 1),
                r[w].push(n)) : (u[p] = u[p] || [],
                u[p].push(n));
            return this
        },
        hasEventListeners: function(a) {
            var b = this._leaflet_events;
            return !!b && (a in b && 0 < b[a].length || a + "_idx" in b && 0 < b[a + "_idx_len"])
        },
        removeEventListener: function(a, b, c) {
            if (!this._leaflet_events)
                return this;
            if (!a)
                return this.clearAllEventListeners();
            if (d.Util.invokeEach(a, this.removeEventListener, this, b, c))
                return this;
            var e, g, n, p, t, v, r, u, w, x = this._leaflet_events, A = c && c !== this && d.stamp(c);
            a = d.Util.splitWords(a);
            e = 0;
            for (g = a.length; g > e; e++)
                if (n = a[e],
                v = n + "_idx",
                r = v + "_len",
                u = x[v],
                b) {
                    if (p = 
                    A && u ? u[A] : x[n]) {
                        for (t = p.length - 1; 0 <= t; t--)
                            p[t].action !== b || c && p[t].context !== c || (w = p.splice(t, 1),
                            w[0].action = d.Util.falseFn);
                        c && u && 0 === p.length && (delete u[A],
                        x[r]--)
                    }
                } else
                    delete x[n],
                    delete x[v],
                    delete x[r];
            return this
        },
        clearAllEventListeners: function() {
            return delete this._leaflet_events,
            this
        },
        fireEvent: function(a, b) {
            if (!this.hasEventListeners(a))
                return this;
            var c, e, g, n, p, t = d.Util.extend({}, b, {
                type: a,
                target: this
            });
            n = this._leaflet_events;
            if (n[a])
                for (c = n[a].slice(),
                e = 0,
                g = c.length; g > e; e++)
                    c[e].action.call(c[e].context, 
                    t);
            n = n[a + "_idx"];
            for (p in n)
                if (c = n[p].slice())
                    for (e = 0,
                    g = c.length; g > e; e++)
                        c[e].action.call(c[e].context, t);
            return this
        },
        addOneTimeEventListener: function(a, b, c) {
            if (d.Util.invokeEach(a, this.addOneTimeEventListener, this, b, c))
                return this;
            var e = d.bind(function() {
                this.removeEventListener(a, b, c).removeEventListener(a, e, c)
            }
            , this);
            return this.addEventListener(a, b, c).addEventListener(a, e, c)
        }
    };
    d.Mixin.Events.on = d.Mixin.Events.addEventListener;
    d.Mixin.Events.off = d.Mixin.Events.removeEventListener;
    d.Mixin.Events.once = 
    d.Mixin.Events.addOneTimeEventListener;
    d.Mixin.Events.fire = d.Mixin.Events.fireEvent;
    (function() {
        var f = "ActiveXObject" in a
          , k = f && !b.addEventListener
          , e = navigator.userAgent.toLowerCase()
          , g = -1 !== e.indexOf("webkit")
          , m = -1 !== e.indexOf("chrome")
          , n = -1 !== e.indexOf("phantom")
          , p = -1 !== e.indexOf("android")
          , t = -1 !== e.search("android [23]")
          , e = -1 !== e.indexOf("gecko")
          , v = typeof orientation != c + ""
          , r = a.navigator && a.navigator.msPointerEnabled && a.navigator.msMaxTouchPoints && !a.PointerEvent
          , u = a.PointerEvent && a.navigator.pointerEnabled && 
        a.navigator.maxTouchPoints || r
          , w = "devicePixelRatio" in a && 1 < a.devicePixelRatio || "matchMedia" in a && a.matchMedia("(min-resolution:144dpi)") && a.matchMedia("(min-resolution:144dpi)").matches
          , x = b.documentElement
          , A = f && "transition" in x.style
          , y = "WebKitCSSMatrix" in a && "m11" in new a.WebKitCSSMatrix && !t
          , z = "MozPerspective" in x.style
          , E = "OTransition" in x.style
          , C = !a.L_DISABLE_3D && (A || y || z || E) && !n;
        if (n = !a.L_NO_TOUCH && !n)
            u || "ontouchstart" in x ? n = !0 : (n = b.createElement("div"),
            x = !1,
            n = n.setAttribute ? (n.setAttribute("ontouchstart", 
            "return;"),
            "function" == typeof n.ontouchstart && (x = !0),
            n.removeAttribute("ontouchstart"),
            x) : !1);
        d.Browser = {
            ie: f,
            ielt9: k,
            webkit: g,
            gecko: e && !g && !a.opera && !f,
            android: p,
            android23: t,
            chrome: m,
            ie3d: A,
            webkit3d: y,
            gecko3d: z,
            opera3d: E,
            any3d: C,
            mobile: v,
            mobileWebkit: v && g,
            mobileWebkit3d: v && y,
            mobileOpera: v && a.opera,
            touch: n,
            msPointer: r,
            pointer: u,
            retina: w
        }
    }
    )();
    d.Point = function(a, b, d) {
        this.x = d ? Math.round(a) : a;
        this.y = d ? Math.round(b) : b
    }
    ;
    d.Point.prototype = {
        clone: function() {
            return new d.Point(this.x,this.y)
        },
        add: function(a) {
            return this.clone()._add(d.point(a))
        },
        _add: function(a) {
            return this.x += a.x,
            this.y += a.y,
            this
        },
        subtract: function(a) {
            return this.clone()._subtract(d.point(a))
        },
        _subtract: function(a) {
            return this.x -= a.x,
            this.y -= a.y,
            this
        },
        divideBy: function(a) {
            return this.clone()._divideBy(a)
        },
        _divideBy: function(a) {
            return this.x /= a,
            this.y /= a,
            this
        },
        multiplyBy: function(a) {
            return this.clone()._multiplyBy(a)
        },
        _multiplyBy: function(a) {
            return this.x *= a,
            this.y *= a,
            this
        },
        round: function() {
            return this.clone()._round()
        },
        _round: function() {
            return this.x = Math.round(this.x),
            this.y = Math.round(this.y),
            this
        },
        floor: function() {
            return this.clone()._floor()
        },
        _floor: function() {
            return this.x = Math.floor(this.x),
            this.y = Math.floor(this.y),
            this
        },
        distanceTo: function(a) {
            a = d.point(a);
            var b = a.x - this.x;
            a = a.y - this.y;
            return Math.sqrt(b * b + a * a)
        },
        equals: function(a) {
            return a = d.point(a),
            a.x === this.x && a.y === this.y
        },
        contains: function(a) {
            return a = d.point(a),
            Math.abs(a.x) <= Math.abs(this.x) && Math.abs(a.y) <= Math.abs(this.y)
        },
        toString: function() {
            return "Point(" + d.Util.formatNum(this.x) + ", " + d.Util.formatNum(this.y) + 
            ")"
        }
    };
    d.point = function(a, b, e) {
        return a instanceof d.Point ? a : d.Util.isArray(a) ? new d.Point(a[0],a[1]) : a === c || null  === a ? a : new d.Point(a,b,e)
    }
    ;
    d.Bounds = function(a, b) {
        if (a)
            for (var d = b ? [a, b] : a, c = 0, e = d.length; e > c; c++)
                this.extend(d[c])
    }
    ;
    d.Bounds.prototype = {
        extend: function(a) {
            return a = d.point(a),
            this.min || this.max ? (this.min.x = Math.min(a.x, this.min.x),
            this.max.x = Math.max(a.x, this.max.x),
            this.min.y = Math.min(a.y, this.min.y),
            this.max.y = Math.max(a.y, this.max.y)) : (this.min = a.clone(),
            this.max = a.clone()),
            this
        },
        getCenter: function(a) {
            return new d.Point((this.min.x + 
            this.max.x) / 2,(this.min.y + this.max.y) / 2,a)
        },
        getBottomLeft: function() {
            return new d.Point(this.min.x,this.max.y)
        },
        getTopRight: function() {
            return new d.Point(this.max.x,this.min.y)
        },
        getSize: function() {
            return this.max.subtract(this.min)
        },
        contains: function(a) {
            var b, c;
            return a = "number" == typeof a[0] || a instanceof d.Point ? d.point(a) : d.bounds(a),
            a instanceof d.Bounds ? (b = a.min,
            c = a.max) : b = c = a,
            b.x >= this.min.x && c.x <= this.max.x && b.y >= this.min.y && c.y <= this.max.y
        },
        intersects: function(a) {
            a = d.bounds(a);
            var b = this.min
              , 
            c = this.max
              , e = a.min;
            a = a.max;
            var g = a.y >= b.y && e.y <= c.y;
            return a.x >= b.x && e.x <= c.x && g
        },
        isValid: function() {
            return !(!this.min || !this.max)
        }
    };
    d.bounds = function(a, b) {
        return !a || a instanceof d.Bounds ? a : new d.Bounds(a,b)
    }
    ;
    d.Transformation = function(a, b, d, c) {
        this._a = a;
        this._b = b;
        this._c = d;
        this._d = c
    }
    ;
    d.Transformation.prototype = {
        transform: function(a, b) {
            return this._transform(a.clone(), b)
        },
        _transform: function(a, b) {
            return b = b || 1,
            a.x = b * (this._a * a.x + this._b),
            a.y = b * (this._c * a.y + this._d),
            a
        },
        untransform: function(a, b) {
            return b = 
            b || 1,
            new d.Point((a.x / b - this._b) / this._a,(a.y / b - this._d) / this._c)
        }
    };
    d.DomUtil = {
        get: function(a) {
            return "string" == typeof a ? b.getElementById(a) : a
        },
        getStyle: function(a, d) {
            var c = a.style[d];
            (!c && a.currentStyle && (c = a.currentStyle[d]),
            c && "auto" !== c || !b.defaultView) || (c = (c = b.defaultView.getComputedStyle(a, null )) ? c[d] : null );
            return "auto" === c ? null  : c
        },
        getViewportOffset: function(a) {
            var c, e = 0, g = 0, m = a, n = b.body, p = b.documentElement;
            do {
                if (e += m.offsetTop || 0,
                g += m.offsetLeft || 0,
                e += parseInt(d.DomUtil.getStyle(m, "borderTopWidth"), 
                10) || 0,
                g += parseInt(d.DomUtil.getStyle(m, "borderLeftWidth"), 10) || 0,
                c = d.DomUtil.getStyle(m, "position"),
                m.offsetParent === n && "absolute" === c)
                    break;
                if ("fixed" === c) {
                    e += n.scrollTop || p.scrollTop || 0;
                    g += n.scrollLeft || p.scrollLeft || 0;
                    break
                }
                if ("relative" === c && !m.offsetLeft) {
                    c = d.DomUtil.getStyle(m, "width");
                    var t = d.DomUtil.getStyle(m, "max-width")
                      , v = m.getBoundingClientRect();
                    "none" === c && "none" === t || (g += v.left + m.clientLeft);
                    e += v.top + (n.scrollTop || p.scrollTop || 0);
                    break
                }
                m = m.offsetParent
            } while (m);m = a;
            do {
                if (m === n)
                    break;
                e -= m.scrollTop || 0;
                g -= m.scrollLeft || 0;
                m = m.parentNode
            } while (m);return new d.Point(g,e)
        },
        documentIsLtr: function() {
            return d.DomUtil._docIsLtrCached || (d.DomUtil._docIsLtrCached = !0,
            d.DomUtil._docIsLtr = "ltr" === d.DomUtil.getStyle(b.body, "direction")),
            d.DomUtil._docIsLtr
        },
        create: function(a, c, d) {
            a = b.createElement(a);
            return a.className = c,
            d && d.appendChild(a),
            a
        },
        hasClass: function(a, b) {
            if (a.classList !== c)
                return a.classList.contains(b);
            var e = d.DomUtil._getClass(a);
            return 0 < e.length && (new RegExp("(^|\\s)" + b + "(\\s|$)")).test(e)
        },
        addClass: function(a, b) {
            if (a.classList !== c)
                for (var e = d.Util.splitWords(b), g = 0, m = e.length; m > g; g++)
                    a.classList.add(e[g]);
            else
                d.DomUtil.hasClass(a, b) || (e = d.DomUtil._getClass(a),
                d.DomUtil._setClass(a, (e ? e + " " : "") + b))
        },
        removeClass: function(a, b) {
            a.classList !== c ? a.classList.remove(b) : d.DomUtil._setClass(a, d.Util.trim((" " + d.DomUtil._getClass(a) + " ").replace(" " + b + " ", " ")))
        },
        _setClass: function(a, b) {
            a.className.baseVal === c ? a.className = b : a.className.baseVal = b
        },
        _getClass: function(a) {
            return a.className.baseVal === 
            c ? a.className : a.className.baseVal
        },
        setOpacity: function(a, b) {
            if ("opacity" in a.style)
                a.style.opacity = b;
            else if ("filter" in a.style) {
                var c = !1;
                try {
                    c = a.filters.item("DXImageTransform.Microsoft.Alpha")
                } catch (d) {
                    if (1 === b)
                        return
                }
                b = Math.round(100 * b);
                c ? (c.Enabled = 100 !== b,
                c.Opacity = b) : a.style.filter += " progid:DXImageTransform.Microsoft.Alpha(opacity=" + b + ")"
            }
        },
        testProp: function(a) {
            for (var c = b.documentElement.style, d = 0; d < a.length; d++)
                if (a[d] in c)
                    return a[d];
            return !1
        },
        getTranslateString: function(a) {
            var b = d.Browser.webkit3d;
            return "translate" + (b ? "3d" : "") + "(" + a.x + "px," + a.y + "px" + ((b ? ",0" : "") + ")")
        },
        getScaleString: function(a, b) {
            return d.DomUtil.getTranslateString(b.add(b.multiplyBy(-1 * a))) + (" scale(" + a + ") ")
        },
        setPosition: function(a, b, c) {
            a._leaflet_pos = b;
            !c && d.Browser.any3d ? a.style[d.DomUtil.TRANSFORM] = d.DomUtil.getTranslateString(b) : (a.style.left = b.x + "px",
            a.style.top = b.y + "px")
        },
        getPosition: function(a) {
            return a._leaflet_pos
        }
    };
    d.DomUtil.TRANSFORM = d.DomUtil.testProp(["transform", "WebkitTransform", "OTransform", "MozTransform", 
    "msTransform"]);
    d.DomUtil.TRANSITION = d.DomUtil.testProp(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
    d.DomUtil.TRANSITION_END = "webkitTransition" === d.DomUtil.TRANSITION || "OTransition" === d.DomUtil.TRANSITION ? d.DomUtil.TRANSITION + "End" : "transitionend";
    (function() {
        if ("onselectstart" in b)
            d.extend(d.DomUtil, {
                disableTextSelection: function() {
                    d.DomEvent.on(a, "selectstart", d.DomEvent.preventDefault)
                },
                enableTextSelection: function() {
                    d.DomEvent.off(a, "selectstart", d.DomEvent.preventDefault)
                }
            });
        else {
            var f = d.DomUtil.testProp(["userSelect", "WebkitUserSelect", "OUserSelect", "MozUserSelect", "msUserSelect"]);
            d.extend(d.DomUtil, {
                disableTextSelection: function() {
                    if (f) {
                        var a = b.documentElement.style;
                        this._userSelect = a[f];
                        a[f] = "none"
                    }
                },
                enableTextSelection: function() {
                    f && (b.documentElement.style[f] = this._userSelect,
                    delete this._userSelect)
                }
            })
        }
        d.extend(d.DomUtil, {
            disableImageDrag: function() {
                d.DomEvent.on(a, "dragstart", d.DomEvent.preventDefault)
            },
            enableImageDrag: function() {
                d.DomEvent.off(a, "dragstart", 
                d.DomEvent.preventDefault)
            }
        })
    }
    )();
    d.LatLng = function(a, b, d) {
        if (a = parseFloat(a),
        b = parseFloat(b),
        isNaN(a) || isNaN(b))
            throw Error("Invalid LatLng object: (" + a + ", " + b + ")");
        this.lat = a;
        this.lng = b;
        d !== c && (this.alt = parseFloat(d))
    }
    ;
    d.extend(d.LatLng, {
        DEG_TO_RAD: Math.PI / 180,
        RAD_TO_DEG: 180 / Math.PI,
        MAX_MARGIN: 1E-9
    });
    d.LatLng.prototype = {
        equals: function(a) {
            if (!a)
                return !1;
            a = d.latLng(a);
            return Math.max(Math.abs(this.lat - a.lat), Math.abs(this.lng - a.lng)) <= d.LatLng.MAX_MARGIN
        },
        toString: function(a) {
            return "LatLng(" + d.Util.formatNum(this.lat, 
            a) + ", " + d.Util.formatNum(this.lng, a) + ")"
        },
        distanceTo: function(a) {
            a = d.latLng(a);
            var b = d.LatLng.DEG_TO_RAD
              , c = (a.lng - this.lng) * b
              , e = this.lat * b
              , g = a.lat * b;
            a = Math.sin((a.lat - this.lat) * b / 2);
            c = Math.sin(c / 2);
            e = a * a + c * c * Math.cos(e) * Math.cos(g);
            return 12756274 * Math.atan2(Math.sqrt(e), Math.sqrt(1 - e))
        },
        wrap: function(a, b) {
            var c = this.lng;
            return a = a || -180,
            b = b || 180,
            c = (c + b) % (b - a) + (a > c || c === b ? b : a),
            new d.LatLng(this.lat,c)
        }
    };
    d.latLng = function(a, b) {
        return a instanceof d.LatLng ? a : d.Util.isArray(a) ? "number" == typeof a[0] || 
        "string" == typeof a[0] ? new d.LatLng(a[0],a[1],a[2]) : null  : a === c || null  === a ? a : "object" == typeof a && "lat" in a ? new d.LatLng(a.lat,"lng" in a ? a.lng : a.lon) : b === c ? null  : new d.LatLng(a,b)
    }
    ;
    d.LatLngBounds = function(a, b) {
        if (a)
            for (var c = b ? [a, b] : a, d = 0, e = c.length; e > d; d++)
                this.extend(c[d])
    }
    ;
    d.LatLngBounds.prototype = {
        extend: function(a) {
            if (!a)
                return this;
            var b = d.latLng(a);
            return a = null  !== b ? b : d.latLngBounds(a),
            a instanceof d.LatLng ? this._southWest || this._northEast ? (this._southWest.lat = Math.min(a.lat, this._southWest.lat),
            this._southWest.lng = Math.min(a.lng, this._southWest.lng),
            this._northEast.lat = Math.max(a.lat, this._northEast.lat),
            this._northEast.lng = Math.max(a.lng, this._northEast.lng)) : (this._southWest = new d.LatLng(a.lat,a.lng),
            this._northEast = new d.LatLng(a.lat,a.lng)) : a instanceof d.LatLngBounds && (this.extend(a._southWest),
            this.extend(a._northEast)),
            this
        },
        pad: function(a) {
            var b = this._southWest
              , c = this._northEast
              , e = Math.abs(b.lat - c.lat) * a;
            a *= Math.abs(b.lng - c.lng);
            return new d.LatLngBounds(new d.LatLng(b.lat - e,b.lng - 
            a),new d.LatLng(c.lat + e,c.lng + a))
        },
        getCenter: function() {
            return new d.LatLng((this._southWest.lat + this._northEast.lat) / 2,(this._southWest.lng + this._northEast.lng) / 2)
        },
        getSouthWest: function() {
            return this._southWest
        },
        getNorthEast: function() {
            return this._northEast
        },
        getNorthWest: function() {
            return new d.LatLng(this.getNorth(),this.getWest())
        },
        getSouthEast: function() {
            return new d.LatLng(this.getSouth(),this.getEast())
        },
        getWest: function() {
            return this._southWest.lng
        },
        getSouth: function() {
            return this._southWest.lat
        },
        getEast: function() {
            return this._northEast.lng
        },
        getNorth: function() {
            return this._northEast.lat
        },
        contains: function(a) {
            a = "number" == typeof a[0] || a instanceof d.LatLng ? d.latLng(a) : d.latLngBounds(a);
            var b, c, e = this._southWest, g = this._northEast;
            return a instanceof d.LatLngBounds ? (b = a.getSouthWest(),
            c = a.getNorthEast()) : b = c = a,
            b.lat >= e.lat && c.lat <= g.lat && b.lng >= e.lng && c.lng <= g.lng
        },
        intersects: function(a) {
            a = d.latLngBounds(a);
            var b = this._southWest
              , c = this._northEast
              , e = a.getSouthWest();
            a = a.getNorthEast();
            var g = 
            a.lng >= b.lng && e.lng <= c.lng;
            return a.lat >= b.lat && e.lat <= c.lat && g
        },
        toBBoxString: function() {
            return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join()
        },
        equals: function(a) {
            return a ? (a = d.latLngBounds(a),
            this._southWest.equals(a.getSouthWest()) && this._northEast.equals(a.getNorthEast())) : !1
        },
        isValid: function() {
            return !(!this._southWest || !this._northEast)
        }
    };
    d.latLngBounds = function(a, b) {
        return !a || a instanceof d.LatLngBounds ? a : new d.LatLngBounds(a,b)
    }
    ;
    d.Projection = {};
    d.Projection.SphericalMercator = 
    {
        MAX_LATITUDE: 85.0511287798,
        project: function(a) {
            var b = d.LatLng.DEG_TO_RAD
              , c = this.MAX_LATITUDE
              , c = Math.max(Math.min(c, a.lat), -c);
            a = a.lng * b;
            b *= c;
            return b = Math.log(Math.tan(Math.PI / 4 + b / 2)),
            new d.Point(a,b)
        },
        unproject: function(a) {
            var b = d.LatLng.RAD_TO_DEG
              , c = a.x * b;
            a = (2 * Math.atan(Math.exp(a.y)) - Math.PI / 2) * b;
            return new d.LatLng(a,c)
        }
    };
    d.Projection.LonLat = {
        project: function(a) {
            return new d.Point(a.lng,a.lat)
        },
        unproject: function(a) {
            return new d.LatLng(a.y,a.x)
        }
    };
    d.CRS = {
        latLngToPoint: function(a, b) {
            var c = this.projection.project(a)
              , 
            d = this.scale(b);
            return this.transformation._transform(c, d)
        },
        pointToLatLng: function(a, b) {
            var c = this.scale(b)
              , c = this.transformation.untransform(a, c);
            return this.projection.unproject(c)
        },
        project: function(a) {
            return this.projection.project(a)
        },
        scale: function(a) {
            return 256 * Math.pow(2, a)
        },
        getSize: function(a) {
            a = this.scale(a);
            return d.point(a, a)
        }
    };
    d.CRS.Simple = d.extend({}, d.CRS, {
        projection: d.Projection.LonLat,
        transformation: new d.Transformation(1,0,-1,0),
        scale: function(a) {
            return Math.pow(2, a)
        }
    });
    d.CRS.EPSG3857 = 
    d.extend({}, d.CRS, {
        code: "EPSG:3857",
        projection: d.Projection.SphericalMercator,
        transformation: new d.Transformation(.5 / Math.PI,.5,-.5 / Math.PI,.5),
        project: function(a) {
            return this.projection.project(a).multiplyBy(6378137)
        }
    });
    d.CRS.EPSG900913 = d.extend({}, d.CRS.EPSG3857, {
        code: "EPSG:900913"
    });
    d.CRS.EPSG4326 = d.extend({}, d.CRS, {
        code: "EPSG:4326",
        projection: d.Projection.LonLat,
        transformation: new d.Transformation(1 / 360,.5,-1 / 360,.5)
    });
    d.Map = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            crs: d.CRS.EPSG3857,
            fadeAnimation: d.DomUtil.TRANSITION && !d.Browser.android23,
            trackResize: !0,
            markerZoomAnimation: d.DomUtil.TRANSITION && d.Browser.any3d
        },
        initialize: function(a, b) {
            b = d.setOptions(this, b);
            this._initContainer(a);
            this._initLayout();
            this._onResize = d.bind(this._onResize, this);
            this._initEvents();
            b.maxBounds && this.setMaxBounds(b.maxBounds);
            b.center && b.zoom !== c && this.setView(d.latLng(b.center), b.zoom, {
                reset: !0
            });
            this._handlers = [];
            this._layers = {};
            this._zoomBoundLayers = {};
            this._tileLayersNum = 0;
            this.callInitHooks();
            this._addLayers(b.layers)
        },
        setView: function(a, b) {
            return b = b === c ? this.getZoom() : b,
            this._resetView(d.latLng(a), this._limitZoom(b)),
            this
        },
        setZoom: function(a, b) {
            return this._loaded ? this.setView(this.getCenter(), a, {
                zoom: b
            }) : (this._zoom = this._limitZoom(a),
            this)
        },
        zoomIn: function(a, b) {
            return this.setZoom(this._zoom + (a || 1), b)
        },
        zoomOut: function(a, b) {
            return this.setZoom(this._zoom - (a || 1), b)
        },
        setZoomAround: function(a, b, c) {
            var e = this.getZoomScale(b)
              , g = this.getSize().divideBy(2);
            a = (a instanceof d.Point ? a : this.latLngToContainerPoint(a)).subtract(g).multiplyBy(1 - 
            1 / e);
            g = this.containerPointToLatLng(g.add(a));
            return this.setView(g, b, {
                zoom: c
            })
        },
        fitBounds: function(a, b) {
            b = b || {};
            a = a.getBounds ? a.getBounds() : d.latLngBounds(a);
            var c = d.point(b.paddingTopLeft || b.padding || [0, 0])
              , e = d.point(b.paddingBottomRight || b.padding || [0, 0])
              , g = this.getBoundsZoom(a, !1, c.add(e))
              , c = e.subtract(c).divideBy(2)
              , e = this.project(a.getSouthWest(), g)
              , n = this.project(a.getNorthEast(), g)
              , c = this.unproject(e.add(n).divideBy(2).add(c), g);
            return g = b && b.maxZoom ? Math.min(b.maxZoom, g) : g,
            this.setView(c, 
            g, b)
        },
        fitWorld: function(a) {
            return this.fitBounds([[-90, -180], [90, 180]], a)
        },
        panTo: function(a, b) {
            return this.setView(a, this._zoom, {
                pan: b
            })
        },
        panBy: function(a) {
            return this.fire("movestart"),
            this._rawPanBy(d.point(a)),
            this.fire("move"),
            this.fire("moveend")
        },
        setMaxBounds: function(a) {
            return a = d.latLngBounds(a),
            this.options.maxBounds = a,
            a ? (this._loaded && this._panInsideMaxBounds(),
            this.on("moveend", this._panInsideMaxBounds, this)) : this.off("moveend", this._panInsideMaxBounds, this)
        },
        panInsideBounds: function(a, 
        b) {
            var c = this.getCenter()
              , d = this._limitCenter(c, this._zoom, a);
            return c.equals(d) ? this : this.panTo(d, b)
        },
        addLayer: function(a) {
            var b = d.stamp(a);
            return this._layers[b] ? this : (this._layers[b] = a,
            !a.options || isNaN(a.options.maxZoom) && isNaN(a.options.minZoom) || (this._zoomBoundLayers[b] = a,
            this._updateZoomLevels()),
            this.options.zoomAnimation && d.TileLayer && a instanceof d.TileLayer && (this._tileLayersNum++,
            this._tileLayersToLoad++,
            a.on("load", this._onTileLayerLoad, this)),
            this._loaded && this._layerAdd(a),
            this)
        },
        removeLayer: function(a) {
            var b = d.stamp(a);
            return this._layers[b] ? (this._loaded && a.onRemove(this),
            delete this._layers[b],
            this._loaded && this.fire("layerremove", {
                layer: a
            }),
            this._zoomBoundLayers[b] && (delete this._zoomBoundLayers[b],
            this._updateZoomLevels()),
            this.options.zoomAnimation && d.TileLayer && a instanceof d.TileLayer && (this._tileLayersNum--,
            this._tileLayersToLoad--,
            a.off("load", this._onTileLayerLoad, this)),
            this) : this
        },
        hasLayer: function(a) {
            return a ? d.stamp(a) in this._layers : !1
        },
        eachLayer: function(a, 
        b) {
            for (var c in this._layers)
                a.call(b, this._layers[c]);
            return this
        },
        invalidateSize: function(a) {
            if (!this._loaded)
                return this;
            a = d.extend({
                animate: !1,
                pan: !0
            }, !0 === a ? {
                animate: !0
            } : a);
            var b = this.getSize();
            this._sizeChanged = !0;
            this._initialCenter = null ;
            var c = this.getSize()
              , e = b.divideBy(2).round()
              , g = c.divideBy(2).round()
              , e = e.subtract(g);
            return e.x || e.y ? (a.animate && a.pan ? this.panBy(e) : (a.pan && this._rawPanBy(e),
            this.fire("move"),
            a.debounceMoveend ? (clearTimeout(this._sizeTimer),
            this._sizeTimer = setTimeout(d.bind(this.fire, 
            this, "moveend"), 200)) : this.fire("moveend")),
            this.fire("resize", {
                oldSize: b,
                newSize: c
            })) : this
        },
        addHandler: function(a, b) {
            if (!b)
                return this;
            var c = this[a] = new b(this);
            return this._handlers.push(c),
            this.options[a] && c.enable(),
            this
        },
        remove: function() {
            this._loaded && this.fire("unload");
            this._initEvents("off");
            try {
                delete this._container._leaflet
            } catch (a) {
                this._container._leaflet = c
            }
            return this._clearPanes(),
            this._clearControlPos && this._clearControlPos(),
            this._clearHandlers(),
            this
        },
        getCenter: function() {
            return this._checkIfLoaded(),
            this._initialCenter && !this._moved() ? this._initialCenter : this.layerPointToLatLng(this._getCenterLayerPoint())
        },
        getZoom: function() {
            return this._zoom
        },
        getBounds: function() {
            var a = this.getPixelBounds()
              , b = this.unproject(a.getBottomLeft())
              , a = this.unproject(a.getTopRight());
            return new d.LatLngBounds(b,a)
        },
        getMinZoom: function() {
            return this.options.minZoom === c ? this._layersMinZoom === c ? 0 : this._layersMinZoom : this.options.minZoom
        },
        getMaxZoom: function() {
            return this.options.maxZoom === c ? this._layersMaxZoom === c ? 1 / 
            0 : this._layersMaxZoom : this.options.maxZoom
        },
        getBoundsZoom: function(a, b, c) {
            a = d.latLngBounds(a);
            var e, g = this.getMinZoom() - (b ? 1 : 0), n = this.getMaxZoom(), p = this.getSize(), t = a.getNorthWest();
            a = a.getSouthEast();
            e = !0;
            c = d.point(c || [0, 0]);
            do
                g++,
                e = this.project(a, g).subtract(this.project(t, g)).add(c),
                e = b ? e.x < p.x || e.y < p.y : p.contains(e);
            while (e && n >= g);return e && b ? null  : b ? g : g - 1
        },
        getSize: function() {
            return (!this._size || this._sizeChanged) && (this._size = new d.Point(this._container.clientWidth,this._container.clientHeight),
            this._sizeChanged = !1),
            this._size.clone()
        },
        getPixelBounds: function() {
            var a = this._getTopLeftPoint();
            return new d.Bounds(a,a.add(this.getSize()))
        },
        getPixelOrigin: function() {
            return this._checkIfLoaded(),
            this._initialTopLeftPoint
        },
        getPanes: function() {
            return this._panes
        },
        getContainer: function() {
            return this._container
        },
        getZoomScale: function(a) {
            var b = this.options.crs;
            return b.scale(a) / b.scale(this._zoom)
        },
        getScaleZoom: function(a) {
            return this._zoom + Math.log(a) / Math.LN2
        },
        project: function(a, b) {
            return b = b === 
            c ? this._zoom : b,
            this.options.crs.latLngToPoint(d.latLng(a), b)
        },
        unproject: function(a, b) {
            return b = b === c ? this._zoom : b,
            this.options.crs.pointToLatLng(d.point(a), b)
        },
        layerPointToLatLng: function(a) {
            a = d.point(a).add(this.getPixelOrigin());
            return this.unproject(a)
        },
        latLngToLayerPoint: function(a) {
            return this.project(d.latLng(a))._round()._subtract(this.getPixelOrigin())
        },
        containerPointToLayerPoint: function(a) {
            return d.point(a).subtract(this._getMapPanePos())
        },
        layerPointToContainerPoint: function(a) {
            return d.point(a).add(this._getMapPanePos())
        },
        containerPointToLatLng: function(a) {
            a = this.containerPointToLayerPoint(d.point(a));
            return this.layerPointToLatLng(a)
        },
        latLngToContainerPoint: function(a) {
            return this.layerPointToContainerPoint(this.latLngToLayerPoint(d.latLng(a)))
        },
        mouseEventToContainerPoint: function(a) {
            return d.DomEvent.getMousePosition(a, this._container)
        },
        mouseEventToLayerPoint: function(a) {
            return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(a))
        },
        mouseEventToLatLng: function(a) {
            return this.layerPointToLatLng(this.mouseEventToLayerPoint(a))
        },
        _initContainer: function(a) {
            a = this._container = d.DomUtil.get(a);
            if (!a)
                throw Error("Map container not found.");
            if (a._leaflet)
                throw Error("Map container is already initialized.");
            a._leaflet = !0
        },
        _initLayout: function() {
            var a = this._container;
            d.DomUtil.addClass(a, "leaflet-container" + (d.Browser.touch ? " leaflet-touch" : "") + (d.Browser.retina ? " leaflet-retina" : "") + (d.Browser.ielt9 ? " leaflet-oldie" : "") + (this.options.fadeAnimation ? " leaflet-fade-anim" : ""));
            var b = d.DomUtil.getStyle(a, "position");
            "absolute" !== b && 
            "relative" !== b && "fixed" !== b && (a.style.position = "relative");
            this._initPanes();
            this._initControlPos && this._initControlPos()
        },
        _initPanes: function() {
            var a = this._panes = {};
            this._mapPane = a.mapPane = this._createPane("leaflet-map-pane", this._container);
            this._tilePane = a.tilePane = this._createPane("leaflet-tile-pane", this._mapPane);
            a.objectsPane = this._createPane("leaflet-objects-pane", this._mapPane);
            a.shadowPane = this._createPane("leaflet-shadow-pane");
            a.overlayPane = this._createPane("leaflet-overlay-pane");
            a.markerPane = 
            this._createPane("leaflet-marker-pane");
            a.popupPane = this._createPane("leaflet-popup-pane");
            this.options.markerZoomAnimation || (d.DomUtil.addClass(a.markerPane, " leaflet-zoom-hide"),
            d.DomUtil.addClass(a.shadowPane, " leaflet-zoom-hide"),
            d.DomUtil.addClass(a.popupPane, " leaflet-zoom-hide"))
        },
        _createPane: function(a, b) {
            return d.DomUtil.create("div", a, b || this._panes.objectsPane)
        },
        _clearPanes: function() {
            this._container.removeChild(this._mapPane)
        },
        _addLayers: function(a) {
            a = a ? d.Util.isArray(a) ? a : [a] : [];
            for (var b = 
            0, c = a.length; c > b; b++)
                this.addLayer(a[b])
        },
        _resetView: function(a, b, c, e) {
            var g = this._zoom !== b;
            e || (this.fire("movestart"),
            g && this.fire("zoomstart"));
            this._zoom = b;
            this._initialCenter = a;
            this._initialTopLeftPoint = this._getNewTopLeftPoint(a);
            c ? this._initialTopLeftPoint._add(this._getMapPanePos()) : d.DomUtil.setPosition(this._mapPane, new d.Point(0,0));
            this._tileLayersToLoad = this._tileLayersNum;
            a = !this._loaded;
            this._loaded = !0;
            a && (this.fire("load"),
            this.eachLayer(this._layerAdd, this));
            this.fire("viewreset", 
            {
                hard: !c
            });
            this.fire("move");
            (g || e) && this.fire("zoomend");
            this.fire("moveend", {
                hard: !c
            })
        },
        _rawPanBy: function(a) {
            d.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(a))
        },
        _getZoomSpan: function() {
            return this.getMaxZoom() - this.getMinZoom()
        },
        _updateZoomLevels: function() {
            var a, b = 1 / 0, d = -1 / 0, e = this._getZoomSpan();
            for (a in this._zoomBoundLayers) {
                var g = this._zoomBoundLayers[a];
                isNaN(g.options.minZoom) || (b = Math.min(b, g.options.minZoom));
                isNaN(g.options.maxZoom) || (d = Math.max(d, g.options.maxZoom))
            }
            a === 
            c ? this._layersMaxZoom = this._layersMinZoom = c : (this._layersMaxZoom = d,
            this._layersMinZoom = b);
            e !== this._getZoomSpan() && this.fire("zoomlevelschange")
        },
        _panInsideMaxBounds: function() {
            this.panInsideBounds(this.options.maxBounds)
        },
        _checkIfLoaded: function() {
            if (!this._loaded)
                throw Error("Set map center and zoom first.");
        },
        _initEvents: function(b) {
            if (d.DomEvent) {
                b = b || "on";
                d.DomEvent[b](this._container, "click", this._onMouseClick, this);
                var c, e, g = "dblclick mousedown mouseup mouseenter mouseleave mousemove contextmenu".split(" ");
                c = 0;
                for (e = g.length; e > c; c++)
                    d.DomEvent[b](this._container, g[c], this._fireMouseEvent, this);
                this.options.trackResize && d.DomEvent[b](a, "resize", this._onResize, this)
            }
        },
        _onResize: function() {
            d.Util.cancelAnimFrame(this._resizeRequest);
            this._resizeRequest = d.Util.requestAnimFrame(function() {
                this.invalidateSize({
                    debounceMoveend: !0
                })
            }
            , this, !1, this._container)
        },
        _onMouseClick: function(a) {
            !this._loaded || !a._simulated && (this.dragging && this.dragging.moved() || this.boxZoom && this.boxZoom.moved()) || d.DomEvent._skipped(a) || 
            (this.fire("preclick"),
            this._fireMouseEvent(a))
        },
        _fireMouseEvent: function(a) {
            if (this._loaded && !d.DomEvent._skipped(a)) {
                var b = a.type;
                if (b = "mouseenter" === b ? "mouseover" : "mouseleave" === b ? "mouseout" : b,
                this.hasEventListeners(b)) {
                    "contextmenu" === b && d.DomEvent.preventDefault(a);
                    var c = this.mouseEventToContainerPoint(a)
                      , e = this.containerPointToLayerPoint(c)
                      , g = this.layerPointToLatLng(e);
                    this.fire(b, {
                        latlng: g,
                        layerPoint: e,
                        containerPoint: c,
                        originalEvent: a
                    })
                }
            }
        },
        _onTileLayerLoad: function() {
            this._tileLayersToLoad--;
            this._tileLayersNum && !this._tileLayersToLoad && this.fire("tilelayersload")
        },
        _clearHandlers: function() {
            for (var a = 0, b = this._handlers.length; b > a; a++)
                this._handlers[a].disable()
        },
        whenReady: function(a, b) {
            return this._loaded ? a.call(b || this, this) : this.on("load", a, b),
            this
        },
        _layerAdd: function(a) {
            a.onAdd(this);
            this.fire("layeradd", {
                layer: a
            })
        },
        _getMapPanePos: function() {
            return d.DomUtil.getPosition(this._mapPane)
        },
        _moved: function() {
            var a = this._getMapPanePos();
            return a && !a.equals([0, 0])
        },
        _getTopLeftPoint: function() {
            return this.getPixelOrigin().subtract(this._getMapPanePos())
        },
        _getNewTopLeftPoint: function(a, b) {
            var c = this.getSize()._divideBy(2);
            return this.project(a, b)._subtract(c)._round()
        },
        _latLngToNewLayerPoint: function(a, b, c) {
            c = this._getNewTopLeftPoint(c, b).add(this._getMapPanePos());
            return this.project(a, b)._subtract(c)
        },
        _getCenterLayerPoint: function() {
            return this.containerPointToLayerPoint(this.getSize()._divideBy(2))
        },
        _getCenterOffset: function(a) {
            return this.latLngToLayerPoint(a).subtract(this._getCenterLayerPoint())
        },
        _limitCenter: function(a, b, c) {
            if (!c)
                return a;
            a = 
            this.project(a, b);
            var e = this.getSize().divideBy(2)
              , e = new d.Bounds(a.subtract(e),a.add(e));
            c = this._getBoundsOffset(e, c, b);
            return this.unproject(a.add(c), b)
        },
        _limitOffset: function(a, b) {
            if (!b)
                return a;
            var c = this.getPixelBounds()
              , c = new d.Bounds(c.min.add(a),c.max.add(a));
            return a.add(this._getBoundsOffset(c, b))
        },
        _getBoundsOffset: function(a, b, c) {
            var e = this.project(b.getNorthWest(), c).subtract(a.min);
            b = this.project(b.getSouthEast(), c).subtract(a.max);
            a = this._rebound(e.x, -b.x);
            e = this._rebound(e.y, -b.y);
            return new d.Point(a,e)
        },
        _rebound: function(a, b) {
            return 0 < a + b ? Math.round(a - b) / 2 : Math.max(0, Math.ceil(a)) - Math.max(0, Math.floor(b))
        },
        _limitZoom: function(a) {
            var b = this.getMinZoom()
              , c = this.getMaxZoom();
            return Math.max(b, Math.min(c, a))
        }
    });
    d.map = function(a, b) {
        return new d.Map(a,b)
    }
    ;
    d.Projection.Mercator = {
        MAX_LATITUDE: 85.0840591556,
        R_MINOR: 6356752.314245179,
        R_MAJOR: 6378137,
        project: function(a) {
            var b = d.LatLng.DEG_TO_RAD
              , c = this.MAX_LATITUDE
              , e = Math.max(Math.min(c, a.lat), -c)
              , c = this.R_MAJOR;
            a = a.lng * b * c;
            var b = 
            e * b
              , e = this.R_MINOR / c
              , e = Math.sqrt(1 - e * e)
              , g = e * Math.sin(b)
              , g = Math.pow((1 - g) / (1 + g), .5 * e)
              , e = Math.tan(.5 * (.5 * Math.PI - b)) / g;
            return b = -c * Math.log(e),
            new d.Point(a,b)
        },
        unproject: function(a) {
            var b, c = d.LatLng.RAD_TO_DEG, e = this.R_MAJOR, g = a.x * c / e, n = this.R_MINOR / e, n = Math.sqrt(1 - n * n);
            a = Math.exp(-a.y / e);
            var e = Math.PI / 2 - 2 * Math.atan(a)
              , p = 15;
            for (b = .1; 1E-7 < Math.abs(b) && 0 < --p; )
                b = n * Math.sin(e),
                b = Math.PI / 2 - 2 * Math.atan(a * Math.pow((1 - b) / (1 + b), .5 * n)) - e,
                e += b;
            return new d.LatLng(e * c,g)
        }
    };
    d.CRS.EPSG3395 = d.extend({}, d.CRS, {
        code: "EPSG:3395",
        projection: d.Projection.Mercator,
        transformation: function() {
            var a = .5 / (Math.PI * d.Projection.Mercator.R_MAJOR);
            return new d.Transformation(a,.5,-a,.5)
        }
        ()
    });
    d.TileLayer = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            minZoom: 0,
            maxZoom: 18,
            tileSize: 256,
            subdomains: "abc",
            errorTileUrl: "",
            attribution: "",
            zoomOffset: 0,
            opacity: 1,
            unloadInvisibleTiles: d.Browser.mobile,
            updateWhenIdle: d.Browser.mobile
        },
        initialize: function(a, b) {
            b = d.setOptions(this, b);
            b.detectRetina && d.Browser.retina && 0 < b.maxZoom && (b.tileSize = Math.floor(b.tileSize / 
            2),
            b.zoomOffset++,
            0 < b.minZoom && b.minZoom--,
            this.options.maxZoom--);
            b.bounds && (b.bounds = d.latLngBounds(b.bounds));
            this._url = a;
            var c = this.options.subdomains;
            "string" == typeof c && (this.options.subdomains = c.split(""))
        },
        onAdd: function(a) {
            this._map = a;
            this._animated = a._zoomAnimated;
            this._initContainer();
            a.on({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            this._animated && a.on({
                zoomanim: this._animateZoom,
                zoomend: this._endZoomAnim
            }, this);
            this.options.updateWhenIdle || (this._limitedUpdate = d.Util.limitExecByInterval(this._update, 
            150, this),
            a.on("move", this._limitedUpdate, this));
            this._reset();
            this._update()
        },
        addTo: function(a) {
            return a.addLayer(this),
            this
        },
        onRemove: function(a) {
            this._container.parentNode.removeChild(this._container);
            a.off({
                viewreset: this._reset,
                moveend: this._update
            }, this);
            this._animated && a.off({
                zoomanim: this._animateZoom,
                zoomend: this._endZoomAnim
            }, this);
            this.options.updateWhenIdle || a.off("move", this._limitedUpdate, this);
            this._map = this._container = null 
        },
        bringToFront: function() {
            var a = this._map._panes.tilePane;
            return this._container && 
            (a.appendChild(this._container),
            this._setAutoZIndex(a, Math.max)),
            this
        },
        bringToBack: function() {
            var a = this._map._panes.tilePane;
            return this._container && (a.insertBefore(this._container, a.firstChild),
            this._setAutoZIndex(a, Math.min)),
            this
        },
        getAttribution: function() {
            return this.options.attribution
        },
        getContainer: function() {
            return this._container
        },
        setOpacity: function(a) {
            return this.options.opacity = a,
            this._map && this._updateOpacity(),
            this
        },
        setZIndex: function(a) {
            return this.options.zIndex = a,
            this._updateZIndex(),
            this
        },
        setUrl: function(a, b) {
            return this._url = a,
            b || this.redraw(),
            this
        },
        redraw: function() {
            return this._map && (this._reset({
                hard: !0
            }),
            this._update()),
            this
        },
        _updateZIndex: function() {
            this._container && this.options.zIndex !== c && (this._container.style.zIndex = this.options.zIndex)
        },
        _setAutoZIndex: function(a, b) {
            var c, d, e, g = a.children, p = -b(1 / 0, -1 / 0);
            d = 0;
            for (e = g.length; e > d; d++)
                g[d] !== this._container && (c = parseInt(g[d].style.zIndex, 10),
                isNaN(c) || (p = b(p, c)));
            this.options.zIndex = this._container.style.zIndex = (isFinite(p) ? 
            p : 0) + b(1, -1)
        },
        _updateOpacity: function() {
            var a, b = this._tiles;
            if (d.Browser.ielt9)
                for (a in b)
                    d.DomUtil.setOpacity(b[a], this.options.opacity);
            else
                d.DomUtil.setOpacity(this._container, this.options.opacity)
        },
        _initContainer: function() {
            var a = this._map._panes.tilePane;
            this._container || ((this._container = d.DomUtil.create("div", "leaflet-layer"),
            this._updateZIndex(),
            this._animated) ? (this._bgBuffer = d.DomUtil.create("div", "leaflet-tile-container", this._container),
            this._tileContainer = d.DomUtil.create("div", "leaflet-tile-container", 
            this._container)) : this._tileContainer = this._container,
            a.appendChild(this._container),
            1 > this.options.opacity && this._updateOpacity())
        },
        _reset: function(a) {
            for (var b in this._tiles)
                this.fire("tileunload", {
                    tile: this._tiles[b]
                });
            this._tiles = {};
            this._tilesToLoad = 0;
            this.options.reuseTiles && (this._unusedTiles = []);
            this._tileContainer.innerHTML = "";
            this._animated && a && a.hard && this._clearBgBuffer();
            this._initContainer()
        },
        _getTileSize: function() {
            var a = this._map
              , b = a.getZoom() + this.options.zoomOffset
              , c = this.options.maxNativeZoom
              , 
            d = this.options.tileSize;
            return c && b > c && (d = Math.round(a.getZoomScale(b) / a.getZoomScale(c) * d)),
            d
        },
        _update: function() {
            if (this._map) {
                var a = this._map
                  , b = a.getPixelBounds()
                  , a = a.getZoom()
                  , c = this._getTileSize();
                a > this.options.maxZoom || a < this.options.minZoom || (b = d.bounds(b.min.divideBy(c)._floor(), b.max.divideBy(c)._floor()),
                this._addTilesFromCenterOut(b),
                (this.options.unloadInvisibleTiles || this.options.reuseTiles) && this._removeOtherTiles(b))
            }
        },
        _addTilesFromCenterOut: function(a) {
            var c, e, g, m = [], n = a.getCenter();
            for (c = a.min.y; c <= a.max.y; c++)
                for (e = a.min.x; e <= a.max.x; e++)
                    g = new d.Point(e,c),
                    this._tileShouldBeLoaded(g) && m.push(g);
            a = m.length;
            if (0 !== a) {
                m.sort(function(a, b) {
                    return a.distanceTo(n) - b.distanceTo(n)
                }
                );
                c = b.createDocumentFragment();
                this._tilesToLoad || this.fire("loading");
                this._tilesToLoad += a;
                for (e = 0; a > e; e++)
                    this._addTile(m[e], c);
                this._tileContainer.appendChild(c)
            }
        },
        _tileShouldBeLoaded: function(a) {
            if (a.x + ":" + a.y in this._tiles)
                return !1;
            var b = this.options;
            if (!b.continuousWorld) {
                var c = this._getWrapTileNum();
                if (b.noWrap && (0 > a.x || a.x >= c.x) || 0 > a.y || a.y >= c.y)
                    return !1
            }
            return b.bounds && (c = b.tileSize,
            a = a.multiplyBy(c),
            c = a.add([c, c]),
            a = this._map.unproject(a),
            c = this._map.unproject(c),
            b.continuousWorld || b.noWrap || (a = a.wrap(),
            c = c.wrap()),
            !b.bounds.intersects([a, c])) ? !1 : !0
        },
        _removeOtherTiles: function(a) {
            var b, c, d;
            for (d in this._tiles)
                b = d.split(":"),
                c = parseInt(b[0], 10),
                b = parseInt(b[1], 10),
                (c < a.min.x || c > a.max.x || b < a.min.y || b > a.max.y) && this._removeTile(d)
        },
        _removeTile: function(a) {
            var b = this._tiles[a];
            this.fire("tileunload", 
            {
                tile: b,
                url: b.src
            });
            this.options.reuseTiles ? (d.DomUtil.removeClass(b, "leaflet-tile-loaded"),
            this._unusedTiles.push(b)) : b.parentNode === this._tileContainer && this._tileContainer.removeChild(b);
            d.Browser.android || (b.onload = null ,
            b.src = d.Util.emptyImageUrl);
            delete this._tiles[a]
        },
        _addTile: function(a, b) {
            var c = this._getTilePos(a)
              , e = this._getTile();
            d.DomUtil.setPosition(e, c, d.Browser.chrome);
            this._tiles[a.x + ":" + a.y] = e;
            this._loadTile(e, a);
            e.parentNode !== this._tileContainer && b.appendChild(e)
        },
        _getZoomForUrl: function() {
            var a = 
            this.options
              , b = this._map.getZoom();
            return a.zoomReverse && (b = a.maxZoom - b),
            b += a.zoomOffset,
            a.maxNativeZoom ? Math.min(b, a.maxNativeZoom) : b
        },
        _getTilePos: function(a) {
            var b = this._map.getPixelOrigin()
              , c = this._getTileSize();
            return a.multiplyBy(c).subtract(b)
        },
        getTileUrl: function(a) {
            return d.Util.template(this._url, d.extend({
                s: this._getSubdomain(a),
                z: a.z,
                x: a.x,
                y: a.y
            }, this.options))
        },
        _getWrapTileNum: function() {
            return this._map.options.crs.getSize(this._map.getZoom()).divideBy(this._getTileSize())._floor()
        },
        _adjustTilePoint: function(a) {
            var b = this._getWrapTileNum();
            this.options.continuousWorld || this.options.noWrap || (a.x = (a.x % b.x + b.x) % b.x);
            this.options.tms && (a.y = b.y - a.y - 1);
            a.z = this._getZoomForUrl()
        },
        _getSubdomain: function(a) {
            a = Math.abs(a.x + a.y) % this.options.subdomains.length;
            return this.options.subdomains[a]
        },
        _getTile: function() {
            if (this.options.reuseTiles && 0 < this._unusedTiles.length) {
                var a = this._unusedTiles.pop();
                return this._resetTile(a),
                a
            }
            return this._createTile()
        },
        _resetTile: function() {},
        _createTile: function() {
            var a = 
            d.DomUtil.create("img", "leaflet-tile");
            return a.style.width = a.style.height = this._getTileSize() + "px",
            a.galleryimg = "no",
            a.onselectstart = a.onmousemove = d.Util.falseFn,
            d.Browser.ielt9 && this.options.opacity !== c && d.DomUtil.setOpacity(a, this.options.opacity),
            d.Browser.mobileWebkit3d && (a.style.WebkitBackfaceVisibility = "hidden"),
            a
        },
        _loadTile: function(a, b) {
            a._layer = this;
            a.onload = this._tileOnLoad;
            a.onerror = this._tileOnError;
            this._adjustTilePoint(b);
            a.src = this.getTileUrl(b);
            this.fire("tileloadstart", {
                tile: a,
                url: a.src
            })
        },
        _tileLoaded: function() {
            this._tilesToLoad--;
            this._animated && d.DomUtil.addClass(this._tileContainer, "leaflet-zoom-animated");
            this._tilesToLoad || (this.fire("load"),
            this._animated && (clearTimeout(this._clearBgBufferTimer),
            this._clearBgBufferTimer = setTimeout(d.bind(this._clearBgBuffer, this), 500)))
        },
        _tileOnLoad: function() {
            var a = this._layer;
            this.src !== d.Util.emptyImageUrl && (d.DomUtil.addClass(this, "leaflet-tile-loaded"),
            a.fire("tileload", {
                tile: this,
                url: this.src
            }));
            a._tileLoaded()
        },
        _tileOnError: function() {
            var a = 
            this._layer;
            a.fire("tileerror", {
                tile: this,
                url: this.src
            });
            var b = a.options.errorTileUrl;
            b && (this.src = b);
            a._tileLoaded()
        }
    });
    d.tileLayer = function(a, b) {
        return new d.TileLayer(a,b)
    }
    ;
    d.TileLayer.WMS = d.TileLayer.extend({
        defaultWmsParams: {
            service: "WMS",
            request: "GetMap",
            version: "1.1.1",
            layers: "",
            styles: "",
            format: "image/jpeg",
            transparent: !1
        },
        initialize: function(a, b) {
            this._url = a;
            var c = d.extend({}, this.defaultWmsParams)
              , e = b.tileSize || this.options.tileSize;
            c.width = c.height = b.detectRetina && d.Browser.retina ? 2 * e : 
            e;
            for (var g in b)
                this.options.hasOwnProperty(g) || "crs" === g || (c[g] = b[g]);
            this.wmsParams = c;
            d.setOptions(this, b)
        },
        onAdd: function(a) {
            this._crs = this.options.crs || a.options.crs;
            this._wmsVersion = parseFloat(this.wmsParams.version);
            this.wmsParams[1.3 <= this._wmsVersion ? "crs" : "srs"] = this._crs.code;
            d.TileLayer.prototype.onAdd.call(this, a)
        },
        getTileUrl: function(a) {
            var b = this._map
              , c = this.options.tileSize
              , e = a.multiplyBy(c)
              , c = e.add([c, c])
              , e = this._crs.project(b.unproject(e, a.z))
              , b = this._crs.project(b.unproject(c, a.z))
              , 
            b = 1.3 <= this._wmsVersion && this._crs === d.CRS.EPSG4326 ? [b.y, e.x, e.y, b.x].join() : [e.x, b.y, b.x, e.y].join();
            a = d.Util.template(this._url, {
                s: this._getSubdomain(a)
            });
            return a + d.Util.getParamString(this.wmsParams, a, !0) + "&BBOX=" + b
        },
        setParams: function(a, b) {
            return d.extend(this.wmsParams, a),
            b || this.redraw(),
            this
        }
    });
    d.tileLayer.wms = function(a, b) {
        return new d.TileLayer.WMS(a,b)
    }
    ;
    d.TileLayer.Canvas = d.TileLayer.extend({
        options: {
            async: !1
        },
        initialize: function(a) {
            d.setOptions(this, a)
        },
        redraw: function() {
            this._map && (this._reset({
                hard: !0
            }),
            this._update());
            for (var a in this._tiles)
                this._redrawTile(this._tiles[a]);
            return this
        },
        _redrawTile: function(a) {
            this.drawTile(a, a._tilePoint, this._map._zoom)
        },
        _createTile: function() {
            var a = d.DomUtil.create("canvas", "leaflet-tile");
            return a.width = a.height = this.options.tileSize,
            a.onselectstart = a.onmousemove = d.Util.falseFn,
            a
        },
        _loadTile: function(a, b) {
            a._layer = this;
            a._tilePoint = b;
            this._redrawTile(a);
            this.options.async || this.tileDrawn(a)
        },
        drawTile: function() {},
        tileDrawn: function(a) {
            this._tileOnLoad.call(a)
        }
    });
    d.tileLayer.canvas = function(a) {
        return new d.TileLayer.Canvas(a)
    }
    ;
    d.ImageOverlay = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            opacity: 1
        },
        initialize: function(a, b, c) {
            this._url = a;
            this._bounds = d.latLngBounds(b);
            d.setOptions(this, c)
        },
        onAdd: function(a) {
            this._map = a;
            this._image || this._initImage();
            a._panes.overlayPane.appendChild(this._image);
            a.on("viewreset", this._reset, this);
            a.options.zoomAnimation && d.Browser.any3d && a.on("zoomanim", this._animateZoom, this);
            this._reset()
        },
        onRemove: function(a) {
            a.getPanes().overlayPane.removeChild(this._image);
            a.off("viewreset", this._reset, this);
            a.options.zoomAnimation && a.off("zoomanim", this._animateZoom, this)
        },
        addTo: function(a) {
            return a.addLayer(this),
            this
        },
        setOpacity: function(a) {
            return this.options.opacity = a,
            this._updateOpacity(),
            this
        },
        bringToFront: function() {
            return this._image && this._map._panes.overlayPane.appendChild(this._image),
            this
        },
        bringToBack: function() {
            var a = this._map._panes.overlayPane;
            return this._image && a.insertBefore(this._image, a.firstChild),
            this
        },
        setUrl: function(a) {
            this._url = a;
            this._image.src = 
            this._url
        },
        getAttribution: function() {
            return this.options.attribution
        },
        _initImage: function() {
            this._image = d.DomUtil.create("img", "leaflet-image-layer");
            this._map.options.zoomAnimation && d.Browser.any3d ? d.DomUtil.addClass(this._image, "leaflet-zoom-animated") : d.DomUtil.addClass(this._image, "leaflet-zoom-hide");
            this._updateOpacity();
            d.extend(this._image, {
                galleryimg: "no",
                onselectstart: d.Util.falseFn,
                onmousemove: d.Util.falseFn,
                onload: d.bind(this._onImageLoad, this),
                src: this._url
            })
        },
        _animateZoom: function(a) {
            var b = 
            this._map
              , c = this._image
              , e = b.getZoomScale(a.zoom)
              , g = this._bounds.getNorthWest()
              , n = this._bounds.getSouthEast()
              , g = b._latLngToNewLayerPoint(g, a.zoom, a.center);
            a = b._latLngToNewLayerPoint(n, a.zoom, a.center)._subtract(g);
            a = g._add(a._multiplyBy(.5 * (1 - 1 / e)));
            c.style[d.DomUtil.TRANSFORM] = d.DomUtil.getTranslateString(a) + " scale(" + e + ") "
        },
        _reset: function() {
            var a = this._image
              , b = this._map.latLngToLayerPoint(this._bounds.getNorthWest())
              , c = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(b);
            d.DomUtil.setPosition(a, 
            b);
            a.style.width = c.x + "px";
            a.style.height = c.y + "px"
        },
        _onImageLoad: function() {
            this.fire("load")
        },
        _updateOpacity: function() {
            d.DomUtil.setOpacity(this._image, this.options.opacity)
        }
    });
    d.imageOverlay = function(a, b, c) {
        return new d.ImageOverlay(a,b,c)
    }
    ;
    d.Icon = d.Class.extend({
        options: {
            className: ""
        },
        initialize: function(a) {
            d.setOptions(this, a)
        },
        createIcon: function(a) {
            return this._createIcon("icon", a)
        },
        createShadow: function(a) {
            return this._createIcon("shadow", a)
        },
        _createIcon: function(a, b) {
            var c = this._getIconUrl(a);
            if (!c) {
                if ("icon" === a)
                    throw Error("iconUrl not set in Icon options (see the docs).");
                return null 
            }
            var d;
            return d = b && "IMG" === b.tagName ? this._createImg(c, b) : this._createImg(c),
            this._setIconStyles(d, a),
            d
        },
        _setIconStyles: function(a, b) {
            var c, e = this.options, g = d.point(e[b + "Size"]);
            c = d.point("shadow" === b ? e.shadowAnchor || e.iconAnchor : e.iconAnchor);
            !c && g && (c = g.divideBy(2, !0));
            a.className = "leaflet-marker-" + b + " " + e.className;
            c && (a.style.marginLeft = -c.x + "px",
            a.style.marginTop = -c.y + "px");
            g && (a.style.width = g.x + "px",
            a.style.height = g.y + "px")
        },
        _createImg: function(a, c) {
            return c = c || b.createElement("img"),
            c.src = a,
            c
        },
        _getIconUrl: function(a) {
            return d.Browser.retina && this.options[a + "RetinaUrl"] ? this.options[a + "RetinaUrl"] : this.options[a + "Url"]
        }
    });
    d.icon = function(a) {
        return new d.Icon(a)
    }
    ;
    d.Icon.Default = d.Icon.extend({
        options: {
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        },
        _getIconUrl: function(a) {
            var b = a + "Url";
            if (this.options[b])
                return this.options[b];
            d.Browser.retina && "icon" === a && (a += "-2x");
            b = d.Icon.Default.imagePath;
            if (!b)
                throw Error("Couldn't autodetect L.Icon.Default.imagePath, set it manually.");
            return b + "/marker-" + a + ".png"
        }
    });
    d.Icon.Default.imagePath = function() {
        var a, c, d, e, g = b.getElementsByTagName("script"), n = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;
        a = 0;
        for (c = g.length; c > a; a++)
            if (d = g[a].src,
            d.match(n))
                return e = d.split(n)[0],
                (e ? e + "/" : "") + "images"
    }
    ();
    d.Marker = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            icon: new d.Icon.Default,
            title: "",
            alt: "",
            clickable: !0,
            draggable: !1,
            keyboard: !0,
            zIndexOffset: 0,
            opacity: 1,
            riseOnHover: !1,
            riseOffset: 250
        },
        initialize: function(a, b) {
            d.setOptions(this, b);
            this._latlng = d.latLng(a)
        },
        onAdd: function(a) {
            this._map = a;
            a.on("viewreset", this.update, this);
            this._initIcon();
            this.update();
            this.fire("add");
            a.options.zoomAnimation && a.options.markerZoomAnimation && a.on("zoomanim", this._animateZoom, this)
        },
        addTo: function(a) {
            return a.addLayer(this),
            this
        },
        onRemove: function(a) {
            this.dragging && this.dragging.disable();
            this._removeIcon();
            this._removeShadow();
            this.fire("remove");
            a.off({
                viewreset: this.update,
                zoomanim: this._animateZoom
            }, this);
            this._map = null 
        },
        getLatLng: function() {
            return this._latlng
        },
        setLatLng: function(a) {
            return this._latlng = d.latLng(a),
            this.update(),
            this.fire("move", {
                latlng: this._latlng
            })
        },
        setZIndexOffset: function(a) {
            return this.options.zIndexOffset = a,
            this.update(),
            this
        },
        setIcon: function(a) {
            return this.options.icon = a,
            this._map && (this._initIcon(),
            this.update()),
            this._popup && this.bindPopup(this._popup),
            this
        },
        update: function() {
            if (this._icon) {
                var a = this._map.latLngToLayerPoint(this._latlng).round();
                this._setPos(a)
            }
            return this
        },
        _initIcon: function() {
            var a = this.options
              , b = this._map
              , c = b.options.zoomAnimation && b.options.markerZoomAnimation ? "leaflet-zoom-animated" : "leaflet-zoom-hide"
              , e = a.icon.createIcon(this._icon)
              , b = !1;
            e !== this._icon && (this._icon && this._removeIcon(),
            b = !0,
            a.title && (e.title = a.title),
            a.alt && (e.alt = a.alt));
            d.DomUtil.addClass(e, c);
            a.keyboard && (e.tabIndex = "0");
            this._icon = e;
            this._initInteraction();
            a.riseOnHover && d.DomEvent.on(e, "mouseover", this._bringToFront, this).on(e, "mouseout", this._resetZIndex, 
            this);
            var e = a.icon.createShadow(this._shadow)
              , g = !1;
            e !== this._shadow && (this._removeShadow(),
            g = !0);
            e && d.DomUtil.addClass(e, c);
            this._shadow = e;
            1 > a.opacity && this._updateOpacity();
            a = this._map._panes;
            b && a.markerPane.appendChild(this._icon);
            e && g && a.shadowPane.appendChild(this._shadow)
        },
        _removeIcon: function() {
            this.options.riseOnHover && d.DomEvent.off(this._icon, "mouseover", this._bringToFront).off(this._icon, "mouseout", this._resetZIndex);
            this._map._panes.markerPane.removeChild(this._icon);
            this._icon = null 
        },
        _removeShadow: function() {
            this._shadow && 
            this._map._panes.shadowPane.removeChild(this._shadow);
            this._shadow = null 
        },
        _setPos: function(a) {
            d.DomUtil.setPosition(this._icon, a);
            this._shadow && d.DomUtil.setPosition(this._shadow, a);
            this._zIndex = a.y + this.options.zIndexOffset;
            this._resetZIndex()
        },
        _updateZIndex: function(a) {
            this._icon.style.zIndex = this._zIndex + a
        },
        _animateZoom: function(a) {
            a = this._map._latLngToNewLayerPoint(this._latlng, a.zoom, a.center).round();
            this._setPos(a)
        },
        _initInteraction: function() {
            if (this.options.clickable) {
                var a = this._icon
                  , b = ["dblclick", 
                "mousedown", "mouseover", "mouseout", "contextmenu"];
                d.DomUtil.addClass(a, "leaflet-clickable");
                d.DomEvent.on(a, "click", this._onMouseClick, this);
                d.DomEvent.on(a, "keypress", this._onKeyPress, this);
                for (var c = 0; c < b.length; c++)
                    d.DomEvent.on(a, b[c], this._fireMouseEvent, this);
                d.Handler.MarkerDrag && (this.dragging = new d.Handler.MarkerDrag(this),
                this.options.draggable && this.dragging.enable())
            }
        },
        _onMouseClick: function(a) {
            var b = this.dragging && this.dragging.moved();
            (this.hasEventListeners(a.type) || b) && d.DomEvent.stopPropagation(a);
            b || (this.dragging && this.dragging._enabled || !this._map.dragging || !this._map.dragging.moved()) && this.fire(a.type, {
                originalEvent: a,
                latlng: this._latlng
            })
        },
        _onKeyPress: function(a) {
            13 === a.keyCode && this.fire("click", {
                originalEvent: a,
                latlng: this._latlng
            })
        },
        _fireMouseEvent: function(a) {
            this.fire(a.type, {
                originalEvent: a,
                latlng: this._latlng
            });
            "contextmenu" === a.type && this.hasEventListeners(a.type) && d.DomEvent.preventDefault(a);
            "mousedown" !== a.type ? d.DomEvent.stopPropagation(a) : d.DomEvent.preventDefault(a)
        },
        setOpacity: function(a) {
            return this.options.opacity = 
            a,
            this._map && this._updateOpacity(),
            this
        },
        _updateOpacity: function() {
            d.DomUtil.setOpacity(this._icon, this.options.opacity);
            this._shadow && d.DomUtil.setOpacity(this._shadow, this.options.opacity)
        },
        _bringToFront: function() {
            this._updateZIndex(this.options.riseOffset)
        },
        _resetZIndex: function() {
            this._updateZIndex(0)
        }
    });
    d.marker = function(a, b) {
        return new d.Marker(a,b)
    }
    ;
    d.DivIcon = d.Icon.extend({
        options: {
            iconSize: [12, 12],
            className: "leaflet-div-icon",
            html: !1
        },
        createIcon: function(a) {
            a = a && "DIV" === a.tagName ? a : b.createElement("div");
            var c = this.options;
            return a.innerHTML = !1 !== c.html ? c.html : "",
            c.bgPos && (a.style.backgroundPosition = -c.bgPos.x + "px " + -c.bgPos.y + "px"),
            this._setIconStyles(a, "icon"),
            a
        },
        createShadow: function() {
            return null 
        }
    });
    d.divIcon = function(a) {
        return new d.DivIcon(a)
    }
    ;
    d.Map.mergeOptions({
        closePopupOnClick: !0
    });
    d.Popup = d.Class.extend({
        includes: d.Mixin.Events,
        options: {
            minWidth: 50,
            maxWidth: 300,
            autoPan: !0,
            closeButton: !0,
            offset: [0, 7],
            autoPanPadding: [5, 5],
            keepInView: !1,
            className: "",
            zoomAnimation: !0
        },
        initialize: function(a, 
        b) {
            d.setOptions(this, a);
            this._source = b;
            this._animated = d.Browser.any3d && this.options.zoomAnimation;
            this._isOpen = !1
        },
        onAdd: function(a) {
            this._map = a;
            this._container || this._initLayout();
            var b = a.options.fadeAnimation;
            b && d.DomUtil.setOpacity(this._container, 0);
            a._panes.popupPane.appendChild(this._container);
            a.on(this._getEvents(), this);
            this.update();
            b && d.DomUtil.setOpacity(this._container, 1);
            this.fire("open");
            a.fire("popupopen", {
                popup: this
            });
            this._source && this._source.fire("popupopen", {
                popup: this
            })
        },
        addTo: function(a) {
            return a.addLayer(this),
            this
        },
        openOn: function(a) {
            return a.openPopup(this),
            this
        },
        onRemove: function(a) {
            a._panes.popupPane.removeChild(this._container);
            d.Util.falseFn(this._container.offsetWidth);
            a.off(this._getEvents(), this);
            a.options.fadeAnimation && d.DomUtil.setOpacity(this._container, 0);
            this._map = null ;
            this.fire("close");
            a.fire("popupclose", {
                popup: this
            });
            this._source && this._source.fire("popupclose", {
                popup: this
            })
        },
        getLatLng: function() {
            return this._latlng
        },
        setLatLng: function(a) {
            return this._latlng = d.latLng(a),
            this._map && (this._updatePosition(),
            this._adjustPan()),
            this
        },
        getContent: function() {
            return this._content
        },
        setContent: function(a) {
            return this._content = a,
            this.update(),
            this
        },
        update: function() {
            this._map && (this._container.style.visibility = "hidden",
            this._updateContent(),
            this._updateLayout(),
            this._updatePosition(),
            this._container.style.visibility = "",
            this._adjustPan())
        },
        _getEvents: function() {
            var a = {
                viewreset: this._updatePosition
            };
            return this._animated && (a.zoomanim = this._zoomAnimation),
            ("closeOnClick" in this.options ? this.options.closeOnClick : 
            this._map.options.closePopupOnClick) && (a.preclick = this._close),
            this.options.keepInView && (a.moveend = this._adjustPan),
            a
        },
        _close: function() {
            this._map && this._map.closePopup(this)
        },
        _initLayout: function() {
            var a, b = this._container = d.DomUtil.create("div", "leaflet-popup " + this.options.className + " leaflet-zoom-" + (this._animated ? "animated" : "hide"));
            this.options.closeButton && (a = this._closeButton = d.DomUtil.create("a", "leaflet-popup-close-button", b),
            a.href = "#close",
            a.innerHTML = "&#215;",
            d.DomEvent.disableClickPropagation(a),
            d.DomEvent.on(a, "click", this._onCloseButtonClick, this));
            a = this._wrapper = d.DomUtil.create("div", "leaflet-popup-content-wrapper", b);
            d.DomEvent.disableClickPropagation(a);
            this._contentNode = d.DomUtil.create("div", "leaflet-popup-content", a);
            d.DomEvent.disableScrollPropagation(this._contentNode);
            d.DomEvent.on(a, "contextmenu", d.DomEvent.stopPropagation);
            this._tipContainer = d.DomUtil.create("div", "leaflet-popup-tip-container", b);
            this._tip = d.DomUtil.create("div", "leaflet-popup-tip", this._tipContainer)
        },
        _updateContent: function() {
            if (this._content) {
                if ("string" == 
                typeof this._content)
                    this._contentNode.innerHTML = this._content;
                else {
                    for (; this._contentNode.hasChildNodes(); )
                        this._contentNode.removeChild(this._contentNode.firstChild);
                    this._contentNode.appendChild(this._content)
                }
                this.fire("contentupdate")
            }
        },
        _updateLayout: function() {
            var a = this._contentNode
              , b = a.style;
            b.width = "";
            b.whiteSpace = "nowrap";
            var c = a.offsetWidth
              , c = Math.min(c, this.options.maxWidth)
              , c = Math.max(c, this.options.minWidth);
            b.width = c + 1 + "px";
            b.whiteSpace = "";
            b.height = "";
            var c = a.offsetHeight
              , e = this.options.maxHeight;
            e && c > e ? (b.height = e + "px",
            d.DomUtil.addClass(a, "leaflet-popup-scrolled")) : d.DomUtil.removeClass(a, "leaflet-popup-scrolled");
            this._containerWidth = this._container.offsetWidth
        },
        _updatePosition: function() {
            if (this._map) {
                var a = this._map.latLngToLayerPoint(this._latlng)
                  , b = this._animated
                  , c = d.point(this.options.offset);
                b && d.DomUtil.setPosition(this._container, a);
                this._containerBottom = -c.y - (b ? 0 : a.y);
                this._containerLeft = -Math.round(this._containerWidth / 2) + c.x + (b ? 0 : a.x);
                this._container.style.bottom = this._containerBottom + 
                "px";
                this._container.style.left = this._containerLeft + "px"
            }
        },
        _zoomAnimation: function(a) {
            a = this._map._latLngToNewLayerPoint(this._latlng, a.zoom, a.center);
            d.DomUtil.setPosition(this._container, a)
        },
        _adjustPan: function() {
            if (this.options.autoPan) {
                var a = this._map
                  , b = this._container.offsetHeight
                  , c = this._containerWidth
                  , e = new d.Point(this._containerLeft,-b - this._containerBottom);
                this._animated && e._add(d.DomUtil.getPosition(this._container));
                var e = a.layerPointToContainerPoint(e)
                  , g = d.point(this.options.autoPanPadding)
                  , 
                n = d.point(this.options.autoPanPaddingTopLeft || g)
                  , g = d.point(this.options.autoPanPaddingBottomRight || g)
                  , p = a.getSize()
                  , t = 0
                  , v = 0;
                e.x + c + g.x > p.x && (t = e.x + c - p.x + g.x);
                0 > e.x - t - n.x && (t = e.x - n.x);
                e.y + b + g.y > p.y && (v = e.y + b - p.y + g.y);
                0 > e.y - v - n.y && (v = e.y - n.y);
                (t || v) && a.fire("autopanstart").panBy([t, v])
            }
        },
        _onCloseButtonClick: function(a) {
            this._close();
            d.DomEvent.stop(a)
        }
    });
    d.popup = function(a, b) {
        return new d.Popup(a,b)
    }
    ;
    d.Map.include({
        openPopup: function(a, b, c) {
            (this.closePopup(),
            a instanceof d.Popup) || (a = (new d.Popup(c)).setLatLng(b).setContent(a));
            return a._isOpen = !0,
            this._popup = a,
            this.addLayer(a)
        },
        closePopup: function(a) {
            return a && a !== this._popup || (a = this._popup,
            this._popup = null ),
            a && (this.removeLayer(a),
            a._isOpen = !1),
            this
        }
    });
    d.Marker.include({
        openPopup: function() {
            return this._popup && this._map && !this._map.hasLayer(this._popup) && (this._popup.setLatLng(this._latlng),
            this._map.openPopup(this._popup)),
            this
        },
        closePopup: function() {
            return this._popup && this._popup._close(),
            this
        },
        togglePopup: function() {
            return this._popup && (this._popup._isOpen ? this.closePopup() : 
            this.openPopup()),
            this
        },
        bindPopup: function(a, b) {
            var c = d.point(this.options.icon.options.popupAnchor || [0, 0]);
            return c = c.add(d.Popup.prototype.options.offset),
            b && b.offset && (c = c.add(b.offset)),
            b = d.extend({
                offset: c
            }, b),
            this._popupHandlersAdded || (this.on("click", this.togglePopup, this).on("remove", this.closePopup, this).on("move", this._movePopup, this),
            this._popupHandlersAdded = !0),
            a instanceof d.Popup ? (d.setOptions(a, b),
            this._popup = a) : this._popup = (new d.Popup(b,this)).setContent(a),
            this
        },
        setPopupContent: function(a) {
            return this._popup && 
            this._popup.setContent(a),
            this
        },
        unbindPopup: function() {
            return this._popup && (this._popup = null ,
            this.off("click", this.togglePopup, this).off("remove", this.closePopup, this).off("move", this._movePopup, this),
            this._popupHandlersAdded = !1),
            this
        },
        getPopup: function() {
            return this._popup
        },
        _movePopup: function(a) {
            this._popup.setLatLng(a.latlng)
        }
    });
    d.LayerGroup = d.Class.extend({
        initialize: function(a) {
            this._layers = {};
            var b, c;
            if (a)
                for (b = 0,
                c = a.length; c > b; b++)
                    this.addLayer(a[b])
        },
        addLayer: function(a) {
            var b = this.getLayerId(a);
            return this._layers[b] = a,
            this._map && this._map.addLayer(a),
            this
        },
        removeLayer: function(a) {
            a = a in this._layers ? a : this.getLayerId(a);
            return this._map && this._layers[a] && this._map.removeLayer(this._layers[a]),
            delete this._layers[a],
            this
        },
        hasLayer: function(a) {
            return a ? a in this._layers || this.getLayerId(a) in this._layers : !1
        },
        clearLayers: function() {
            return this.eachLayer(this.removeLayer, this),
            this
        },
        invoke: function(a) {
            var b, c, d = Array.prototype.slice.call(arguments, 1);
            for (b in this._layers)
                c = this._layers[b],
                c[a] && c[a].apply(c, d);
            return this
        },
        onAdd: function(a) {
            this._map = a;
            this.eachLayer(a.addLayer, a)
        },
        onRemove: function(a) {
            this.eachLayer(a.removeLayer, a);
            this._map = null 
        },
        addTo: function(a) {
            return a.addLayer(this),
            this
        },
        eachLayer: function(a, b) {
            for (var c in this._layers)
                a.call(b, this._layers[c]);
            return this
        },
        getLayer: function(a) {
            return this._layers[a]
        },
        getLayers: function() {
            var a = [], b;
            for (b in this._layers)
                a.push(this._layers[b]);
            return a
        },
        setZIndex: function(a) {
            return this.invoke("setZIndex", a)
        },
        getLayerId: function(a) {
            return d.stamp(a)
        }
    });
    d.layerGroup = function(a) {
        return new d.LayerGroup(a)
    }
    ;
    d.FeatureGroup = d.LayerGroup.extend({
        includes: d.Mixin.Events,
        statics: {
            EVENTS: "click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose"
        },
        addLayer: function(a) {
            return this.hasLayer(a) ? this : ("on" in a && a.on(d.FeatureGroup.EVENTS, this._propagateEvent, this),
            d.LayerGroup.prototype.addLayer.call(this, a),
            this._popupContent && a.bindPopup && a.bindPopup(this._popupContent, this._popupOptions),
            this.fire("layeradd", {
                layer: a
            }))
        },
        removeLayer: function(a) {
            return this.hasLayer(a) ? 
            (a in this._layers && (a = this._layers[a]),
            a.off(d.FeatureGroup.EVENTS, this._propagateEvent, this),
            d.LayerGroup.prototype.removeLayer.call(this, a),
            this._popupContent && this.invoke("unbindPopup"),
            this.fire("layerremove", {
                layer: a
            })) : this
        },
        bindPopup: function(a, b) {
            return this._popupContent = a,
            this._popupOptions = b,
            this.invoke("bindPopup", a, b)
        },
        openPopup: function(a) {
            for (var b in this._layers) {
                this._layers[b].openPopup(a);
                break
            }
            return this
        },
        setStyle: function(a) {
            return this.invoke("setStyle", a)
        },
        bringToFront: function() {
            return this.invoke("bringToFront")
        },
        bringToBack: function() {
            return this.invoke("bringToBack")
        },
        getBounds: function() {
            var a = new d.LatLngBounds;
            return this.eachLayer(function(b) {
                a.extend(b instanceof d.Marker ? b.getLatLng() : b.getBounds())
            }
            ),
            a
        },
        _propagateEvent: function(a) {
            a = d.extend({
                layer: a.target,
                target: this
            }, a);
            this.fire(a.type, a)
        }
    });
    d.featureGroup = function(a) {
        return new d.FeatureGroup(a)
    }
    ;
    d.Path = d.Class.extend({
        includes: [d.Mixin.Events],
        statics: {
            CLIP_PADDING: function() {
                var b = ((d.Browser.mobile ? 1280 : 2E3) / Math.max(a.outerWidth, a.outerHeight) - 
                1) / 2;
                return Math.max(0, Math.min(.5, b))
            }
            ()
        },
        options: {
            stroke: !0,
            color: "#0033ff",
            dashArray: null ,
            lineCap: null ,
            lineJoin: null ,
            weight: 5,
            opacity: .5,
            fill: !1,
            fillColor: null ,
            fillOpacity: .2,
            clickable: !0
        },
        initialize: function(a) {
            d.setOptions(this, a)
        },
        onAdd: function(a) {
            this._map = a;
            this._container || (this._initElements(),
            this._initEvents());
            this.projectLatlngs();
            this._updatePath();
            this._container && this._map._pathRoot.appendChild(this._container);
            this.fire("add");
            a.on({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, 
            this)
        },
        addTo: function(a) {
            return a.addLayer(this),
            this
        },
        onRemove: function(a) {
            a._pathRoot.removeChild(this._container);
            this.fire("remove");
            this._map = null ;
            d.Browser.vml && (this._container = null ,
            this._stroke = null ,
            this._fill = null );
            a.off({
                viewreset: this.projectLatlngs,
                moveend: this._updatePath
            }, this)
        },
        projectLatlngs: function() {},
        setStyle: function(a) {
            return d.setOptions(this, a),
            this._container && this._updateStyle(),
            this
        },
        redraw: function() {
            return this._map && (this.projectLatlngs(),
            this._updatePath()),
            this
        }
    });
    d.Map.include({
        _updatePathViewport: function() {
            var a = d.Path.CLIP_PADDING
              , b = this.getSize()
              , c = d.DomUtil.getPosition(this._mapPane).multiplyBy(-1)._subtract(b.multiplyBy(a)._round())
              , a = c.add(b.multiplyBy(1 + 2 * a)._round());
            this._pathViewport = new d.Bounds(c,a)
        }
    });
    d.Path.SVG_NS = "http://www.w3.org/2000/svg";
    d.Browser.svg = !(!b.createElementNS || !b.createElementNS(d.Path.SVG_NS, "svg").createSVGRect);
    d.Path = d.Path.extend({
        statics: {
            SVG: d.Browser.svg
        },
        bringToFront: function() {
            var a = this._map._pathRoot
              , b = this._container;
            return b && a.lastChild !== b && a.appendChild(b),
            this
        },
        bringToBack: function() {
            var a = this._map._pathRoot
              , b = this._container
              , c = a.firstChild;
            return b && c !== b && a.insertBefore(b, c),
            this
        },
        getPathString: function() {},
        _createElement: function(a) {
            return b.createElementNS(d.Path.SVG_NS, a)
        },
        _initElements: function() {
            this._map._initPathRoot();
            this._initPath();
            this._initStyle()
        },
        _initPath: function() {
            this._container = this._createElement("g");
            this._path = this._createElement("path");
            this.options.className && d.DomUtil.addClass(this._path, 
            this.options.className);
            this._container.appendChild(this._path)
        },
        _initStyle: function() {
            this.options.stroke && (this._path.setAttribute("stroke-linejoin", "round"),
            this._path.setAttribute("stroke-linecap", "round"));
            this.options.fill && this._path.setAttribute("fill-rule", "evenodd");
            this.options.pointerEvents && this._path.setAttribute("pointer-events", this.options.pointerEvents);
            this.options.clickable || this.options.pointerEvents || this._path.setAttribute("pointer-events", "none");
            this._updateStyle()
        },
        _updateStyle: function() {
            this.options.stroke ? 
            (this._path.setAttribute("stroke", this.options.color),
            this._path.setAttribute("stroke-opacity", this.options.opacity),
            this._path.setAttribute("stroke-width", this.options.weight),
            this.options.dashArray ? this._path.setAttribute("stroke-dasharray", this.options.dashArray) : this._path.removeAttribute("stroke-dasharray"),
            this.options.lineCap && this._path.setAttribute("stroke-linecap", this.options.lineCap),
            this.options.lineJoin && this._path.setAttribute("stroke-linejoin", this.options.lineJoin)) : this._path.setAttribute("stroke", 
            "none");
            this.options.fill ? (this._path.setAttribute("fill", this.options.fillColor || this.options.color),
            this._path.setAttribute("fill-opacity", this.options.fillOpacity)) : this._path.setAttribute("fill", "none")
        },
        _updatePath: function() {
            var a = this.getPathString();
            a || (a = "M0 0");
            this._path.setAttribute("d", a)
        },
        _initEvents: function() {
            if (this.options.clickable) {
                !d.Browser.svg && d.Browser.vml || d.DomUtil.addClass(this._path, "leaflet-clickable");
                d.DomEvent.on(this._container, "click", this._onMouseClick, this);
                for (var a = 
                "dblclick mousedown mouseover mouseout mousemove contextmenu".split(" "), b = 0; b < a.length; b++)
                    d.DomEvent.on(this._container, a[b], this._fireMouseEvent, this)
            }
        },
        _onMouseClick: function(a) {
            this._map.dragging && this._map.dragging.moved() || this._fireMouseEvent(a)
        },
        _fireMouseEvent: function(a) {
            if (this.hasEventListeners(a.type)) {
                var b = this._map
                  , c = b.mouseEventToContainerPoint(a)
                  , e = b.containerPointToLayerPoint(c)
                  , b = b.layerPointToLatLng(e);
                this.fire(a.type, {
                    latlng: b,
                    layerPoint: e,
                    containerPoint: c,
                    originalEvent: a
                });
                "contextmenu" === a.type && d.DomEvent.preventDefault(a);
                "mousemove" !== a.type && d.DomEvent.stopPropagation(a)
            }
        }
    });
    d.Map.include({
        _initPathRoot: function() {
            this._pathRoot || (this._pathRoot = d.Path.prototype._createElement("svg"),
            this._panes.overlayPane.appendChild(this._pathRoot),
            this.options.zoomAnimation && d.Browser.any3d ? (d.DomUtil.addClass(this._pathRoot, "leaflet-zoom-animated"),
            this.on({
                zoomanim: this._animatePathZoom,
                zoomend: this._endPathZoom
            })) : d.DomUtil.addClass(this._pathRoot, "leaflet-zoom-hide"),
            this.on("moveend", 
            this._updateSvgViewport),
            this._updateSvgViewport())
        },
        _animatePathZoom: function(a) {
            var b = this.getZoomScale(a.zoom);
            a = this._getCenterOffset(a.center)._multiplyBy(-b)._add(this._pathViewport.min);
            this._pathRoot.style[d.DomUtil.TRANSFORM] = d.DomUtil.getTranslateString(a) + " scale(" + b + ") ";
            this._pathZooming = !0
        },
        _endPathZoom: function() {
            this._pathZooming = !1
        },
        _updateSvgViewport: function() {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var a = this._pathViewport
                  , b = a.min
                  , c = a.max
                  , a = c.x - b.x
                  , c = c.y - b.y
                  , e = this._pathRoot
                  , 
                g = this._panes.overlayPane;
                d.Browser.mobileWebkit && g.removeChild(e);
                d.DomUtil.setPosition(e, b);
                e.setAttribute("width", a);
                e.setAttribute("height", c);
                e.setAttribute("viewBox", [b.x, b.y, a, c].join(" "));
                d.Browser.mobileWebkit && g.appendChild(e)
            }
        }
    });
    d.Path.include({
        bindPopup: function(a, b) {
            return a instanceof d.Popup ? this._popup = a : ((!this._popup || b) && (this._popup = new d.Popup(b,this)),
            this._popup.setContent(a)),
            this._popupHandlersAdded || (this.on("click", this._openPopup, this).on("remove", this.closePopup, this),
            this._popupHandlersAdded = !0),
            this
        },
        unbindPopup: function() {
            return this._popup && (this._popup = null ,
            this.off("click", this._openPopup).off("remove", this.closePopup),
            this._popupHandlersAdded = !1),
            this
        },
        openPopup: function(a) {
            return this._popup && (a = a || this._latlng || this._latlngs[Math.floor(this._latlngs.length / 2)],
            this._openPopup({
                latlng: a
            })),
            this
        },
        closePopup: function() {
            return this._popup && this._popup._close(),
            this
        },
        _openPopup: function(a) {
            this._popup.setLatLng(a.latlng);
            this._map.openPopup(this._popup)
        }
    });
    d.Browser.vml = !d.Browser.svg && function() {
        try {
            var a = b.createElement("div");
            a.innerHTML = '<v:shape adj="1"/>';
            var c = a.firstChild;
            return c.style.behavior = "url(#default#VML)",
            c && "object" == typeof c.adj
        } catch (d) {
            return !1
        }
    }
    ();
    d.Path = d.Browser.svg || !d.Browser.vml ? d.Path : d.Path.extend({
        statics: {
            VML: !0,
            CLIP_PADDING: .02
        },
        _createElement: function() {
            try {
                return b.namespaces.add("lvml", "urn:schemas-microsoft-com:vml"),
                function(a) {
                    return b.createElement("<lvml:" + a + ' class="lvml">')
                }
            } catch (a) {
                return function(a) {
                    return b.createElement("<" + 
                    a + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">')
                }
            }
        }
        (),
        _initPath: function() {
            var a = this._container = this._createElement("shape");
            d.DomUtil.addClass(a, "leaflet-vml-shape" + (this.options.className ? " " + this.options.className : ""));
            this.options.clickable && d.DomUtil.addClass(a, "leaflet-clickable");
            a.coordsize = "1 1";
            this._path = this._createElement("path");
            a.appendChild(this._path);
            this._map._pathRoot.appendChild(a)
        },
        _initStyle: function() {
            this._updateStyle()
        },
        _updateStyle: function() {
            var a = this._stroke
              , 
            b = this._fill
              , c = this.options
              , e = this._container;
            e.stroked = c.stroke;
            e.filled = c.fill;
            c.stroke ? (a || (a = this._stroke = this._createElement("stroke"),
            a.endcap = "round",
            e.appendChild(a)),
            a.weight = c.weight + "px",
            a.color = c.color,
            a.opacity = c.opacity,
            a.dashStyle = c.dashArray ? d.Util.isArray(c.dashArray) ? c.dashArray.join(" ") : c.dashArray.replace(/( *, *)/g, " ") : "",
            c.lineCap && (a.endcap = c.lineCap.replace("butt", "flat")),
            c.lineJoin && (a.joinstyle = c.lineJoin)) : a && (e.removeChild(a),
            this._stroke = null );
            c.fill ? (b || (b = this._fill = 
            this._createElement("fill"),
            e.appendChild(b)),
            b.color = c.fillColor || c.color,
            b.opacity = c.fillOpacity) : b && (e.removeChild(b),
            this._fill = null )
        },
        _updatePath: function() {
            var a = this._container.style;
            a.display = "none";
            this._path.v = this.getPathString() + " ";
            a.display = ""
        }
    });
    d.Map.include(d.Browser.svg || !d.Browser.vml ? {} : {
        _initPathRoot: function() {
            if (!this._pathRoot) {
                var a = this._pathRoot = b.createElement("div");
                a.className = "leaflet-vml-container";
                this._panes.overlayPane.appendChild(a);
                this.on("moveend", this._updatePathViewport);
                this._updatePathViewport()
            }
        }
    });
    d.Browser.canvas = !!b.createElement("canvas").getContext;
    d.Path = d.Path.SVG && !a.L_PREFER_CANVAS || !d.Browser.canvas ? d.Path : d.Path.extend({
        statics: {
            CANVAS: !0,
            SVG: !1
        },
        redraw: function() {
            return this._map && (this.projectLatlngs(),
            this._requestUpdate()),
            this
        },
        setStyle: function(a) {
            return d.setOptions(this, a),
            this._map && (this._updateStyle(),
            this._requestUpdate()),
            this
        },
        onRemove: function(a) {
            a.off("viewreset", this.projectLatlngs, this).off("moveend", this._updatePath, this);
            this.options.clickable && 
            (this._map.off("click", this._onClick, this),
            this._map.off("mousemove", this._onMouseMove, this));
            this._requestUpdate();
            this._map = null 
        },
        _requestUpdate: function() {
            this._map && !d.Path._updateRequest && (d.Path._updateRequest = d.Util.requestAnimFrame(this._fireMapMoveEnd, this._map))
        },
        _fireMapMoveEnd: function() {
            d.Path._updateRequest = null ;
            this.fire("moveend")
        },
        _initElements: function() {
            this._map._initPathRoot();
            this._ctx = this._map._canvasCtx
        },
        _updateStyle: function() {
            var a = this.options;
            a.stroke && (this._ctx.lineWidth = 
            a.weight,
            this._ctx.strokeStyle = a.color);
            a.fill && (this._ctx.fillStyle = a.fillColor || a.color)
        },
        _drawPath: function() {
            var a, b, c, e, g, n;
            this._ctx.beginPath();
            a = 0;
            for (c = this._parts.length; c > a; a++) {
                b = 0;
                for (e = this._parts[a].length; e > b; b++)
                    g = this._parts[a][b],
                    n = (0 === b ? "move" : "line") + "To",
                    this._ctx[n](g.x, g.y);
                this instanceof d.Polygon && this._ctx.closePath()
            }
        },
        _checkIfEmpty: function() {
            return !this._parts.length
        },
        _updatePath: function() {
            if (!this._checkIfEmpty()) {
                var a = this._ctx
                  , b = this.options;
                this._drawPath();
                a.save();
                this._updateStyle();
                b.fill && (a.globalAlpha = b.fillOpacity,
                a.fill());
                b.stroke && (a.globalAlpha = b.opacity,
                a.stroke());
                a.restore()
            }
        },
        _initEvents: function() {
            this.options.clickable && (this._map.on("mousemove", this._onMouseMove, this),
            this._map.on("click", this._onClick, this))
        },
        _onClick: function(a) {
            this._containsPoint(a.layerPoint) && this.fire("click", a)
        },
        _onMouseMove: function(a) {
            this._map && !this._map._animatingZoom && (this._containsPoint(a.layerPoint) ? (this._ctx.canvas.style.cursor = "pointer",
            this._mouseInside = 
            !0,
            this.fire("mouseover", a)) : this._mouseInside && (this._ctx.canvas.style.cursor = "",
            this._mouseInside = !1,
            this.fire("mouseout", a)))
        }
    });
    d.Map.include(d.Path.SVG && !a.L_PREFER_CANVAS || !d.Browser.canvas ? {} : {
        _initPathRoot: function() {
            var a, c = this._pathRoot;
            c || (c = this._pathRoot = b.createElement("canvas"),
            c.style.position = "absolute",
            a = this._canvasCtx = c.getContext("2d"),
            a.lineCap = "round",
            a.lineJoin = "round",
            this._panes.overlayPane.appendChild(c),
            this.options.zoomAnimation && (this._pathRoot.className = "leaflet-zoom-animated",
            this.on("zoomanim", this._animatePathZoom),
            this.on("zoomend", this._endPathZoom)),
            this.on("moveend", this._updateCanvasViewport),
            this._updateCanvasViewport())
        },
        _updateCanvasViewport: function() {
            if (!this._pathZooming) {
                this._updatePathViewport();
                var a = this._pathViewport
                  , b = a.min
                  , a = a.max.subtract(b)
                  , c = this._pathRoot;
                d.DomUtil.setPosition(c, b);
                c.width = a.x;
                c.height = a.y;
                c.getContext("2d").translate(-b.x, -b.y)
            }
        }
    });
    d.LineUtil = {
        simplify: function(a, b) {
            if (!b || !a.length)
                return a.slice();
            var c = b * b;
            return a = this._reducePoints(a, 
            c),
            this._simplifyDP(a, c)
        },
        pointToSegmentDistance: function(a, b, c) {
            return Math.sqrt(this._sqClosestPointOnSegment(a, b, c, !0))
        },
        closestPointOnSegment: function(a, b, c) {
            return this._sqClosestPointOnSegment(a, b, c)
        },
        _simplifyDP: function(a, b) {
            var d = a.length
              , e = new (typeof Uint8Array != c + "" ? Uint8Array : Array)(d);
            e[0] = e[d - 1] = 1;
            this._simplifyDPStep(a, e, b, 0, d - 1);
            var g, n = [];
            for (g = 0; d > g; g++)
                e[g] && n.push(a[g]);
            return n
        },
        _simplifyDPStep: function(a, b, c, d, e) {
            var g, p, t, v = 0;
            for (p = d + 1; e - 1 >= p; p++)
                t = this._sqClosestPointOnSegment(a[p], 
                a[d], a[e], !0),
                t > v && (g = p,
                v = t);
            v > c && (b[g] = 1,
            this._simplifyDPStep(a, b, c, d, g),
            this._simplifyDPStep(a, b, c, g, e))
        },
        _reducePoints: function(a, b) {
            for (var c = [a[0]], d = 1, e = 0, g = a.length; g > d; d++)
                this._sqDist(a[d], a[e]) > b && (c.push(a[d]),
                e = d);
            return g - 1 > e && c.push(a[g - 1]),
            c
        },
        clipSegment: function(a, b, c, d) {
            var e, g, p = d ? this._lastCode : this._getBitCode(a, c), t = this._getBitCode(b, c);
            for (this._lastCode = t; ; ) {
                if (!(p | t))
                    return [a, b];
                if (p & t)
                    return !1;
                d = p || t;
                e = this._getEdgeIntersection(a, b, d, c);
                g = this._getBitCode(e, c);
                d === p ? (a = e,
                p = g) : (b = e,
                t = g)
            }
        },
        _getEdgeIntersection: function(a, b, c, e) {
            var g = b.x - a.x;
            b = b.y - a.y;
            var n = e.min;
            e = e.max;
            return 8 & c ? new d.Point(a.x + g * (e.y - a.y) / b,e.y) : 4 & c ? new d.Point(a.x + g * (n.y - a.y) / b,n.y) : 2 & c ? new d.Point(e.x,a.y + b * (e.x - a.x) / g) : 1 & c ? new d.Point(n.x,a.y + b * (n.x - a.x) / g) : void 0
        },
        _getBitCode: function(a, b) {
            var c = 0;
            return a.x < b.min.x ? c |= 1 : a.x > b.max.x && (c |= 2),
            a.y < b.min.y ? c |= 4 : a.y > b.max.y && (c |= 8),
            c
        },
        _sqDist: function(a, b) {
            var c = b.x - a.x
              , d = b.y - a.y;
            return c * c + d * d
        },
        _sqClosestPointOnSegment: function(a, b, c, e) {
            var g, n = 
            b.x;
            b = b.y;
            var p = c.x - n
              , t = c.y - b
              , v = p * p + t * t;
            return 0 < v && (g = ((a.x - n) * p + (a.y - b) * t) / v,
            1 < g ? (n = c.x,
            b = c.y) : 0 < g && (n += p * g,
            b += t * g)),
            p = a.x - n,
            t = a.y - b,
            e ? p * p + t * t : new d.Point(n,b)
        }
    };
    d.Polyline = d.Path.extend({
        initialize: function(a, b) {
            d.Path.prototype.initialize.call(this, b);
            this._latlngs = this._convertLatLngs(a)
        },
        options: {
            smoothFactor: 1,
            noClip: !1
        },
        projectLatlngs: function() {
            this._originalPoints = [];
            for (var a = 0, b = this._latlngs.length; b > a; a++)
                this._originalPoints[a] = this._map.latLngToLayerPoint(this._latlngs[a])
        },
        getPathString: function() {
            for (var a = 
            0, b = this._parts.length, c = ""; b > a; a++)
                c += this._getPathPartStr(this._parts[a]);
            return c
        },
        getLatLngs: function() {
            return this._latlngs
        },
        setLatLngs: function(a) {
            return this._latlngs = this._convertLatLngs(a),
            this.redraw()
        },
        addLatLng: function(a) {
            return this._latlngs.push(d.latLng(a)),
            this.redraw()
        },
        spliceLatLngs: function() {
            var a = [].splice.apply(this._latlngs, arguments);
            return this._convertLatLngs(this._latlngs, !0),
            this.redraw(),
            a
        },
        closestLayerPoint: function(a) {
            for (var b, c, e = 1 / 0, g = this._parts, n = null , p = 0, t = g.length; t > 
            p; p++)
                for (var v = g[p], r = 1, u = v.length; u > r; r++) {
                    b = v[r - 1];
                    c = v[r];
                    var w = d.LineUtil._sqClosestPointOnSegment(a, b, c, !0);
                    e > w && (e = w,
                    n = d.LineUtil._sqClosestPointOnSegment(a, b, c))
                }
            return n && (n.distance = Math.sqrt(e)),
            n
        },
        getBounds: function() {
            return new d.LatLngBounds(this.getLatLngs())
        },
        _convertLatLngs: function(a, b) {
            var c, e, g = b ? a : [];
            c = 0;
            for (e = a.length; e > c; c++) {
                if (d.Util.isArray(a[c]) && "number" != typeof a[c][0])
                    return;
                g[c] = d.latLng(a[c])
            }
            return g
        },
        _initEvents: function() {
            d.Path.prototype._initEvents.call(this)
        },
        _getPathPartStr: function(a) {
            for (var b, c = d.Path.VML, e = 0, g = a.length, n = ""; g > e; e++)
                b = a[e],
                c && b._round(),
                n += (e ? "L" : "M") + b.x + " " + b.y;
            return n
        },
        _clipPoints: function() {
            var a, b, c, e = this._originalPoints, g = e.length;
            if (this.options.noClip)
                return void (this._parts = [e]);
            var n = this._parts = []
              , p = this._map._pathViewport
              , t = d.LineUtil;
            for (b = a = 0; g - 1 > a; a++)
                (c = t.clipSegment(e[a], e[a + 1], p, a)) && (n[b] = n[b] || [],
                n[b].push(c[0]),
                (c[1] !== e[a + 1] || a === g - 2) && (n[b].push(c[1]),
                b++))
        },
        _simplifyPoints: function() {
            for (var a = this._parts, 
            b = d.LineUtil, c = 0, e = a.length; e > c; c++)
                a[c] = b.simplify(a[c], this.options.smoothFactor)
        },
        _updatePath: function() {
            this._map && (this._clipPoints(),
            this._simplifyPoints(),
            d.Path.prototype._updatePath.call(this))
        }
    });
    d.polyline = function(a, b) {
        return new d.Polyline(a,b)
    }
    ;
    d.PolyUtil = {};
    d.PolyUtil.clipPolygon = function(a, b) {
        var c, e, g, n, p, t, v, r, u = [1, 4, 2, 8], w = d.LineUtil;
        e = 0;
        for (t = a.length; t > e; e++)
            a[e]._code = w._getBitCode(a[e], b);
        for (n = 0; 4 > n; n++) {
            v = u[n];
            c = [];
            e = 0;
            t = a.length;
            for (g = t - 1; t > e; g = e++)
                p = a[e],
                g = a[g],
                p._code & 
                v ? g._code & v || (r = w._getEdgeIntersection(g, p, v, b),
                r._code = w._getBitCode(r, b),
                c.push(r)) : (g._code & v && (r = w._getEdgeIntersection(g, p, v, b),
                r._code = w._getBitCode(r, b),
                c.push(r)),
                c.push(p));
            a = c
        }
        return a
    }
    ;
    d.Polygon = d.Polyline.extend({
        options: {
            fill: !0
        },
        initialize: function(a, b) {
            d.Polyline.prototype.initialize.call(this, a, b);
            this._initWithHoles(a)
        },
        _initWithHoles: function(a) {
            var b, c;
            if (a && d.Util.isArray(a[0]) && "number" != typeof a[0][0])
                for (this._latlngs = this._convertLatLngs(a[0]),
                this._holes = a.slice(1),
                a = 0,
                b = 
                this._holes.length; b > a; a++)
                    c = this._holes[a] = this._convertLatLngs(this._holes[a]),
                    c[0].equals(c[c.length - 1]) && c.pop();
            a = this._latlngs;
            2 <= a.length && a[0].equals(a[a.length - 1]) && a.pop()
        },
        projectLatlngs: function() {
            if (d.Polyline.prototype.projectLatlngs.call(this),
            this._holePoints = [],
            this._holes) {
                var a, b, c, e;
                a = 0;
                for (c = this._holes.length; c > a; a++)
                    for (this._holePoints[a] = [],
                    b = 0,
                    e = this._holes[a].length; e > b; b++)
                        this._holePoints[a][b] = this._map.latLngToLayerPoint(this._holes[a][b])
            }
        },
        setLatLngs: function(a) {
            return a && 
            d.Util.isArray(a[0]) && "number" != typeof a[0][0] ? (this._initWithHoles(a),
            this.redraw()) : d.Polyline.prototype.setLatLngs.call(this, a)
        },
        _clipPoints: function() {
            var a = [];
            if (this._parts = [this._originalPoints].concat(this._holePoints),
            !this.options.noClip) {
                for (var b = 0, c = this._parts.length; c > b; b++) {
                    var e = d.PolyUtil.clipPolygon(this._parts[b], this._map._pathViewport);
                    e.length && a.push(e)
                }
                this._parts = a
            }
        },
        _getPathPartStr: function(a) {
            return d.Polyline.prototype._getPathPartStr.call(this, a) + (d.Browser.svg ? "z" : "x")
        }
    });
    d.polygon = function(a, b) {
        return new d.Polygon(a,b)
    }
    ;
    (function() {
        function a(b) {
            return d.FeatureGroup.extend({
                initialize: function(a, b) {
                    this._layers = {};
                    this._options = b;
                    this.setLatLngs(a)
                },
                setLatLngs: function(a) {
                    var c = 0
                      , d = a.length;
                    for (this.eachLayer(function(b) {
                        d > c ? b.setLatLngs(a[c++]) : this.removeLayer(b)
                    }
                    , this); d > c; )
                        this.addLayer(new b(a[c++],this._options));
                    return this
                },
                getLatLngs: function() {
                    var a = [];
                    return this.eachLayer(function(b) {
                        a.push(b.getLatLngs())
                    }
                    ),
                    a
                }
            })
        }
        d.MultiPolyline = a(d.Polyline);
        d.MultiPolygon = 
        a(d.Polygon);
        d.multiPolyline = function(a, b) {
            return new d.MultiPolyline(a,b)
        }
        ;
        d.multiPolygon = function(a, b) {
            return new d.MultiPolygon(a,b)
        }
    }
    )();
    d.Rectangle = d.Polygon.extend({
        initialize: function(a, b) {
            d.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(a), b)
        },
        setBounds: function(a) {
            this.setLatLngs(this._boundsToLatLngs(a))
        },
        _boundsToLatLngs: function(a) {
            return a = d.latLngBounds(a),
            [a.getSouthWest(), a.getNorthWest(), a.getNorthEast(), a.getSouthEast()]
        }
    });
    d.rectangle = function(a, b) {
        return new d.Rectangle(a,
        b)
    }
    ;
    d.Circle = d.Path.extend({
        initialize: function(a, b, c) {
            d.Path.prototype.initialize.call(this, c);
            this._latlng = d.latLng(a);
            this._mRadius = b
        },
        options: {
            fill: !0
        },
        setLatLng: function(a) {
            return this._latlng = d.latLng(a),
            this.redraw()
        },
        setRadius: function(a) {
            return this._mRadius = a,
            this.redraw()
        },
        projectLatlngs: function() {
            var a = this._getLngRadius()
              , b = this._latlng
              , a = this._map.latLngToLayerPoint([b.lat, b.lng - a]);
            this._point = this._map.latLngToLayerPoint(b);
            this._radius = Math.max(this._point.x - a.x, 1)
        },
        getBounds: function() {
            var a = 
            this._getLngRadius()
              , b = this._mRadius / 40075017 * 360
              , c = this._latlng;
            return new d.LatLngBounds([c.lat - b, c.lng - a],[c.lat + b, c.lng + a])
        },
        getLatLng: function() {
            return this._latlng
        },
        getPathString: function() {
            var a = this._point
              , b = this._radius;
            return this._checkIfEmpty() ? "" : d.Browser.svg ? "M" + a.x + "," + (a.y - b) + "A" + b + "," + b + ",0,1,1," + (a.x - .1) + "," + (a.y - b) + " z" : (a._round(),
            b = Math.round(b),
            "AL " + a.x + "," + a.y + " " + b + "," + b + " 0,23592600")
        },
        getRadius: function() {
            return this._mRadius
        },
        _getLatRadius: function() {
            return this._mRadius / 
            40075017 * 360
        },
        _getLngRadius: function() {
            return this._getLatRadius() / Math.cos(d.LatLng.DEG_TO_RAD * this._latlng.lat)
        },
        _checkIfEmpty: function() {
            if (!this._map)
                return !1;
            var a = this._map._pathViewport
              , b = this._radius
              , c = this._point;
            return c.x - b > a.max.x || c.y - b > a.max.y || c.x + b < a.min.x || c.y + b < a.min.y
        }
    });
    d.circle = function(a, b, c) {
        return new d.Circle(a,b,c)
    }
    ;
    d.CircleMarker = d.Circle.extend({
        options: {
            radius: 10,
            weight: 2
        },
        initialize: function(a, b) {
            d.Circle.prototype.initialize.call(this, a, null , b);
            this._radius = this.options.radius
        },
        projectLatlngs: function() {
            this._point = this._map.latLngToLayerPoint(this._latlng)
        },
        _updateStyle: function() {
            d.Circle.prototype._updateStyle.call(this);
            this.setRadius(this.options.radius)
        },
        setLatLng: function(a) {
            return d.Circle.prototype.setLatLng.call(this, a),
            this._popup && this._popup._isOpen && this._popup.setLatLng(a),
            this
        },
        setRadius: function(a) {
            return this.options.radius = this._radius = a,
            this.redraw()
        },
        getRadius: function() {
            return this._radius
        }
    });
    d.circleMarker = function(a, b) {
        return new d.CircleMarker(a,
        b)
    }
    ;
    d.Polyline.include(d.Path.CANVAS ? {
        _containsPoint: function(a, b) {
            var c, e, g, n, p, t, v, r = this.options.weight / 2;
            d.Browser.touch && (r += 10);
            c = 0;
            for (n = this._parts.length; n > c; c++)
                for (v = this._parts[c],
                e = 0,
                p = v.length,
                g = p - 1; p > e; g = e++)
                    if ((b || 0 !== e) && (t = d.LineUtil.pointToSegmentDistance(a, v[g], v[e]),
                    r >= t))
                        return !0;
            return !1
        }
    } : {});
    d.Polygon.include(d.Path.CANVAS ? {
        _containsPoint: function(a) {
            var b, c, e, g, n, p, t, v = !1;
            if (d.Polyline.prototype._containsPoint.call(this, a, !0))
                return !0;
            g = 0;
            for (p = this._parts.length; p > g; g++)
                for (b = 
                this._parts[g],
                n = 0,
                t = b.length,
                e = t - 1; t > n; e = n++)
                    c = b[n],
                    e = b[e],
                    c.y > a.y != e.y > a.y && a.x < (e.x - c.x) * (a.y - c.y) / (e.y - c.y) + c.x && (v = !v);
            return v
        }
    } : {});
    d.Circle.include(d.Path.CANVAS ? {
        _drawPath: function() {
            var a = this._point;
            this._ctx.beginPath();
            this._ctx.arc(a.x, a.y, this._radius, 0, 2 * Math.PI, !1)
        },
        _containsPoint: function(a) {
            var b = this.options.stroke ? this.options.weight / 2 : 0;
            return a.distanceTo(this._point) <= this._radius + b
        }
    } : {});
    d.CircleMarker.include(d.Path.CANVAS ? {
        _updateStyle: function() {
            d.Path.prototype._updateStyle.call(this)
        }
    } : 
    {});
    d.GeoJSON = d.FeatureGroup.extend({
        initialize: function(a, b) {
            d.setOptions(this, b);
            this._layers = {};
            a && this.addData(a)
        },
        addData: function(a) {
            var b, c, e = d.Util.isArray(a) ? a : a.features;
            if (e) {
                a = 0;
                for (b = e.length; b > a; a++)
                    c = e[a],
                    (c.geometries || c.geometry || c.features || c.coordinates) && this.addData(e[a]);
                return this
            }
            e = this.options;
            if (!e.filter || e.filter(a))
                return b = d.GeoJSON.geometryToLayer(a, e.pointToLayer, e.coordsToLatLng, e),
                b.feature = d.GeoJSON.asFeature(a),
                b.defaultOptions = b.options,
                this.resetStyle(b),
                e.onEachFeature && 
                e.onEachFeature(a, b),
                this.addLayer(b)
        },
        resetStyle: function(a) {
            var b = this.options.style;
            b && (d.Util.extend(a.options, a.defaultOptions),
            this._setLayerStyle(a, b))
        },
        setStyle: function(a) {
            this.eachLayer(function(b) {
                this._setLayerStyle(b, a)
            }
            , this)
        },
        _setLayerStyle: function(a, b) {
            "function" == typeof b && (b = b(a.feature));
            a.setStyle && a.setStyle(b)
        }
    });
    d.extend(d.GeoJSON, {
        geometryToLayer: function(a, b, c, e) {
            var g, n, p, t = "Feature" === a.type ? a.geometry : a, v = t.coordinates, r = [];
            switch (c = c || this.coordsToLatLng,
            t.type) {
            case "Point":
                return g = 
                c(v),
                b ? b(a, g) : new d.Marker(g);
            case "MultiPoint":
                n = 0;
                for (p = v.length; p > n; n++)
                    g = c(v[n]),
                    r.push(b ? b(a, g) : new d.Marker(g));
                return new d.FeatureGroup(r);
            case "LineString":
                return n = this.coordsToLatLngs(v, 0, c),
                new d.Polyline(n,e);
            case "Polygon":
                if (2 === v.length && !v[1].length)
                    throw Error("Invalid GeoJSON object.");
                return n = this.coordsToLatLngs(v, 1, c),
                new d.Polygon(n,e);
            case "MultiLineString":
                return n = this.coordsToLatLngs(v, 1, c),
                new d.MultiPolyline(n,e);
            case "MultiPolygon":
                return n = this.coordsToLatLngs(v, 2, 
                c),
                new d.MultiPolygon(n,e);
            case "GeometryCollection":
                n = 0;
                for (p = t.geometries.length; p > n; n++)
                    r.push(this.geometryToLayer({
                        geometry: t.geometries[n],
                        type: "Feature",
                        properties: a.properties
                    }, b, c, e));
                return new d.FeatureGroup(r);
            default:
                throw Error("Invalid GeoJSON object.");
            }
        },
        coordsToLatLng: function(a) {
            return new d.LatLng(a[1],a[0],a[2])
        },
        coordsToLatLngs: function(a, b, c) {
            var d, e, g, p = [];
            e = 0;
            for (g = a.length; g > e; e++)
                d = b ? this.coordsToLatLngs(a[e], b - 1, c) : (c || this.coordsToLatLng)(a[e]),
                p.push(d);
            return p
        },
        latLngToCoords: function(a) {
            var b = 
            [a.lng, a.lat];
            return a.alt !== c && b.push(a.alt),
            b
        },
        latLngsToCoords: function(a) {
            for (var b = [], c = 0, e = a.length; e > c; c++)
                b.push(d.GeoJSON.latLngToCoords(a[c]));
            return b
        },
        getFeature: function(a, b) {
            return a.feature ? d.extend({}, a.feature, {
                geometry: b
            }) : d.GeoJSON.asFeature(b)
        },
        asFeature: function(a) {
            return "Feature" === a.type ? a : {
                type: "Feature",
                properties: {},
                geometry: a
            }
        }
    });
    var g = {
        toGeoJSON: function() {
            return d.GeoJSON.getFeature(this, {
                type: "Point",
                coordinates: d.GeoJSON.latLngToCoords(this.getLatLng())
            })
        }
    };
    d.Marker.include(g);
    d.Circle.include(g);
    d.CircleMarker.include(g);
    d.Polyline.include({
        toGeoJSON: function() {
            return d.GeoJSON.getFeature(this, {
                type: "LineString",
                coordinates: d.GeoJSON.latLngsToCoords(this.getLatLngs())
            })
        }
    });
    d.Polygon.include({
        toGeoJSON: function() {
            var a, b, c, e = [d.GeoJSON.latLngsToCoords(this.getLatLngs())];
            if (e[0].push(e[0][0]),
            this._holes)
                for (a = 0,
                b = this._holes.length; b > a; a++)
                    c = d.GeoJSON.latLngsToCoords(this._holes[a]),
                    c.push(c[0]),
                    e.push(c);
            return d.GeoJSON.getFeature(this, {
                type: "Polygon",
                coordinates: e
            })
        }
    });
    (function() {
        function a(b) {
            return function() {
                var a = [];
                return this.eachLayer(function(b) {
                    a.push(b.toGeoJSON().geometry.coordinates)
                }
                ),
                d.GeoJSON.getFeature(this, {
                    type: b,
                    coordinates: a
                })
            }
        }
        d.MultiPolyline.include({
            toGeoJSON: a("MultiLineString")
        });
        d.MultiPolygon.include({
            toGeoJSON: a("MultiPolygon")
        });
        d.LayerGroup.include({
            toGeoJSON: function() {
                var b, c = this.feature && this.feature.geometry, e = [];
                if (c && "MultiPoint" === c.type)
                    return a("MultiPoint").call(this);
                var g = c && "GeometryCollection" === c.type;
                return this.eachLayer(function(a) {
                    a.toGeoJSON && 
                    (b = a.toGeoJSON(),
                    e.push(g ? b.geometry : d.GeoJSON.asFeature(b)))
                }
                ),
                g ? d.GeoJSON.getFeature(this, {
                    geometries: e,
                    type: "GeometryCollection"
                }) : {
                    type: "FeatureCollection",
                    features: e
                }
            }
        })
    }
    )();
    d.geoJson = function(a, b) {
        return new d.GeoJSON(a,b)
    }
    ;
    d.DomEvent = {
        addListener: function(a, b, c, e) {
            var g, n, p, t = d.stamp(c), v = "_leaflet_" + b + t;
            return a[v] ? this : (g = function(b) {
                return c.call(e || a, b || d.DomEvent._getEvent())
            }
            ,
            d.Browser.pointer && 0 === b.indexOf("touch") ? this.addPointerListener(a, b, g, t) : (d.Browser.touch && "dblclick" === b && 
            this.addDoubleTapListener && this.addDoubleTapListener(a, g, t),
            "addEventListener" in a ? "mousewheel" === b ? (a.addEventListener("DOMMouseScroll", g, !1),
            a.addEventListener(b, g, !1)) : "mouseenter" === b || "mouseleave" === b ? (n = g,
            p = "mouseenter" === b ? "mouseover" : "mouseout",
            g = function(b) {
                return d.DomEvent._checkMouse(a, b) ? n(b) : void 0
            }
            ,
            a.addEventListener(p, g, !1)) : "click" === b && d.Browser.android ? (n = g,
            g = function(a) {
                return d.DomEvent._filterClick(a, n)
            }
            ,
            a.addEventListener(b, g, !1)) : a.addEventListener(b, g, !1) : "attachEvent" in a && 
            a.attachEvent("on" + b, g),
            a[v] = g,
            this))
        },
        removeListener: function(a, b, c) {
            c = d.stamp(c);
            var e = "_leaflet_" + b + c
              , g = a[e];
            return g ? (d.Browser.pointer && 0 === b.indexOf("touch") ? this.removePointerListener(a, b, c) : d.Browser.touch && "dblclick" === b && this.removeDoubleTapListener ? this.removeDoubleTapListener(a, c) : "removeEventListener" in a ? "mousewheel" === b ? (a.removeEventListener("DOMMouseScroll", g, !1),
            a.removeEventListener(b, g, !1)) : "mouseenter" === b || "mouseleave" === b ? a.removeEventListener("mouseenter" === b ? "mouseover" : "mouseout", 
            g, !1) : a.removeEventListener(b, g, !1) : "detachEvent" in a && a.detachEvent("on" + b, g),
            a[e] = null ,
            this) : this
        },
        stopPropagation: function(a) {
            return a.stopPropagation ? a.stopPropagation() : a.cancelBubble = !0,
            d.DomEvent._skipped(a),
            this
        },
        disableScrollPropagation: function(a) {
            var b = d.DomEvent.stopPropagation;
            return d.DomEvent.on(a, "mousewheel", b).on(a, "MozMousePixelScroll", b)
        },
        disableClickPropagation: function(a) {
            for (var b = d.DomEvent.stopPropagation, c = d.Draggable.START.length - 1; 0 <= c; c--)
                d.DomEvent.on(a, d.Draggable.START[c], 
                b);
            return d.DomEvent.on(a, "click", d.DomEvent._fakeStop).on(a, "dblclick", b)
        },
        preventDefault: function(a) {
            return a.preventDefault ? a.preventDefault() : a.returnValue = !1,
            this
        },
        stop: function(a) {
            return d.DomEvent.preventDefault(a).stopPropagation(a)
        },
        getMousePosition: function(a, b) {
            if (!b)
                return new d.Point(a.clientX,a.clientY);
            var c = b.getBoundingClientRect();
            return new d.Point(a.clientX - c.left - b.clientLeft,a.clientY - c.top - b.clientTop)
        },
        getWheelDelta: function(a) {
            var b = 0;
            return a.wheelDelta && (b = a.wheelDelta / 
            120),
            a.detail && (b = -a.detail / 3),
            b
        },
        _skipEvents: {},
        _fakeStop: function(a) {
            d.DomEvent._skipEvents[a.type] = !0
        },
        _skipped: function(a) {
            var b = this._skipEvents[a.type];
            return this._skipEvents[a.type] = !1,
            b
        },
        _checkMouse: function(a, b) {
            var c = b.relatedTarget;
            if (!c)
                return !0;
            try {
                for (; c && c !== a; )
                    c = c.parentNode
            } catch (d) {
                return !1
            }
            return c !== a
        },
        _getEvent: function() {
            var b = a.event;
            if (!b)
                for (var c = arguments.callee.caller; c && (b = c.arguments[0],
                !b || a.Event !== b.constructor); )
                    c = c.caller;
            return b
        },
        _filterClick: function(a, b) {
            var c = 
            a.timeStamp || a.originalEvent.timeStamp
              , e = d.DomEvent._lastClick && c - d.DomEvent._lastClick;
            return e && 100 < e && 1E3 > e || a.target._simulatedClick && !a._simulated ? void d.DomEvent.stop(a) : (d.DomEvent._lastClick = c,
            b(a))
        }
    };
    d.DomEvent.on = d.DomEvent.addListener;
    d.DomEvent.off = d.DomEvent.removeListener;
    d.Draggable = d.Class.extend({
        includes: d.Mixin.Events,
        statics: {
            START: d.Browser.touch ? ["touchstart", "mousedown"] : ["mousedown"],
            END: {
                mousedown: "mouseup",
                touchstart: "touchend",
                pointerdown: "touchend",
                MSPointerDown: "touchend"
            },
            MOVE: {
                mousedown: "mousemove",
                touchstart: "touchmove",
                pointerdown: "touchmove",
                MSPointerDown: "touchmove"
            }
        },
        initialize: function(a, b) {
            this._element = a;
            this._dragStartTarget = b || a
        },
        enable: function() {
            if (!this._enabled) {
                for (var a = d.Draggable.START.length - 1; 0 <= a; a--)
                    d.DomEvent.on(this._dragStartTarget, d.Draggable.START[a], this._onDown, this);
                this._enabled = !0
            }
        },
        disable: function() {
            if (this._enabled) {
                for (var a = d.Draggable.START.length - 1; 0 <= a; a--)
                    d.DomEvent.off(this._dragStartTarget, d.Draggable.START[a], this._onDown, 
                    this);
                this._moved = this._enabled = !1
            }
        },
        _onDown: function(a) {
            if (this._moved = !1,
            !(a.shiftKey || 1 !== a.which && 1 !== a.button && !a.touches || (d.DomEvent.stopPropagation(a),
            d.Draggable._disabled || (d.DomUtil.disableImageDrag(),
            d.DomUtil.disableTextSelection(),
            this._moving)))) {
                var c = a.touches ? a.touches[0] : a;
                this._startPoint = new d.Point(c.clientX,c.clientY);
                this._startPos = this._newPos = d.DomUtil.getPosition(this._element);
                d.DomEvent.on(b, d.Draggable.MOVE[a.type], this._onMove, this).on(b, d.Draggable.END[a.type], this._onUp, 
                this)
            }
        },
        _onMove: function(a) {
            if (a.touches && 1 < a.touches.length)
                return void (this._moved = !0);
            var c = a.touches && 1 === a.touches.length ? a.touches[0] : a
              , c = (new d.Point(c.clientX,c.clientY)).subtract(this._startPoint);
            (c.x || c.y) && (d.DomEvent.preventDefault(a),
            this._moved || (this.fire("dragstart"),
            this._moved = !0,
            this._startPos = d.DomUtil.getPosition(this._element).subtract(c),
            d.DomUtil.addClass(b.body, "leaflet-dragging"),
            d.DomUtil.addClass(a.target || a.srcElement, "leaflet-drag-target")),
            this._newPos = this._startPos.add(c),
            this._moving = !0,
            d.Util.cancelAnimFrame(this._animRequest),
            this._animRequest = d.Util.requestAnimFrame(this._updatePosition, this, !0, this._dragStartTarget))
        },
        _updatePosition: function() {
            this.fire("predrag");
            d.DomUtil.setPosition(this._element, this._newPos);
            this.fire("drag")
        },
        _onUp: function(a) {
            d.DomUtil.removeClass(b.body, "leaflet-dragging");
            d.DomUtil.removeClass(a.target || a.srcElement, "leaflet-drag-target");
            for (var c in d.Draggable.MOVE)
                d.DomEvent.off(b, d.Draggable.MOVE[c], this._onMove).off(b, d.Draggable.END[c], 
                this._onUp);
            d.DomUtil.enableImageDrag();
            d.DomUtil.enableTextSelection();
            this._moved && this._moving && (d.Util.cancelAnimFrame(this._animRequest),
            this.fire("dragend", {
                distance: this._newPos.distanceTo(this._startPos)
            }));
            this._moving = !1
        }
    });
    d.Handler = d.Class.extend({
        initialize: function(a) {
            this._map = a
        },
        enable: function() {
            this._enabled || (this._enabled = !0,
            this.addHooks())
        },
        disable: function() {
            this._enabled && (this._enabled = !1,
            this.removeHooks())
        },
        enabled: function() {
            return !!this._enabled
        }
    });
    d.Map.mergeOptions({
        dragging: !0,
        inertia: !d.Browser.android23,
        inertiaDeceleration: 3400,
        inertiaMaxSpeed: 1 / 0,
        inertiaThreshold: d.Browser.touch ? 32 : 18,
        easeLinearity: .25,
        worldCopyJump: !1
    });
    d.Map.Drag = d.Handler.extend({
        addHooks: function() {
            if (!this._draggable) {
                var a = this._map;
                this._draggable = new d.Draggable(a._mapPane,a._container);
                this._draggable.on({
                    dragstart: this._onDragStart,
                    drag: this._onDrag,
                    dragend: this._onDragEnd
                }, this);
                a.options.worldCopyJump && (this._draggable.on("predrag", this._onPreDrag, this),
                a.on("viewreset", this._onViewReset, 
                this),
                a.whenReady(this._onViewReset, this))
            }
            this._draggable.enable()
        },
        removeHooks: function() {
            this._draggable.disable()
        },
        moved: function() {
            return this._draggable && this._draggable._moved
        },
        _onDragStart: function() {
            var a = this._map;
            a._panAnim && a._panAnim.stop();
            a.fire("movestart").fire("dragstart");
            a.options.inertia && (this._positions = [],
            this._times = [])
        },
        _onDrag: function() {
            if (this._map.options.inertia) {
                var a = this._lastTime = +new Date
                  , b = this._lastPos = this._draggable._newPos;
                this._positions.push(b);
                this._times.push(a);
                200 < a - this._times[0] && (this._positions.shift(),
                this._times.shift())
            }
            this._map.fire("move").fire("drag")
        },
        _onViewReset: function() {
            var a = this._map.getSize()._divideBy(2);
            this._initialWorldOffset = this._map.latLngToLayerPoint([0, 0]).subtract(a).x;
            this._worldWidth = this._map.project([0, 180]).x
        },
        _onPreDrag: function() {
            var a = this._worldWidth
              , b = Math.round(a / 2)
              , c = this._initialWorldOffset
              , d = this._draggable._newPos.x
              , e = (d - b + c) % a + b - c
              , a = (d + b + c) % a - b - c
              , c = Math.abs(e + c) < Math.abs(a + c) ? e : a;
            this._draggable._newPos.x = c
        },
        _onDragEnd: function(a) {
            var b = this._map
              , c = b.options
              , e = +new Date - this._lastTime
              , g = !c.inertia || e > c.inertiaThreshold || !this._positions[0];
            if (b.fire("dragend", a),
            g)
                b.fire("moveend");
            else {
                a = this._lastPos.subtract(this._positions[0]);
                var n = c.easeLinearity;
                a = a.multiplyBy(n / ((this._lastTime + e - this._times[0]) / 1E3));
                g = a.distanceTo([0, 0]);
                e = Math.min(c.inertiaMaxSpeed, g);
                a = a.multiplyBy(e / g);
                var p = e / (c.inertiaDeceleration * n)
                  , t = a.multiplyBy(-p / 2).round();
                t.x && t.y ? (t = b._limitOffset(t, b.options.maxBounds),
                d.Util.requestAnimFrame(function() {
                    b.panBy(t, 
                    {
                        duration: p,
                        easeLinearity: n,
                        noMoveStart: !0
                    })
                }
                )) : b.fire("moveend")
            }
        }
    });
    d.Map.addInitHook("addHandler", "dragging", d.Map.Drag);
    d.Map.mergeOptions({
        doubleClickZoom: !0
    });
    d.Map.DoubleClickZoom = d.Handler.extend({
        addHooks: function() {
            this._map.on("dblclick", this._onDoubleClick, this)
        },
        removeHooks: function() {
            this._map.off("dblclick", this._onDoubleClick, this)
        },
        _onDoubleClick: function(a) {
            var b = this._map
              , c = b.getZoom() + (a.originalEvent.shiftKey ? -1 : 1);
            "center" === b.options.doubleClickZoom ? b.setZoom(c) : b.setZoomAround(a.containerPoint, 
            c)
        }
    });
    d.Map.addInitHook("addHandler", "doubleClickZoom", d.Map.DoubleClickZoom);
    d.Map.mergeOptions({
        scrollWheelZoom: !0
    });
    d.Map.ScrollWheelZoom = d.Handler.extend({
        addHooks: function() {
            d.DomEvent.on(this._map._container, "mousewheel", this._onWheelScroll, this);
            d.DomEvent.on(this._map._container, "MozMousePixelScroll", d.DomEvent.preventDefault);
            this._delta = 0
        },
        removeHooks: function() {
            d.DomEvent.off(this._map._container, "mousewheel", this._onWheelScroll);
            d.DomEvent.off(this._map._container, "MozMousePixelScroll", 
            d.DomEvent.preventDefault)
        },
        _onWheelScroll: function(a) {
            var b = d.DomEvent.getWheelDelta(a);
            this._delta += b;
            this._lastMousePos = this._map.mouseEventToContainerPoint(a);
            this._startTime || (this._startTime = +new Date);
            b = Math.max(40 - (+new Date - this._startTime), 0);
            clearTimeout(this._timer);
            this._timer = setTimeout(d.bind(this._performZoom, this), b);
            d.DomEvent.preventDefault(a);
            d.DomEvent.stopPropagation(a)
        },
        _performZoom: function() {
            var a = this._map
              , b = this._delta
              , c = a.getZoom()
              , b = 0 < b ? Math.ceil(b) : Math.floor(b)
              , b = Math.max(Math.min(b, 
            4), -4)
              , b = a._limitZoom(c + b) - c;
            this._delta = 0;
            this._startTime = null ;
            b && ("center" === a.options.scrollWheelZoom ? a.setZoom(c + b) : a.setZoomAround(this._lastMousePos, c + b))
        }
    });
    d.Map.addInitHook("addHandler", "scrollWheelZoom", d.Map.ScrollWheelZoom);
    d.extend(d.DomEvent, {
        _touchstart: d.Browser.msPointer ? "MSPointerDown" : d.Browser.pointer ? "pointerdown" : "touchstart",
        _touchend: d.Browser.msPointer ? "MSPointerUp" : d.Browser.pointer ? "pointerup" : "touchend",
        addDoubleTapListener: function(a, c, e) {
            function g(a) {
                var b;
                if (d.Browser.pointer ? 
                (w.push(a.pointerId),
                b = w.length) : b = a.touches.length,
                !(1 < b)) {
                    b = Date.now();
                    var c = b - (n || b);
                    p = a.touches ? a.touches[0] : a;
                    t = 0 < c && v >= c;
                    n = b
                }
            }
            function m(a) {
                if (d.Browser.pointer) {
                    a = w.indexOf(a.pointerId);
                    if (-1 === a)
                        return;
                    w.splice(a, 1)
                }
                if (t) {
                    if (d.Browser.pointer) {
                        var b = {}, e;
                        for (e in p)
                            a = p[e],
                            b[e] = "function" == typeof a ? a.bind(p) : a;
                        p = b
                    }
                    p.type = "dblclick";
                    c(p);
                    n = null 
                }
            }
            var n, p, t = !1, v = 250, r = this._touchstart, u = this._touchend, w = [];
            a["_leaflet_" + r + e] = g;
            a["_leaflet_" + u + e] = m;
            e = d.Browser.pointer ? b.documentElement : a;
            return a.addEventListener(r, 
            g, !1),
            e.addEventListener(u, m, !1),
            d.Browser.pointer && e.addEventListener(d.DomEvent.POINTER_CANCEL, m, !1),
            this
        },
        removeDoubleTapListener: function(a, c) {
            return a.removeEventListener(this._touchstart, a["_leaflet_" + this._touchstart + c], !1),
            (d.Browser.pointer ? b.documentElement : a).removeEventListener(this._touchend, a["_leaflet_" + this._touchend + c], !1),
            d.Browser.pointer && b.documentElement.removeEventListener(d.DomEvent.POINTER_CANCEL, a["_leaflet_" + this._touchend + c], !1),
            this
        }
    });
    d.extend(d.DomEvent, {
        POINTER_DOWN: d.Browser.msPointer ? 
        "MSPointerDown" : "pointerdown",
        POINTER_MOVE: d.Browser.msPointer ? "MSPointerMove" : "pointermove",
        POINTER_UP: d.Browser.msPointer ? "MSPointerUp" : "pointerup",
        POINTER_CANCEL: d.Browser.msPointer ? "MSPointerCancel" : "pointercancel",
        _pointers: [],
        _pointerDocumentListener: !1,
        addPointerListener: function(a, b, c, d) {
            switch (b) {
            case "touchstart":
                return this.addPointerListenerStart(a, b, c, d);
            case "touchend":
                return this.addPointerListenerEnd(a, b, c, d);
            case "touchmove":
                return this.addPointerListenerMove(a, b, c, d);
            default:
                throw "Unknown touch event type";
            }
        },
        addPointerListenerStart: function(a, c, e, g) {
            var m = this._pointers;
            c = function(a) {
                d.DomEvent.preventDefault(a);
                for (var b = !1, c = 0; c < m.length; c++)
                    if (m[c].pointerId === a.pointerId) {
                        b = !0;
                        break
                    }
                b || m.push(a);
                a.touches = m.slice();
                a.changedTouches = [a];
                e(a)
            }
            ;
            (a["_leaflet_touchstart" + g] = c,
            a.addEventListener(this.POINTER_DOWN, c, !1),
            this._pointerDocumentListener) || (a = function(a) {
                for (var b = 0; b < m.length; b++)
                    if (m[b].pointerId === a.pointerId) {
                        m.splice(b, 1);
                        break
                    }
            }
            ,
            b.documentElement.addEventListener(this.POINTER_UP, a, !1),
            b.documentElement.addEventListener(this.POINTER_CANCEL, a, !1),
            this._pointerDocumentListener = !0);
            return this
        },
        addPointerListenerMove: function(a, b, c, d) {
            function e(a) {
                if (a.pointerType !== a.MSPOINTER_TYPE_MOUSE && "mouse" !== a.pointerType || 0 !== a.buttons) {
                    for (var b = 0; b < g.length; b++)
                        if (g[b].pointerId === a.pointerId) {
                            g[b] = a;
                            break
                        }
                    a.touches = g.slice();
                    a.changedTouches = [a];
                    c(a)
                }
            }
            var g = this._pointers;
            return a["_leaflet_touchmove" + d] = e,
            a.addEventListener(this.POINTER_MOVE, e, !1),
            this
        },
        addPointerListenerEnd: function(a, 
        b, c, d) {
            var e = this._pointers;
            b = function(a) {
                for (var b = 0; b < e.length; b++)
                    if (e[b].pointerId === a.pointerId) {
                        e.splice(b, 1);
                        break
                    }
                a.touches = e.slice();
                a.changedTouches = [a];
                c(a)
            }
            ;
            return a["_leaflet_touchend" + d] = b,
            a.addEventListener(this.POINTER_UP, b, !1),
            a.addEventListener(this.POINTER_CANCEL, b, !1),
            this
        },
        removePointerListener: function(a, b, c) {
            c = a["_leaflet_" + b + c];
            switch (b) {
            case "touchstart":
                a.removeEventListener(this.POINTER_DOWN, c, !1);
                break;
            case "touchmove":
                a.removeEventListener(this.POINTER_MOVE, c, !1);
                break;
            case "touchend":
                a.removeEventListener(this.POINTER_UP, c, !1),
                a.removeEventListener(this.POINTER_CANCEL, c, !1)
            }
            return this
        }
    });
    d.Map.mergeOptions({
        touchZoom: d.Browser.touch && !d.Browser.android23,
        bounceAtZoomLimits: !0
    });
    d.Map.TouchZoom = d.Handler.extend({
        addHooks: function() {
            d.DomEvent.on(this._map._container, "touchstart", this._onTouchStart, this)
        },
        removeHooks: function() {
            d.DomEvent.off(this._map._container, "touchstart", this._onTouchStart, this)
        },
        _onTouchStart: function(a) {
            var c = this._map;
            if (a.touches && 2 === 
            a.touches.length && !c._animatingZoom && !this._zooming) {
                var e = c.mouseEventToLayerPoint(a.touches[0])
                  , g = c.mouseEventToLayerPoint(a.touches[1])
                  , m = c._getCenterLayerPoint();
                this._startCenter = e.add(g)._divideBy(2);
                this._startDist = e.distanceTo(g);
                this._moved = !1;
                this._zooming = !0;
                this._centerOffset = m.subtract(this._startCenter);
                c._panAnim && c._panAnim.stop();
                d.DomEvent.on(b, "touchmove", this._onTouchMove, this).on(b, "touchend", this._onTouchEnd, this);
                d.DomEvent.preventDefault(a)
            }
        },
        _onTouchMove: function(a) {
            var b = 
            this._map;
            if (a.touches && 2 === a.touches.length && this._zooming) {
                var c = b.mouseEventToLayerPoint(a.touches[0])
                  , e = b.mouseEventToLayerPoint(a.touches[1]);
                this._scale = c.distanceTo(e) / this._startDist;
                this._delta = c._add(e)._divideBy(2)._subtract(this._startCenter);
                1 === this._scale || !b.options.bounceAtZoomLimits && (b.getZoom() === b.getMinZoom() && 1 > this._scale || b.getZoom() === b.getMaxZoom() && 1 < this._scale) || (this._moved || (d.DomUtil.addClass(b._mapPane, "leaflet-touching"),
                b.fire("movestart").fire("zoomstart"),
                this._moved = 
                !0),
                d.Util.cancelAnimFrame(this._animRequest),
                this._animRequest = d.Util.requestAnimFrame(this._updateOnMove, this, !0, this._map._container),
                d.DomEvent.preventDefault(a))
            }
        },
        _updateOnMove: function() {
            var a = this._map
              , b = this._getScaleOrigin()
              , b = a.layerPointToLatLng(b)
              , c = a.getScaleZoom(this._scale);
            a._animateZoom(b, c, this._startCenter, this._scale, this._delta)
        },
        _onTouchEnd: function() {
            if (!this._moved || !this._zooming)
                return void (this._zooming = !1);
            var a = this._map;
            this._zooming = !1;
            d.DomUtil.removeClass(a._mapPane, 
            "leaflet-touching");
            d.Util.cancelAnimFrame(this._animRequest);
            d.DomEvent.off(b, "touchmove", this._onTouchMove).off(b, "touchend", this._onTouchEnd);
            var c = this._getScaleOrigin()
              , e = a.layerPointToLatLng(c)
              , g = a.getZoom()
              , m = a.getScaleZoom(this._scale) - g
              , m = 0 < m ? Math.ceil(m) : Math.floor(m)
              , g = a._limitZoom(g + m)
              , m = a.getZoomScale(g) / this._scale;
            a._animateZoom(e, g, c, m)
        },
        _getScaleOrigin: function() {
            var a = this._centerOffset.subtract(this._delta).divideBy(this._scale);
            return this._startCenter.add(a)
        }
    });
    d.Map.addInitHook("addHandler", 
    "touchZoom", d.Map.TouchZoom);
    d.Map.mergeOptions({
        tap: !0,
        tapTolerance: 15
    });
    d.Map.Tap = d.Handler.extend({
        addHooks: function() {
            d.DomEvent.on(this._map._container, "touchstart", this._onDown, this)
        },
        removeHooks: function() {
            d.DomEvent.off(this._map._container, "touchstart", this._onDown, this)
        },
        _onDown: function(a) {
            if (a.touches) {
                if (d.DomEvent.preventDefault(a),
                this._fireClick = !0,
                1 < a.touches.length)
                    return this._fireClick = !1,
                    void clearTimeout(this._holdTimeout);
                var c = a.touches[0];
                a = c.target;
                this._startPos = this._newPos = 
                new d.Point(c.clientX,c.clientY);
                a.tagName && "a" === a.tagName.toLowerCase() && d.DomUtil.addClass(a, "leaflet-active");
                this._holdTimeout = setTimeout(d.bind(function() {
                    this._isTapValid() && (this._fireClick = !1,
                    this._onUp(),
                    this._simulateEvent("contextmenu", c))
                }
                , this), 1E3);
                d.DomEvent.on(b, "touchmove", this._onMove, this).on(b, "touchend", this._onUp, this)
            }
        },
        _onUp: function(a) {
            if (clearTimeout(this._holdTimeout),
            d.DomEvent.off(b, "touchmove", this._onMove, this).off(b, "touchend", this._onUp, this),
            this._fireClick && a && 
            a.changedTouches) {
                a = a.changedTouches[0];
                var c = a.target;
                c && c.tagName && "a" === c.tagName.toLowerCase() && d.DomUtil.removeClass(c, "leaflet-active");
                this._isTapValid() && this._simulateEvent("click", a)
            }
        },
        _isTapValid: function() {
            return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance
        },
        _onMove: function(a) {
            a = a.touches[0];
            this._newPos = new d.Point(a.clientX,a.clientY)
        },
        _simulateEvent: function(c, d) {
            var e = b.createEvent("MouseEvents");
            e._simulated = !0;
            d.target._simulatedClick = !0;
            e.initMouseEvent(c, 
            !0, !0, a, 1, d.screenX, d.screenY, d.clientX, d.clientY, !1, !1, !1, !1, 0, null );
            d.target.dispatchEvent(e)
        }
    });
    d.Browser.touch && !d.Browser.pointer && d.Map.addInitHook("addHandler", "tap", d.Map.Tap);
    d.Map.mergeOptions({
        boxZoom: !0
    });
    d.Map.BoxZoom = d.Handler.extend({
        initialize: function(a) {
            this._map = a;
            this._container = a._container;
            this._pane = a._panes.overlayPane;
            this._moved = !1
        },
        addHooks: function() {
            d.DomEvent.on(this._container, "mousedown", this._onMouseDown, this)
        },
        removeHooks: function() {
            d.DomEvent.off(this._container, 
            "mousedown", this._onMouseDown);
            this._moved = !1
        },
        moved: function() {
            return this._moved
        },
        _onMouseDown: function(a) {
            return this._moved = !1,
            !a.shiftKey || 1 !== a.which && 1 !== a.button ? !1 : (d.DomUtil.disableTextSelection(),
            d.DomUtil.disableImageDrag(),
            this._startLayerPoint = this._map.mouseEventToLayerPoint(a),
            void d.DomEvent.on(b, "mousemove", this._onMouseMove, this).on(b, "mouseup", this._onMouseUp, this).on(b, "keydown", this._onKeyDown, this))
        },
        _onMouseMove: function(a) {
            this._moved || (this._box = d.DomUtil.create("div", "leaflet-zoom-box", 
            this._pane),
            d.DomUtil.setPosition(this._box, this._startLayerPoint),
            this._container.style.cursor = "crosshair",
            this._map.fire("boxzoomstart"));
            var b = this._startLayerPoint
              , c = this._box
              , e = this._map.mouseEventToLayerPoint(a);
            a = e.subtract(b);
            b = new d.Point(Math.min(e.x, b.x),Math.min(e.y, b.y));
            d.DomUtil.setPosition(c, b);
            this._moved = !0;
            c.style.width = Math.max(0, Math.abs(a.x) - 4) + "px";
            c.style.height = Math.max(0, Math.abs(a.y) - 4) + "px"
        },
        _finish: function() {
            this._moved && (this._pane.removeChild(this._box),
            this._container.style.cursor = 
            "");
            d.DomUtil.enableTextSelection();
            d.DomUtil.enableImageDrag();
            d.DomEvent.off(b, "mousemove", this._onMouseMove).off(b, "mouseup", this._onMouseUp).off(b, "keydown", this._onKeyDown)
        },
        _onMouseUp: function(a) {
            this._finish();
            var b = this._map;
            a = b.mouseEventToLayerPoint(a);
            this._startLayerPoint.equals(a) || (a = new d.LatLngBounds(b.layerPointToLatLng(this._startLayerPoint),b.layerPointToLatLng(a)),
            b.fitBounds(a),
            b.fire("boxzoomend", {
                boxZoomBounds: a
            }))
        },
        _onKeyDown: function(a) {
            27 === a.keyCode && this._finish()
        }
    });
    d.Map.addInitHook("addHandler", 
    "boxZoom", d.Map.BoxZoom);
    d.Map.mergeOptions({
        keyboard: !0,
        keyboardPanOffset: 80,
        keyboardZoomOffset: 1
    });
    d.Map.Keyboard = d.Handler.extend({
        keyCodes: {
            left: [37],
            right: [39],
            down: [40],
            up: [38],
            zoomIn: [187, 107, 61, 171],
            zoomOut: [189, 109, 173]
        },
        initialize: function(a) {
            this._map = a;
            this._setPanOffset(a.options.keyboardPanOffset);
            this._setZoomOffset(a.options.keyboardZoomOffset)
        },
        addHooks: function() {
            var a = this._map._container;
            -1 === a.tabIndex && (a.tabIndex = "0");
            d.DomEvent.on(a, "focus", this._onFocus, this).on(a, "blur", 
            this._onBlur, this).on(a, "mousedown", this._onMouseDown, this);
            this._map.on("focus", this._addHooks, this).on("blur", this._removeHooks, this)
        },
        removeHooks: function() {
            this._removeHooks();
            var a = this._map._container;
            d.DomEvent.off(a, "focus", this._onFocus, this).off(a, "blur", this._onBlur, this).off(a, "mousedown", this._onMouseDown, this);
            this._map.off("focus", this._addHooks, this).off("blur", this._removeHooks, this)
        },
        _onMouseDown: function() {
            if (!this._focused) {
                var c = b.body
                  , d = b.documentElement
                  , e = c.scrollTop || d.scrollTop
                  , 
                c = c.scrollLeft || d.scrollLeft;
                this._map._container.focus();
                a.scrollTo(c, e)
            }
        },
        _onFocus: function() {
            this._focused = !0;
            this._map.fire("focus")
        },
        _onBlur: function() {
            this._focused = !1;
            this._map.fire("blur")
        },
        _setPanOffset: function(a) {
            var b, c, d = this._panKeys = {}, e = this.keyCodes;
            b = 0;
            for (c = e.left.length; c > b; b++)
                d[e.left[b]] = [-1 * a, 0];
            b = 0;
            for (c = e.right.length; c > b; b++)
                d[e.right[b]] = [a, 0];
            b = 0;
            for (c = e.down.length; c > b; b++)
                d[e.down[b]] = [0, a];
            b = 0;
            for (c = e.up.length; c > b; b++)
                d[e.up[b]] = [0, -1 * a]
        },
        _setZoomOffset: function(a) {
            var b, 
            c, d = this._zoomKeys = {}, e = this.keyCodes;
            b = 0;
            for (c = e.zoomIn.length; c > b; b++)
                d[e.zoomIn[b]] = a;
            b = 0;
            for (c = e.zoomOut.length; c > b; b++)
                d[e.zoomOut[b]] = -a
        },
        _addHooks: function() {
            d.DomEvent.on(b, "keydown", this._onKeyDown, this)
        },
        _removeHooks: function() {
            d.DomEvent.off(b, "keydown", this._onKeyDown, this)
        },
        _onKeyDown: function(a) {
            var b = a.keyCode
              , c = this._map;
            if (b in this._panKeys) {
                if (c._panAnim && c._panAnim._inProgress)
                    return;
                c.panBy(this._panKeys[b]);
                c.options.maxBounds && c.panInsideBounds(c.options.maxBounds)
            } else {
                if (!(b in 
                this._zoomKeys))
                    return;
                c.setZoom(c.getZoom() + this._zoomKeys[b])
            }
            d.DomEvent.stop(a)
        }
    });
    d.Map.addInitHook("addHandler", "keyboard", d.Map.Keyboard);
    d.Handler.MarkerDrag = d.Handler.extend({
        initialize: function(a) {
            this._marker = a
        },
        addHooks: function() {
            var a = this._marker._icon;
            this._draggable || (this._draggable = new d.Draggable(a,a));
            this._draggable.on("dragstart", this._onDragStart, this).on("drag", this._onDrag, this).on("dragend", this._onDragEnd, this);
            this._draggable.enable();
            d.DomUtil.addClass(this._marker._icon, 
            "leaflet-marker-draggable")
        },
        removeHooks: function() {
            this._draggable.off("dragstart", this._onDragStart, this).off("drag", this._onDrag, this).off("dragend", this._onDragEnd, this);
            this._draggable.disable();
            d.DomUtil.removeClass(this._marker._icon, "leaflet-marker-draggable")
        },
        moved: function() {
            return this._draggable && this._draggable._moved
        },
        _onDragStart: function() {
            this._marker.closePopup().fire("movestart").fire("dragstart")
        },
        _onDrag: function() {
            var a = this._marker
              , b = a._shadow
              , c = d.DomUtil.getPosition(a._icon)
              , 
            e = a._map.layerPointToLatLng(c);
            b && d.DomUtil.setPosition(b, c);
            a._latlng = e;
            a.fire("move", {
                latlng: e
            }).fire("drag")
        },
        _onDragEnd: function(a) {
            this._marker.fire("moveend").fire("dragend", a)
        }
    });
    d.Control = d.Class.extend({
        options: {
            position: "topright"
        },
        initialize: function(a) {
            d.setOptions(this, a)
        },
        getPosition: function() {
            return this.options.position
        },
        setPosition: function(a) {
            var b = this._map;
            return b && b.removeControl(this),
            this.options.position = a,
            b && b.addControl(this),
            this
        },
        getContainer: function() {
            return this._container
        },
        addTo: function(a) {
            this._map = a;
            var b = this._container = this.onAdd(a)
              , c = this.getPosition();
            a = a._controlCorners[c];
            return d.DomUtil.addClass(b, "leaflet-control"),
            -1 !== c.indexOf("bottom") ? a.insertBefore(b, a.firstChild) : a.appendChild(b),
            this
        },
        removeFrom: function(a) {
            var b = this.getPosition();
            return a._controlCorners[b].removeChild(this._container),
            this._map = null ,
            this.onRemove && this.onRemove(a),
            this
        },
        _refocusOnMap: function() {
            this._map && this._map.getContainer().focus()
        }
    });
    d.control = function(a) {
        return new d.Control(a)
    }
    ;
    d.Map.include({
        addControl: function(a) {
            return a.addTo(this),
            this
        },
        removeControl: function(a) {
            return a.removeFrom(this),
            this
        },
        _initControlPos: function() {
            function a(f, g) {
                b[f + g] = d.DomUtil.create("div", c + f + " " + c + g, e)
            }
            var b = this._controlCorners = {}
              , c = "leaflet-"
              , e = this._controlContainer = d.DomUtil.create("div", c + "control-container", this._container);
            a("top", "left");
            a("top", "right");
            a("bottom", "left");
            a("bottom", "right")
        },
        _clearControlPos: function() {
            this._container.removeChild(this._controlContainer)
        }
    });
    d.Control.Zoom = 
    d.Control.extend({
        options: {
            position: "topleft",
            zoomInText: "+",
            zoomInTitle: "Zoom in",
            zoomOutText: "-",
            zoomOutTitle: "Zoom out"
        },
        onAdd: function(a) {
            var b = d.DomUtil.create("div", "leaflet-control-zoom leaflet-bar");
            return this._map = a,
            this._zoomInButton = this._createButton(this.options.zoomInText, this.options.zoomInTitle, "leaflet-control-zoom-in", b, this._zoomIn, this),
            this._zoomOutButton = this._createButton(this.options.zoomOutText, this.options.zoomOutTitle, "leaflet-control-zoom-out", b, this._zoomOut, this),
            this._updateDisabled(),
            a.on("zoomend zoomlevelschange", this._updateDisabled, this),
            b
        },
        onRemove: function(a) {
            a.off("zoomend zoomlevelschange", this._updateDisabled, this)
        },
        _zoomIn: function(a) {
            this._map.zoomIn(a.shiftKey ? 3 : 1)
        },
        _zoomOut: function(a) {
            this._map.zoomOut(a.shiftKey ? 3 : 1)
        },
        _createButton: function(a, b, c, e, g, n) {
            c = d.DomUtil.create("a", c, e);
            c.innerHTML = a;
            c.href = "#";
            c.title = b;
            a = d.DomEvent.stopPropagation;
            return d.DomEvent.on(c, "click", a).on(c, "mousedown", a).on(c, "dblclick", a).on(c, "click", d.DomEvent.preventDefault).on(c, "click", 
            g, n).on(c, "click", this._refocusOnMap, n),
            c
        },
        _updateDisabled: function() {
            var a = this._map;
            d.DomUtil.removeClass(this._zoomInButton, "leaflet-disabled");
            d.DomUtil.removeClass(this._zoomOutButton, "leaflet-disabled");
            a._zoom === a.getMinZoom() && d.DomUtil.addClass(this._zoomOutButton, "leaflet-disabled");
            a._zoom === a.getMaxZoom() && d.DomUtil.addClass(this._zoomInButton, "leaflet-disabled")
        }
    });
    d.Map.mergeOptions({
        zoomControl: !0
    });
    d.Map.addInitHook(function() {
        this.options.zoomControl && (this.zoomControl = new d.Control.Zoom,
        this.addControl(this.zoomControl))
    }
    );
    d.control.zoom = function(a) {
        return new d.Control.Zoom(a)
    }
    ;
    d.Control.Attribution = d.Control.extend({
        options: {
            position: "bottomright",
            prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
        },
        initialize: function(a) {
            d.setOptions(this, a);
            this._attributions = {}
        },
        onAdd: function(a) {
            this._container = d.DomUtil.create("div", "leaflet-control-attribution");
            d.DomEvent.disableClickPropagation(this._container);
            for (var b in a._layers)
                a._layers[b].getAttribution && 
                this.addAttribution(a._layers[b].getAttribution());
            return a.on("layeradd", this._onLayerAdd, this).on("layerremove", this._onLayerRemove, this),
            this._update(),
            this._container
        },
        onRemove: function(a) {
            a.off("layeradd", this._onLayerAdd).off("layerremove", this._onLayerRemove)
        },
        setPrefix: function(a) {
            return this.options.prefix = a,
            this._update(),
            this
        },
        addAttribution: function(a) {
            return a ? (this._attributions[a] || (this._attributions[a] = 0),
            this._attributions[a]++,
            this._update(),
            this) : void 0
        },
        removeAttribution: function(a) {
            return a ? 
            (this._attributions[a] && (this._attributions[a]--,
            this._update()),
            this) : void 0
        },
        _update: function() {
            if (this._map) {
                var a = [], b;
                for (b in this._attributions)
                    this._attributions[b] && a.push(b);
                b = [];
                this.options.prefix && b.push(this.options.prefix);
                a.length && b.push(a.join(", "));
                this._container.innerHTML = b.join(" | ")
            }
        },
        _onLayerAdd: function(a) {
            a.layer.getAttribution && this.addAttribution(a.layer.getAttribution())
        },
        _onLayerRemove: function(a) {
            a.layer.getAttribution && this.removeAttribution(a.layer.getAttribution())
        }
    });
    d.Map.mergeOptions({
        attributionControl: !0
    });
    d.Map.addInitHook(function() {
        this.options.attributionControl && (this.attributionControl = (new d.Control.Attribution).addTo(this))
    }
    );
    d.control.attribution = function(a) {
        return new d.Control.Attribution(a)
    }
    ;
    d.Control.Scale = d.Control.extend({
        options: {
            position: "bottomleft",
            maxWidth: 100,
            metric: !0,
            imperial: !0,
            updateWhenIdle: !1
        },
        onAdd: function(a) {
            this._map = a;
            var b = d.DomUtil.create("div", "leaflet-control-scale")
              , c = this.options;
            return this._addScales(c, "leaflet-control-scale", 
            b),
            a.on(c.updateWhenIdle ? "moveend" : "move", this._update, this),
            a.whenReady(this._update, this),
            b
        },
        onRemove: function(a) {
            a.off(this.options.updateWhenIdle ? "moveend" : "move", this._update, this)
        },
        _addScales: function(a, b, c) {
            a.metric && (this._mScale = d.DomUtil.create("div", b + "-line", c));
            a.imperial && (this._iScale = d.DomUtil.create("div", b + "-line", c))
        },
        _update: function() {
            var a = this._map.getBounds()
              , b = a.getCenter().lat
              , a = 6378137 * Math.PI * Math.cos(b * Math.PI / 180) * (a.getNorthEast().lng - a.getSouthWest().lng) / 180
              , b = this._map.getSize()
              , 
            c = this.options
              , d = 0;
            0 < b.x && (d = c.maxWidth / b.x * a);
            this._updateScales(c, d)
        },
        _updateScales: function(a, b) {
            a.metric && b && this._updateMetric(b);
            a.imperial && b && this._updateImperial(b)
        },
        _updateMetric: function(a) {
            var b = this._getRoundNum(a);
            this._mScale.style.width = this._getScaleWidth(b / a) + "px";
            this._mScale.innerHTML = 1E3 > b ? b + " m" : b / 1E3 + " km"
        },
        _updateImperial: function(a) {
            var b, c, d;
            a *= 3.2808399;
            var e = this._iScale;
            5280 < a ? (b = a / 5280,
            c = this._getRoundNum(b),
            e.style.width = this._getScaleWidth(c / b) + "px",
            e.innerHTML = c + " mi") : 
            (d = this._getRoundNum(a),
            e.style.width = this._getScaleWidth(d / a) + "px",
            e.innerHTML = d + " ft")
        },
        _getScaleWidth: function(a) {
            return Math.round(this.options.maxWidth * a) - 10
        },
        _getRoundNum: function(a) {
            var b = Math.pow(10, (Math.floor(a) + "").length - 1);
            a /= b;
            return a = 10 <= a ? 10 : 5 <= a ? 5 : 3 <= a ? 3 : 2 <= a ? 2 : 1,
            b * a
        }
    });
    d.control.scale = function(a) {
        return new d.Control.Scale(a)
    }
    ;
    d.Control.Layers = d.Control.extend({
        options: {
            collapsed: !0,
            position: "topright",
            autoZIndex: !0
        },
        initialize: function(a, b, c) {
            d.setOptions(this, c);
            this._layers = 
            {};
            this._lastZIndex = 0;
            this._handlingClick = !1;
            for (var e in a)
                this._addLayer(a[e], e);
            for (e in b)
                this._addLayer(b[e], e, !0)
        },
        onAdd: function(a) {
            return this._initLayout(),
            this._update(),
            a.on("layeradd", this._onLayerChange, this).on("layerremove", this._onLayerChange, this),
            this._container
        },
        onRemove: function(a) {
            a.off("layeradd", this._onLayerChange).off("layerremove", this._onLayerChange)
        },
        addBaseLayer: function(a, b) {
            return this._addLayer(a, b),
            this._update(),
            this
        },
        addOverlay: function(a, b) {
            return this._addLayer(a, 
            b, !0),
            this._update(),
            this
        },
        removeLayer: function(a) {
            a = d.stamp(a);
            return delete this._layers[a],
            this._update(),
            this
        },
        _initLayout: function() {
            var a = this._container = d.DomUtil.create("div", "leaflet-control-layers");
            a.setAttribute("aria-haspopup", !0);
            d.Browser.touch ? d.DomEvent.on(a, "click", d.DomEvent.stopPropagation) : d.DomEvent.disableClickPropagation(a).disableScrollPropagation(a);
            var b = this._form = d.DomUtil.create("form", "leaflet-control-layers-list");
            if (this.options.collapsed) {
                d.Browser.android || d.DomEvent.on(a, 
                "mouseover", this._expand, this).on(a, "mouseout", this._collapse, this);
                var c = this._layersLink = d.DomUtil.create("a", "leaflet-control-layers-toggle", a);
                c.href = "#";
                c.title = "Layers";
                d.Browser.touch ? d.DomEvent.on(c, "click", d.DomEvent.stop).on(c, "click", this._expand, this) : d.DomEvent.on(c, "focus", this._expand, this);
                d.DomEvent.on(b, "click", function() {
                    setTimeout(d.bind(this._onInputClick, this), 0)
                }
                , this);
                this._map.on("click", this._collapse, this)
            } else
                this._expand();
            this._baseLayersList = d.DomUtil.create("div", 
            "leaflet-control-layers-base", b);
            this._separator = d.DomUtil.create("div", "leaflet-control-layers-separator", b);
            this._overlaysList = d.DomUtil.create("div", "leaflet-control-layers-overlays", b);
            a.appendChild(b)
        },
        _addLayer: function(a, b, c) {
            var e = d.stamp(a);
            this._layers[e] = {
                layer: a,
                name: b,
                overlay: c
            };
            this.options.autoZIndex && a.setZIndex && (this._lastZIndex++,
            a.setZIndex(this._lastZIndex))
        },
        _update: function() {
            if (this._container) {
                this._baseLayersList.innerHTML = "";
                this._overlaysList.innerHTML = "";
                var a, b, c = !1, 
                d = !1;
                for (a in this._layers)
                    b = this._layers[a],
                    this._addItem(b),
                    d = d || b.overlay,
                    c = c || !b.overlay;
                this._separator.style.display = d && c ? "" : "none"
            }
        },
        _onLayerChange: function(a) {
            var b = this._layers[d.stamp(a.layer)];
            b && (this._handlingClick || this._update(),
            (a = b.overlay ? "layeradd" === a.type ? "overlayadd" : "overlayremove" : "layeradd" === a.type ? "baselayerchange" : null ) && this._map.fire(a, b))
        },
        _createRadioElement: function(a, c) {
            var d = '<input type="radio" class="leaflet-control-layers-selector" name="' + a + '"';
            c && (d += ' checked="checked"');
            var d = d + "/>"
              , e = b.createElement("div");
            return e.innerHTML = d,
            e.firstChild
        },
        _addItem: function(a) {
            var c, e = b.createElement("label"), g = this._map.hasLayer(a.layer);
            a.overlay ? (c = b.createElement("input"),
            c.type = "checkbox",
            c.className = "leaflet-control-layers-selector",
            c.defaultChecked = g) : c = this._createRadioElement("leaflet-base-layers", g);
            c.layerId = d.stamp(a.layer);
            d.DomEvent.on(c, "click", this._onInputClick, this);
            g = b.createElement("span");
            g.innerHTML = " " + a.name;
            e.appendChild(c);
            e.appendChild(g);
            return (a.overlay ? 
            this._overlaysList : this._baseLayersList).appendChild(e),
            e
        },
        _onInputClick: function() {
            var a, b, c, d = this._form.getElementsByTagName("input"), e = d.length;
            this._handlingClick = !0;
            for (a = 0; e > a; a++)
                b = d[a],
                c = this._layers[b.layerId],
                b.checked && !this._map.hasLayer(c.layer) ? this._map.addLayer(c.layer) : !b.checked && this._map.hasLayer(c.layer) && this._map.removeLayer(c.layer);
            this._handlingClick = !1;
            this._refocusOnMap()
        },
        _expand: function() {
            d.DomUtil.addClass(this._container, "leaflet-control-layers-expanded")
        },
        _collapse: function() {
            this._container.className = 
            this._container.className.replace(" leaflet-control-layers-expanded", "")
        }
    });
    d.control.layers = function(a, b, c) {
        return new d.Control.Layers(a,b,c)
    }
    ;
    d.PosAnimation = d.Class.extend({
        includes: d.Mixin.Events,
        run: function(a, b, c, e) {
            this.stop();
            this._el = a;
            this._inProgress = !0;
            this._newPos = b;
            this.fire("start");
            a.style[d.DomUtil.TRANSITION] = "all " + (c || .25) + "s cubic-bezier(0,0," + (e || .5) + ",1)";
            d.DomEvent.on(a, d.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            d.DomUtil.setPosition(a, b);
            d.Util.falseFn(a.offsetWidth);
            this._stepTimer = setInterval(d.bind(this._onStep, this), 50)
        },
        stop: function() {
            this._inProgress && (d.DomUtil.setPosition(this._el, this._getPos()),
            this._onTransitionEnd(),
            d.Util.falseFn(this._el.offsetWidth))
        },
        _onStep: function() {
            var a = this._getPos();
            return a ? (this._el._leaflet_pos = a,
            void this.fire("step")) : void this._onTransitionEnd()
        },
        _transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,
        _getPos: function() {
            var b, c, e = a.getComputedStyle(this._el);
            if (d.Browser.any3d) {
                if (c = e[d.DomUtil.TRANSFORM].match(this._transformRe),
                !c)
                    return;
                b = parseFloat(c[1]);
                c = parseFloat(c[2])
            } else
                b = parseFloat(e.left),
                c = parseFloat(e.top);
            return new d.Point(b,c,!0)
        },
        _onTransitionEnd: function() {
            d.DomEvent.off(this._el, d.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
            this._inProgress && (this._inProgress = !1,
            this._el.style[d.DomUtil.TRANSITION] = "",
            this._el._leaflet_pos = this._newPos,
            clearInterval(this._stepTimer),
            this.fire("step").fire("end"))
        }
    });
    d.Map.include({
        setView: function(a, b, e) {
            if (b = b === c ? this._zoom : this._limitZoom(b),
            a = this._limitCenter(d.latLng(a), 
            b, this.options.maxBounds),
            e = e || {},
            this._panAnim && this._panAnim.stop(),
            this._loaded && !e.reset && !0 !== e)
                if (e.animate !== c && (e.zoom = d.extend({
                    animate: e.animate
                }, e.zoom),
                e.pan = d.extend({
                    animate: e.animate
                }, e.pan)),
                this._zoom !== b ? this._tryAnimatedZoom && this._tryAnimatedZoom(a, b, e.zoom) : this._tryAnimatedPan(a, e.pan))
                    return clearTimeout(this._sizeTimer),
                    this;
            return this._resetView(a, b),
            this
        },
        panBy: function(a, b) {
            if (a = d.point(a).round(),
            b = b || {},
            !a.x && !a.y)
                return this;
            if (this._panAnim || (this._panAnim = new d.PosAnimation,
            this._panAnim.on({
                step: this._onPanTransitionStep,
                end: this._onPanTransitionEnd
            }, this)),
            b.noMoveStart || this.fire("movestart"),
            !1 !== b.animate) {
                d.DomUtil.addClass(this._mapPane, "leaflet-pan-anim");
                var c = this._getMapPanePos().subtract(a);
                this._panAnim.run(this._mapPane, c, b.duration || .25, b.easeLinearity)
            } else
                this._rawPanBy(a),
                this.fire("move").fire("moveend");
            return this
        },
        _onPanTransitionStep: function() {
            this.fire("move")
        },
        _onPanTransitionEnd: function() {
            d.DomUtil.removeClass(this._mapPane, "leaflet-pan-anim");
            this.fire("moveend")
        },
        _tryAnimatedPan: function(a, b) {
            var c = this._getCenterOffset(a)._floor();
            return !0 === (b && b.animate) || this.getSize().contains(c) ? (this.panBy(c, b),
            !0) : !1
        }
    });
    d.PosAnimation = d.DomUtil.TRANSITION ? d.PosAnimation : d.PosAnimation.extend({
        run: function(a, b, c, e) {
            this.stop();
            this._el = a;
            this._inProgress = !0;
            this._duration = c || .25;
            this._easeOutPower = 1 / Math.max(e || .5, .2);
            this._startPos = d.DomUtil.getPosition(a);
            this._offset = b.subtract(this._startPos);
            this._startTime = +new Date;
            this.fire("start");
            this._animate()
        },
        stop: function() {
            this._inProgress && (this._step(),
            this._complete())
        },
        _animate: function() {
            this._animId = d.Util.requestAnimFrame(this._animate, this);
            this._step()
        },
        _step: function() {
            var a = +new Date - this._startTime
              , b = 1E3 * this._duration;
            b > a ? this._runFrame(this._easeOut(a / b)) : (this._runFrame(1),
            this._complete())
        },
        _runFrame: function(a) {
            a = this._startPos.add(this._offset.multiplyBy(a));
            d.DomUtil.setPosition(this._el, a);
            this.fire("step")
        },
        _complete: function() {
            d.Util.cancelAnimFrame(this._animId);
            this._inProgress = 
            !1;
            this.fire("end")
        },
        _easeOut: function(a) {
            return 1 - Math.pow(1 - a, this._easeOutPower)
        }
    });
    d.Map.mergeOptions({
        zoomAnimation: !0,
        zoomAnimationThreshold: 4
    });
    d.DomUtil.TRANSITION && d.Map.addInitHook(function() {
        (this._zoomAnimated = this.options.zoomAnimation && d.DomUtil.TRANSITION && d.Browser.any3d && !d.Browser.android23 && !d.Browser.mobileOpera) && d.DomEvent.on(this._mapPane, d.DomUtil.TRANSITION_END, this._catchTransitionEnd, this)
    }
    );
    d.Map.include(d.DomUtil.TRANSITION ? {
        _catchTransitionEnd: function(a) {
            this._animatingZoom && 
            0 <= a.propertyName.indexOf("transform") && this._onZoomTransitionEnd()
        },
        _nothingToAnimate: function() {
            return !this._container.getElementsByClassName("leaflet-zoom-animated").length
        },
        _tryAnimatedZoom: function(a, b, c) {
            if (this._animatingZoom)
                return !0;
            if (c = c || {},
            !this._zoomAnimated || !1 === c.animate || this._nothingToAnimate() || Math.abs(b - this._zoom) > this.options.zoomAnimationThreshold)
                return !1;
            var d = this.getZoomScale(b)
              , e = this._getCenterOffset(a)._divideBy(1 - 1 / d)
              , g = this._getCenterLayerPoint()._add(e);
            return !0 === 
            c.animate || this.getSize().contains(e) ? (this.fire("movestart").fire("zoomstart"),
            this._animateZoom(a, b, g, d, null , !0),
            !0) : !1
        },
        _animateZoom: function(a, b, c, e, g, n) {
            this._animatingZoom = !0;
            d.DomUtil.addClass(this._mapPane, "leaflet-zoom-anim");
            this._animateToCenter = a;
            this._animateToZoom = b;
            d.Draggable && (d.Draggable._disabled = !0);
            this.fire("zoomanim", {
                center: a,
                zoom: b,
                origin: c,
                scale: e,
                delta: g,
                backwards: n
            })
        },
        _onZoomTransitionEnd: function() {
            this._animatingZoom = !1;
            d.DomUtil.removeClass(this._mapPane, "leaflet-zoom-anim");
            this._resetView(this._animateToCenter, this._animateToZoom, !0, !0);
            d.Draggable && (d.Draggable._disabled = !1)
        }
    } : {});
    d.TileLayer.include({
        _animateZoom: function(a) {
            this._animating || (this._animating = !0,
            this._prepareBgBuffer());
            var b = this._bgBuffer
              , c = d.DomUtil.TRANSFORM
              , e = a.delta ? d.DomUtil.getTranslateString(a.delta) : b.style[c]
              , g = d.DomUtil.getScaleString(a.scale, a.origin);
            b.style[c] = a.backwards ? g + " " + e : e + " " + g
        },
        _endZoomAnim: function() {
            var a = this._tileContainer
              , b = this._bgBuffer;
            a.style.visibility = "";
            a.parentNode.appendChild(a);
            d.Util.falseFn(b.offsetWidth);
            this._animating = !1
        },
        _clearBgBuffer: function() {
            var a = this._map;
            !a || a._animatingZoom || a.touchZoom._zooming || (this._bgBuffer.innerHTML = "",
            this._bgBuffer.style[d.DomUtil.TRANSFORM] = "")
        },
        _prepareBgBuffer: function() {
            var a = this._tileContainer
              , b = this._bgBuffer
              , c = this._getLoadedTilesPercentage(b)
              , e = this._getLoadedTilesPercentage(a);
            return b && .5 < c && .5 > e ? (a.style.visibility = "hidden",
            void this._stopLoadingImages(a)) : (b.style.visibility = "hidden",
            b.style[d.DomUtil.TRANSFORM] = "",
            this._tileContainer = 
            b,
            b = this._bgBuffer = a,
            this._stopLoadingImages(b),
            void clearTimeout(this._clearBgBufferTimer))
        },
        _getLoadedTilesPercentage: function(a) {
            var b, c = a.getElementsByTagName("img"), d = 0;
            a = 0;
            for (b = c.length; b > a; a++)
                c[a].complete && d++;
            return d / b
        },
        _stopLoadingImages: function(a) {
            var b, c, e = Array.prototype.slice.call(a.getElementsByTagName("img"));
            a = 0;
            for (b = e.length; b > a; a++)
                c = e[a],
                c.complete || (c.onload = d.Util.falseFn,
                c.onerror = d.Util.falseFn,
                c.src = d.Util.emptyImageUrl,
                c.parentNode.removeChild(c))
        }
    });
    d.Map.include({
        _defaultLocateOptions: {
            watch: !1,
            setView: !1,
            maxZoom: 1 / 0,
            timeout: 1E4,
            maximumAge: 0,
            enableHighAccuracy: !1
        },
        locate: function(a) {
            if (a = this._locateOptions = d.extend(this._defaultLocateOptions, a),
            !navigator.geolocation)
                return this._handleGeolocationError({
                    code: 0,
                    message: "Geolocation not supported."
                }),
                this;
            var b = d.bind(this._handleGeolocationResponse, this)
              , c = d.bind(this._handleGeolocationError, this);
            return a.watch ? this._locationWatchId = navigator.geolocation.watchPosition(b, c, a) : navigator.geolocation.getCurrentPosition(b, c, a),
            this
        },
        stopLocate: function() {
            return navigator.geolocation && 
            navigator.geolocation.clearWatch(this._locationWatchId),
            this._locateOptions && (this._locateOptions.setView = !1),
            this
        },
        _handleGeolocationError: function(a) {
            var b = a.code;
            a = a.message || (1 === b ? "permission denied" : 2 === b ? "position unavailable" : "timeout");
            this._locateOptions.setView && !this._loaded && this.fitWorld();
            this.fire("locationerror", {
                code: b,
                message: "Geolocation error: " + a + "."
            })
        },
        _handleGeolocationResponse: function(a) {
            var b = a.coords.latitude
              , c = a.coords.longitude
              , e = new d.LatLng(b,c)
              , g = 180 * a.coords.accuracy / 
            40075017
              , n = g / Math.cos(d.LatLng.DEG_TO_RAD * b)
              , b = d.latLngBounds([b - g, c - n], [b + g, c + n])
              , c = this._locateOptions;
            c.setView && (c = Math.min(this.getBoundsZoom(b), c.maxZoom),
            this.setView(e, c));
            var e = {
                latlng: e,
                bounds: b,
                timestamp: a.timestamp
            }, p;
            for (p in a.coords)
                "number" == typeof a.coords[p] && (e[p] = a.coords[p]);
            this.fire("locationfound", e)
        }
    })
}
(window, document);
function readOpenCTM_RAW(a, b) {
    var c = a.getString(4);
    if ("INDX" != c)
        return null ;
    for (var e = b.vertexCount, d = b.triangleCount, g = function(a) {
        return a.buffer.slice(a.byteOffset, a.byteOffset + a.length)
    }
    , f = b.indices = new Uint16Array(3 * d), c = 0, d = 3 * d; c < d; c++)
        f[c] = a.getInt32();
    c = a.getString(4);
    if ("VERT" != c)
        return null ;
    b.vertices = new Float32Array(g(a.getBytes(12 * e)));
    if (b.flags & 1) {
        c = a.getString(4);
        if ("NORM" != c)
            return null ;
        b.normals = new Float32Array(g(a.getBytes(12 * e)))
    }
    for (f = 0; f < b.texMapCount; f++) {
        c = a.getString(4);
        if ("TEXC" != c)
            return null ;
        c = {
            name: a.getString(a.getInt32()),
            file: a.getString(a.getInt32()),
            data: new Float32Array(g(a.getBytes(8 * e)))
        };
        b.uvs.push(c)
    }
    for (f = 0; f < b.attribMapCount; f++) {
        c = a.getString(4);
        if ("ATTR" != c)
            return null ;
        c = {
            name: a.getString(a.getInt32()),
            data: new Float32Array(g(a.getBytes(16 * e)))
        };
        if (-1 != c.name.indexOf("Color")) {
            for (var d = new Float32Array(c.data.length / 4 * 3), k = 0, h = 0, l = d.length; k < l; k += 3,
            h += 4)
                d[k] = c.data[h],
                d[k + 1] = c.data[h + 1],
                d[k + 2] = c.data[h + 2];
            b.colors = d
        } else
            b.attrs.push(c)
    }
}
var readOpenCTM = function(a) {
    function b(a) {
        for (var b = 0; b < a.uvs.length; b++)
            for (var c = a.uvs[b].data, d = 0, e = 2 * a.vertexCount; d < e; d += 2) {
                var m = c[d]
                  , n = c[d + 1];
                if (2 < m || 0 > m || 2 < n || 0 > n) {
                    a.uvs[b].isPattern = !0;
                    break
                }
            }
    }
    function c(a) {
        a.vbstride = 3;
        a.flags & 1 && (a.vbstride += 3);
        a.vbstride += 2 * a.texMapCount;
        0 < a.attribMapCount && (a.vbstride += 3);
        var b = a.vb = new Float32Array(a.vertexCount * a.vbstride)
          , c = a.vertices
          , d = a.normals
          , e = a.colors;
        a.vblayout = {};
        var m = 0;
        a.vblayout.position = {
            offset: m,
            itemSize: 3
        };
        m += 3;
        d && (a.vblayout.normal = 
        {
            offset: m,
            itemSize: 3
        },
        m += 3);
        for (var n = 0; n < a.uvs.length; n++) {
            var p = "uv";
            n && (p += (n + 1).toString());
            a.vblayout[p] = {
                offset: m,
                itemSize: 2,
                isPattern: a.uvs[n].isPattern
            };
            m += 2
        }
        e && (a.vblayout.color = {
            offset: m,
            itemSize: 3
        });
        n = m = 0;
        for (p = a.vertexCount; n < p; n++) {
            b[m++] = c[3 * n];
            b[m++] = c[3 * n + 1];
            b[m++] = c[3 * n + 2];
            d && (b[m++] = d[3 * n],
            b[m++] = d[3 * n + 1],
            b[m++] = d[3 * n + 2]);
            for (var t = 0; t < a.uvs.length; t++)
                b[m++] = a.uvs[t].data[2 * n],
                b[m++] = a.uvs[t].data[2 * n + 1];
            e && (b[m++] = e[3 * n],
            b[m++] = e[3 * n + 1],
            b[m++] = e[3 * n + 2])
        }
        delete a.vertices;
        delete a.normals;
        delete a.uvs;
        delete a.colors
    }
    if ("OCTM" != a.getString(4) || 5 != a.getInt32())
        return null ;
    var e = a.getString(3);
    a.getUint8();
    var d = {
        vertices: null ,
        indices: null ,
        normals: null ,
        colors: null ,
        uvs: [],
        attrs: []
    };
    d.vertexCount = a.getInt32();
    d.triangleCount = a.getInt32();
    d.texMapCount = a.getInt32();
    d.attribMapCount = a.getInt32();
    d.flags = a.getInt32();
    d.comment = a.getString(a.getInt32());
    return "RAW" == e ? (readOpenCTM_RAW(a, d),
    computeBounds(d),
    b(d),
    c(d),
    d) : "MG2" == e ? (readOpenCTM_MG2(a, d),
    computeBounds(d),
    b(d),
    c(d),
    d) : null 
}
  , readLines = 
function(a) {
    var b = {
        isLines: !0,
        vertices: null ,
        indices: null ,
        colors: null ,
        normals: null ,
        uvs: [],
        attrs: []
    };
    b.vertexCount = a.readU32V();
    var c = a.readU32V()
      , e = a.readU32V()
      , d = 0 != a.stream.getUint8()
      , g = function(a) {
        return a.buffer.slice(a.byteOffset, a.byteOffset + a.length)
    }
    ;
    b.vertices = new Float32Array(g(a.stream.getBytes(12 * b.vertexCount)));
    if (d)
        for (var d = new Float32Array(g(a.stream.getBytes(16 * b.vertexCount))), f = b.colors = new Float32Array(d.length / 4 * 3), k = 0, h = 0, l = f.length; k < l; k += 3,
        h += 4)
            f[k] = d[h],
            f[k + 1] = d[h + 1],
            f[k + 
            2] = d[h + 2];
    c = new Int32Array(g(a.stream.getBytes(4 * c)));
    b.polyLineBoundBuffer = new Int32Array(g(a.stream.getBytes(4 * e)));
    a = [];
    for (g = 0; g < e; g++)
        for (d = b.polyLineBoundBuffer[g]; d + 1 < b.polyLineBoundBuffer[g + 1]; d++)
            a.push(c[d]),
            a.push(c[d + 1]);
    b.indices = new Uint16Array(a.length);
    for (g = 0; g < a.length; g++)
        b.indices[g] = a[g];
    computeBounds(b);
    return b
}
  , computeBounds = function(a) {
    for (var b = Infinity, c = Infinity, e = Infinity, d = -Infinity, g = -Infinity, f = -Infinity, k = a.vertices, h = 0, l = 3 * a.vertexCount; h < l; h += 3) {
        var m = k[h]
          , n = k[h + 
        1]
          , p = k[h + 2];
        m < b && (b = m);
        n < c && (c = n);
        p < e && (e = p);
        m > d && (d = m);
        n > g && (g = n);
        p > f && (f = p)
    }
    a.boundingBox = new THREE.Box3;
    a.boundingBox.min.set(b, c, e);
    a.boundingBox.max.set(d, g, f);
    b = .5 * (b + d);
    c = .5 * (c + g);
    e = .5 * (e + f);
    a.boundingSphere = new THREE.Sphere;
    a.boundingSphere.center.set(b, c, e);
    h = f = 0;
    for (l = 3 * a.vertexCount; h < l; h += 3)
        g = k[h] - b,
        d = k[h + 1] - c,
        m = k[h + 2] - e,
        g = g * g + d * d + m * m,
        g > f && (f = g);
    a.boundingSphere.radius = Math.sqrt(f)
}
;
function readGeometry(a, b, c) {
    return (b = a.seekToEntry(b)) ? "Autodesk.CloudPlatform.OpenCTM" == b.entryType ? readOpenCTM(a.stream) : "Autodesk.CloudPlatform.Lines" == b.entryType ? readLines(a) : null  : null 
}
;function convertMaterials(a) {
    var b = function(a, b) {
        var c = new THREE.Color;
        if (!a || !a.colors)
            return c.setRGB(1, 0, 0);
        var d = a.colors[b];
        if (!d)
            return c.setRGB(0, 0, 0);
        d = d.values;
        if (!d || !d.length)
            return c.setRGB(1, 0, 0);
        d = d[0];
        return c.setRGB(d.r, d.g, d.b)
    }
      , c = function(a, b) {
        if (!a || !a.scalars)
            return 0;
        var c = a.scalars[b];
        return c ? c.values[0] : void 0
    }
      , e = function(a, b) {
        if (!a || !a.booleans)
            return 0;
        var c = a.booleans;
        return c ? c[b] : void 0
    }
      , d = a.materials.materials;
    a.simplemats = {};
    for (var g in d) {
        var f = d[g]
          , k = f.materials
          , 
        h = k[f.userassets[0]];
        if (h && "SimplePhong" == h.definition) {
            var f = h.properties
              , l = {};
            l.ambient = b(f, "generic_ambient");
            l.color = b(f, "generic_diffuse");
            l.specular = b(f, "generic_specular");
            l.emissive = b(f, "generic_emissive");
            var m = c(f, "generic_glossiness");
            m || (m = 30);
            l.shininess = m;
            (m = c(f, "generic_transparency")) || (m = 0);
            l.opacity = 1 - m;
            (m = c(f, "generic_reflectivity_at_0deg")) || (m = 0);
            l.reflectivity = m;
            m = e(f, "generic_is_metal");
            void 0 !== m && (l.metal = m);
            m = e(f, "generic_backface_cull");
            void 0 !== m && (l.doubleSided = !m);
            l.transparent = 
            h.transparent;
            var h = h.textures, n;
            for (n in h) {
                var m = k[h[n].connections[0]].properties
                  , p = m.uris.unifiedbitmap_Bitmap.values[0]
                  , t = null ;
                if (p)
                    if ("generic_diffuse" == n) {
                        if (t = "map",
                        !l.color || 0 == l.color.r && 0 == l.color.g && 0 == l.color.b)
                            l.color = new THREE.Color(1,1,1)
                    } else
                        "generic_bump" == n ? (t = e(f, "generic_bump_is_normal") ? "normalMap" : "bumpMap",
                        l.bumpScale = c(f, "generic_bump_amount")) : "generic_specular" == n ? t = "specularMap" : "generic_reflection" == n ? t = "envMap" : "generic_alpha" == n && (t = "opacityMap");
                t && (l["uri_" + t] = p,
                (p = 
                c(m, "texture_UScale")) && (l["uscale_" + t] = p),
                (p = c(m, "texture_VScale")) && (l["vscale_" + t] = p))
            }
            a.simplemats[g] = l
        }
    }
}
;function readLightDefinition(a, b) {
    var c = a.seekToEntry(b);
    if (!c || 1 < c.version)
        return null ;
    c = a.stream;
    return {
        position: a.readVector3f(),
        dir: a.readVector3f(),
        r: c.getFloat32(),
        g: c.getFloat32(),
        b: c.getFloat32(),
        intensity: c.getFloat32(),
        spotAngle: c.getFloat32(),
        size: c.getFloat32(),
        type: c.getUint8()
    }
}
;function readCameraDefinition(a, b) {
    var c = a.seekToEntry(b.definition);
    if (!c || 2 < c.version)
        return null ;
    var e = a.stream
      , d = {
        isPerspective: !e.getUint8(),
        position: a.readVector3f(),
        target: a.readVector3f(),
        up: a.readVector3f(),
        aspect: e.getFloat32(),
        fov: THREE.Math.radToDeg(e.getFloat32())
    };
    2 > c.version && (e.getFloat32(),
    e.getFloat32());
    d.orthoScale = e.getFloat32();
    d.inst = b;
    return d
}
;function FragList() {
    this.length = 0
}
function readGeometryMetadata(a, b) {
    var c = a.getEntryCounts()
      , e = a.stream;
    b.length = c;
    for (var d = b.fragTypes = new Uint8Array(c), g = b.primCounts = new Uint16Array(c), f = b.packIds = new Int32Array(c), k = b.entityIndexes = new Int32Array(c), h = 0; h < c && a.seekToEntry(h); h++)
        d[h] = e.getUint8(),
        e.seek(e.offset + 24),
        g[h] = e.getUint16(),
        f[h] = parseInt(a.readString()),
        k[h] = a.readU32V()
}
function readFragments(a, b) {
    function c(a) {
        a *= 6;
        for (var b = 0; 6 > b; b++)
            f[a++] = g.getFloat32()
    }
    function e(a, b, c) {
        a *= 6;
        for (var d = 0; 6 > d; d++)
            f[a++] = g.getFloat32() + b[c + d % 3]
    }
    var d = a.getEntryCounts()
      , g = a.stream;
    b.length = d;
    b.numLoaded = 0;
    for (var f = b.boxes = new Float32Array(6 * d), k = b.transforms = new Float32Array(16 * d), h = b.materials = new Int32Array(d), l = b.packIds = new Int32Array(d), m = b.entityIndexes = new Int32Array(d), n = b.geomDataIndexes = new Int32Array(d), d = b.fragId2dbId = new Int32Array(d), p = 0, t = b.length; p < t; p++) {
        var v = 
        a.seekToEntry(p);
        if (!v)
            break;
        if (4 < v.version)
            break;
        h[p] = a.readU32V();
        2 < v.version ? n[p] = a.readU32V() : (l[p] = parseInt(a.readString()),
        m[p] = a.readU32V());
        a.readTransform(p, k, 16 * p);
        3 < v.version ? e(p, k, 16 * p + 12) : c(p);
        1 < v.version && (d[p] = a.readU32V());
        a.readPathID()
    }
}
function filterFragments(a, b) {
    a.length = b.length;
    a.numLoaded = 0;
    for (var c = a.length, e = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity], d = new Float32Array(6 * c), g = new Float32Array(16 * c), f = new Int32Array(c), k = new Int32Array(c), c = new Int32Array(c), h = {}, l = 0; l < b.length; ++l) {
        for (var m = b[l], n = 6 * m, p = 6 * l, t = 0; 6 > t; ++t)
            d[p++] = a.boxes[n++];
        n = 16 * m;
        p = 16 * l;
        for (t = 0; 16 > t; ++t)
            g[p++] = a.transforms[n++];
        f[l] = a.materials[m];
        k[l] = a.packIds[m];
        c[l] = a.entityIndexes[m];
        t = a.packIds[m] + ":" + a.entityIndexes[m];
        m = h[t];
        void 0 == 
        m ? h[t] = l : Array.isArray(m) ? m.push(l) : h[t] = [m, l];
        m = 6 * l;
        for (t = 0; 3 > t; ++t)
            d[m + t] < e[t] && (e[t] = d[m + t]);
        for (t = 3; 6 > t; ++t)
            d[m + t] > e[t] && (e[t] = d[m + t])
    }
    a.boxes = d;
    a.transforms = g;
    a.materials = f;
    a.packIds = k;
    a.entityIndexes = c;
    a.mesh2frag = h;
    return e
}
;function readInstance(a, b) {
    var c = a.seekToEntry(b);
    return !c || 1 < c.version ? null  : {
        definition: a.stream.getUint32(),
        transform: a.readTransform(),
        instanceNodePath: a.readPathID()
    }
}
;function Package() {
    this.fragments = this.metadata = this.simplemats = this.materials = this.manifest = null ;
    this.geompacks = [];
    this.instances = [];
    this.cameras = [];
    this.lights = [];
    this.propertydb = {
        attrs: [],
        avs: [],
        ids: [],
        values: [],
        offsets: []
    };
    this.bbox = null ;
    this.pendingRequests = 0
}
Package.prototype.loadAsyncResource = function(a, b, c, e) {
    function d(b) {
        g.pendingRequests--;
        this.response && (b = new Uint8Array(this.response),
        31 == b[0] && 139 == b[1] && (b = (new Zlib.Gunzip(b)).decompress()),
        e(b));
        0 == g.pendingRequests && g.postLoad(a)
    }
    if (c)
        e(c);
    else {
        var g = this;
        this.pendingRequests++;
        (new Xhr(a.errorHandler,a.auth,a.viewing_url)).get(a.basePath + b, a.headers, "arraybuffer", d)
    }
}
;
Package.prototype.load = function(a, b) {
    var c = this
      , e = new Zlib.Unzip(b)
      , d = e.decompress("manifest.json");
    if (!d)
        return !1;
    var g = new InputStream(d)
      , f = JSON.parse(g.getString(d.byteLength))
      , d = e.decompress("metadata.json")
      , g = new InputStream(d);
    3 < d.byteLength && 0 !== d[3] && (this.metadata = JSON.parse(g.getString(d.byteLength)).metadata) && (g = this.metadata["world bounding box"],
    this.bbox = new THREE.Box3({
        x: g.minXYZ[0],
        y: g.minXYZ[1],
        z: g.minXYZ[2]
    },{
        x: g.maxXYZ[0],
        y: g.maxXYZ[1],
        z: g.maxXYZ[2]
    }));
    this.manifest = f;
    for (var k = 
    f.typesets, g = {}, d = 0; d < k.length; d++) {
        var h = k[d];
        g[h.id] = h.types
    }
    f = f.assets;
    for (d = 0; d < f.length; d++) {
        h = f[d];
        k = h.type;
        0 == k.indexOf("Autodesk.CloudPlatform.") && (k = k.substr(23));
        var l = h.URI
          , m = h.typeset ? g[h.typeset] : null ;
        0 != l.indexOf("embed:/") && ("PackFile" == k ? "Autodesk.CloudPlatform.Geometry" == (m ? m[0]["class"] : null ) && this.geompacks.push({
            id: h.id,
            uri: l
        }) : "PropertyAttributes" == k ? this.propertydb.attrs.push(l) : "PropertyAVs" == k ? this.propertydb.avs.push(l) : "PropertyIDs" == k ? this.propertydb.ids.push(l) : "PropertyOffsets" == 
        k ? this.propertydb.offsets.push(l) : "PropertyValues" == k && this.propertydb.values.push(l));
        var h = h.URI, n;
        0 == h.indexOf("embed:/") && (h = h.substr(7),
        n = e.decompress(h));
        "ProteinMaterials" == k ? -1 == h.indexOf("Protein") ? this.loadAsyncResource(a, h, n, function(a) {
            a = (new InputStream(a)).getString(a.byteLength);
            0 < a.length && (c.materials = JSON.parse(a),
            convertMaterials(c))
        }
        ) : this.proteinMaterials = !0 : "FragmentList" == k ? this.loadAsyncResource(a, h, n, function(a) {
            a = new PackFileReader(a);
            var b = c.fragments = new FragList;
            readFragments(a, 
            b)
        }
        ) : "GeometryMetadataList" == k ? this.loadAsyncResource(a, h, n, function(a) {
            a = new PackFileReader(a);
            c.geomMetadata = {};
            readGeometryMetadata(a, c.geomMetadata)
        }
        ) : "PackFile" == k && (-1 != h.indexOf("CameraDefinitions.bin") ? this.loadAsyncResource(a, h, n, function(a) {
            c.camDefPack = new PackFileReader(a)
        }
        ) : -1 != h.indexOf("CameraList.bin") ? this.loadAsyncResource(a, h, n, function(a) {
            c.camInstPack = new PackFileReader(a)
        }
        ) : -1 != h.indexOf("LightDefinitions.bin") ? this.loadAsyncResource(a, h, n, function(a) {
            c.lightDefPack = new PackFileReader(a)
        }
        ) : 
        -1 != h.indexOf("LightList.bin") && this.loadAsyncResource(a, h, n, function(a) {
            c.lightInstPack = new PackFileReader(a)
        }
        ))
    }
    0 == this.pendingRequests && this.postLoad(a)
}
;
Package.prototype.postLoad = function(a) {
    if (this.camDefPack && this.camInstPack) {
        for (var b = 0, c = this.camInstPack.getEntryCounts(); b < c; b++) {
            var e = readInstance(this.camInstPack, b);
            this.cameras.push(readCameraDefinition(this.camDefPack, e))
        }
        delete this.camDefPack;
        delete this.camInstPack
    }
    if (this.lightDefPack && this.lightInstPack) {
        b = 0;
        for (c = this.lightInstPack.getEntryCounts(); b < c; b++)
            e = readInstance(this.lightInstPack, b),
            this.lights.push(readLightDefinition(this.lightDefPack, e.definition));
        delete this.lightInstPack;
        delete this.lightDefPack
    }
    e = this.fragments;
    if (this.geomMetadata) {
        for (var c = this.geomMetadata, b = 0, d = e.length; b < d; b++) {
            var g = e.geomDataIndexes[b];
            e.entityIndexes[b] = c.entityIndexes[g];
            e.packIds[b] = c.packIds[g]
        }
        delete this.geomMetadata
    }
    for (var g = e.mesh2frag = {}, c = e.packIds, f = e.entityIndexes, b = 0, d = e.length; b < d; b++) {
        var k = c[b] + ":" + f[b]
          , h = g[k];
        void 0 === h ? g[k] = b : Array.isArray(h) ? h.push(b) : g[k] = [h, b]
    }
    if (!this.bbox) {
        c = [Infinity, Infinity, Infinity, -Infinity, -Infinity, -Infinity];
        d = e.boxes;
        g = 0;
        for (e = e.length; g < 
        e; g++) {
            f = 6 * g;
            for (b = 0; 3 > b; b++)
                d[f + b] < c[b] && (c[b] = d[f + b]);
            for (b = 3; 6 > b; b++)
                d[f + b] > c[b] && (c[b] = d[f + b])
        }
        this.bbox = new THREE.Box3(new THREE.Vector3(c[0],c[1],c[2]),new THREE.Vector3(c[3],c[4],c[5]))
    }
    g = a.objectIds;
    if (null  != g) {
        c = [];
        e = [];
        for (b = 0; b < g.length; ++b)
            for (d = 0; d < this.fragments.length; ++d)
                this.fragments.fragId2dbId[d] == g[b] && (c.push(this.fragments.packIds[d]),
                e.push(d));
        d = 1;
        g = c.length;
        for (b = 1; b < g; ) {
            for (; b < g && c[b] == c[b - 1]; )
                ++b;
            if (g == b)
                break;
            c[d++] = c[b++]
        }
        c.splice(d - 1, g - d);
        g = [];
        for (b = 0; b < this.geompacks.length; ++b)
            for (d = 
            0; d < c.length; ++d)
                parseInt(this.geompacks[b].id) == c[d] && g.push(this.geompacks[b]);
        this.geompacks = g;
        b = filterFragments(this.fragments, e);
        this.bbox = new THREE.Box3(new THREE.Vector3(b[0],b[1],b[2]),new THREE.Vector3(b[3],b[4],b[5]))
    }
    a.loadDoneCB(!0)
}
;
function InputStream(a) {
    this.buffer = a;
    this.offset = 0;
    this.byteLength = a.length;
    this.convBuf = new ArrayBuffer(8);
    this.convUint8 = new Uint8Array(this.convBuf);
    this.convUint16 = new Uint16Array(this.convBuf);
    this.convInt32 = new Int32Array(this.convBuf);
    this.convUint32 = new Uint32Array(this.convBuf);
    this.convFloat32 = new Float32Array(this.convBuf);
    this.convFloat64 = new Float64Array(this.convBuf)
}
InputStream.prototype.seek = function(a) {
    this.offset = a
}
;
InputStream.prototype.getBytes = function(a) {
    var b = new Uint8Array(this.buffer.buffer,this.offset,a);
    this.offset += a;
    return b
}
;
InputStream.prototype.getUint8 = function() {
    return this.buffer[this.offset++]
}
;
InputStream.prototype.getUint16 = function() {
    this.convUint8[0] = this.buffer[this.offset++];
    this.convUint8[1] = this.buffer[this.offset++];
    return this.convUint16[0]
}
;
InputStream.prototype.getInt32 = function() {
    var a = this.buffer
      , b = this.convUint8
      , c = this.offset;
    b[0] = a[c];
    b[1] = a[c + 1];
    b[2] = a[c + 2];
    b[3] = a[c + 3];
    this.offset += 4;
    return this.convInt32[0]
}
;
InputStream.prototype.getUint32 = function() {
    var a = this.buffer
      , b = this.convUint8
      , c = this.offset;
    b[0] = a[c];
    b[1] = a[c + 1];
    b[2] = a[c + 2];
    b[3] = a[c + 3];
    this.offset += 4;
    return this.convUint32[0]
}
;
InputStream.prototype.getFloat32 = function() {
    var a = this.buffer
      , b = this.convUint8
      , c = this.offset;
    b[0] = a[c];
    b[1] = a[c + 1];
    b[2] = a[c + 2];
    b[3] = a[c + 3];
    this.offset += 4;
    return this.convFloat32[0]
}
;
InputStream.prototype.getFloat64 = function() {
    for (var a = this.buffer, b = this.convUint8, c = this.offset, e = 0; 8 > e; e++)
        b[e] = a[c + e];
    this.offset += 8;
    return this.convFloat64[0]
}
;
InputStream.prototype.getString = function(a) {
    for (var b = this.buffer, c = "", e = this.offset, d = this.offset + a; e < d; e++)
        c += String.fromCharCode(b[e]);
    this.offset += a;
    return decodeURIComponent(escape(c))
}
;
function PackFileReader(a) {
    31 == a[0] && 139 == a[1] && (a = (new Zlib.Gunzip(a)).decompress());
    this.tempQuat = new THREE.Quaternion;
    this.tempTrans = new THREE.Vector3;
    this.tempScale = new THREE.Vector3;
    this.tempMat = new THREE.Matrix4;
    a = this.stream = new InputStream(a);
    var b = a.getInt32();
    this.type = a.getString(b);
    this.version = a.getInt32();
    this.types = null ;
    this.entryOffsets = [];
    a.seek(a.byteLength - 8);
    var c = a.getUint32();
    this.typesOffset = a.getUint32();
    a.seek(this.typesOffset);
    var e = this.readU32V();
    this.types = [];
    for (b = 0; b < 
    e; ++b)
        this.types.push({
            entryClass: this.readString(),
            entryType: this.readString(),
            version: this.readU32V()
        });
    a.seek(c);
    c = this.readU32V();
    e = this.entryOffsets;
    for (b = 0; b < c; ++b)
        e.push(a.getUint32());
    a.seek(0)
}
PackFileReader.prototype.readVarint = function() {
    var a, b = 0, c = 0;
    do
        a = this.stream.getUint8(),
        b |= (a & 127) << c,
        c += 7;
    while (a & 128);return b
}
;
PackFileReader.prototype.readU32V = PackFileReader.prototype.readVarint;
PackFileReader.prototype.readString = function() {
    return this.stream.getString(this.readU32V())
}
;
PackFileReader.prototype.readVector3f = function() {
    var a = this.stream;
    return new THREE.Vector3(a.getFloat32(),a.getFloat32(),a.getFloat32())
}
;
PackFileReader.prototype.readTransform = function(a, b, c) {
    function e(a) {
        a.set(f.getFloat32(), f.getFloat32(), f.getFloat32(), f.getFloat32())
    }
    function d(a) {
        a.set(f.getFloat64(), f.getFloat64(), f.getFloat64())
    }
    function g() {
        m.identity();
        for (var a = 0; 3 > a; ++a)
            for (var b = 0; 3 > b; ++b)
                m.elements[4 * a + b] = f.getFloat32()
    }
    var f = this.stream
      , k = this.tempTrans
      , h = this.tempQuat
      , l = this.tempScale
      , m = this.tempMat;
    switch (f.getUint8()) {
    case 4:
        m.identity();
        break;
    case 0:
        d(k);
        m.makeTranslation(k.x, k.y, k.z);
        break;
    case 1:
        e(h);
        d(k);
        m.compose(k, 
        h, l.set(1, 1, 1));
        break;
    case 2:
        var n = f.getFloat32();
        e(h);
        d(k);
        m.compose(k, h, l.set(n, n, n));
        break;
    case 3:
        g(),
        d(k),
        m.setPosition(k)
    }
    if (void 0 !== a)
        for (a = m.elements,
        k = 0; 16 > k; k++)
            b[c++] = a[k];
    else
        return (new THREE.Matrix4).copy(m)
}
;
PackFileReader.prototype.getEntryCounts = function() {
    return this.entryOffsets.length
}
;
PackFileReader.prototype.seekToEntry = function(a) {
    var b = this.getEntryCounts();
    if (a >= b)
        return null ;
    this.stream.seek(this.entryOffsets[a]);
    a = this.stream.getUint32();
    return a >= this.types.length ? null  : this.types[a]
}
;
PackFileReader.prototype.readPathID = function() {
    var a = this.stream;
    if (2 > this.version) {
        var b = a.getUint16();
        if (!b)
            return null ;
        a.getUint16();
        if (1 == b)
            return "";
        for (var c = a.getUint16(), e = 2; e < b; ++e)
            c += "/" + a.getUint16()
    } else {
        b = this.readU32V();
        if (!b)
            return null ;
        this.readU32V();
        if (1 == b)
            return "";
        c = this.readU32V();
        for (e = 2; e < b; ++e)
            c += "/" + this.readU32V()
    }
    return c
}
;
function PropertyDatabase(a) {
    function b(a) {
        for (var b = "", c = 0; c < a.length; c++)
            b += String.fromCharCode(a[c]);
        a = decodeURIComponent(escape(b));
        return JSON.parse(a)
    }
    function c(a, b) {
        for (var c = b, d = ""; c < a.length - 1; ) {
            var e = a[c];
            if (44 == e && (10 == a[c + 1] || 13 == a[c + 1]))
                break;
            if (10 == e || 13 == e)
                break;
            d += String.fromCharCode(e);
            c++
        }
        c = decodeURIComponent(escape(d));
        return JSON.parse(c)
    }
    function e(a, b) {
        for (var c = 0, d = 0, e = a.length; d < e; d++)
            44 == a[d] && c++;
        c++;
        for (var e = new Uint32Array(c + (b ? 1 : 0)), d = 0, f = a.length; 91 != a[d] && d < f; )
            d++;
        if (d == a.length)
            return null ;
        d++;
        for (var g = !1, k = c = 0; d < f; ) {
            var h = a[d];
            48 <= h && 57 >= h ? (k = 10 * k + (h - 48),
            g = !0) : 44 == h || 93 == h ? g && (e[c++] = k,
            g = !1,
            k = 0) : (g = !1,
            k = 0);
            d++
        }
        return e
    }
    function d(a) {
        for (var b = 0, c = a.length - 1, d = 0; d < c; d++)
            44 != a[d] || 10 != a[d + 1] && 13 != a[d + 1] || b++;
        if (!b)
            return null ;
        b++;
        for (var e = new Uint32Array(b), b = d = 0; 91 != a[d] && d < c; )
            d++;
        d++;
        e[b++] = d;
        for (var f = !1; d < c; )
            10 == a[d] || 13 == a[d] ? f = !0 : f && (f = !1,
            e[b++] = d),
            d++;
        return e
    }
    var g, f, k, h, l, m, n, p, t, v, r;
    for (r in a.attrs) {
        g = b(a.attrs[r]);
        for (var u = 0; u < g.length; u++) {
            var w = 
            g[u][1];
            "__parent__" == w ? t = u : "__child__" == w ? p = u : "__name__" == w && (v = u)
        }
        break
    }
    for (r in a.avs) {
        k = e(a.avs[r], 0);
        delete a.avs;
        break
    }
    for (r in a.offsets) {
        f = e(a.offsets[r], 1);
        f[f.length - 1] = k.length / 2;
        delete a.offsets;
        break
    }
    for (r in a.values) {
        h = a.values[r];
        l = d(h);
        break
    }
    for (r in a.ids) {
        m = a.ids[r];
        n = d(m);
        break
    }
    this.getObjectCount = function() {
        return f.length - 1
    }
    ;
    this.getValueAt = function(a) {
        return c(h, l[a])
    }
    ;
    this.getIntValueAt = function(a) {
        var b = 0;
        for (a = l[a]; a < h.length - 1; ) {
            var c = h[a];
            if (44 == c && (10 == h[a + 1] || 13 == h[a + 
            1]))
                break;
            if (10 == c || 13 == c)
                break;
            48 <= c && 57 >= c && (b += 10 * b + (c - 48));
            a++
        }
        return b
    }
    ;
    this.getIdAt = function(a) {
        return c(m, n[a])
    }
    ;
    this.getObjectProperties = function(a) {
        var b = {
            dbId: a,
            name: "",
            properties: {}
        }
          , c = 2 * f[a + 1];
        for (a = 2 * f[a]; a < c; a += 2) {
            var d = k[a];
            if (d == v)
                d = this.getValueAt(k[a + 1]),
                b.name = d;
            else if (d != t && d != p) {
                var e = g[d]
                  , d = this.getValueAt(k[a + 1]);
                b.properties[e[0]] = null  != e[3] ? d + " " + e[3] : d
            }
        }
        return b
    }
    ;
    this.findRootNodes = function() {
        for (var a = [], b = 1, c = f.length; b < c; b++) {
            for (var d = !1, e = !1, g = !1, h = 2 * f[b + 1], l = 2 * f[b]; l < 
            h; l += 2) {
                var m = k[l];
                m == t ? this.getIntValueAt(k[l + 1]) && (e = !0) : m == p ? d = !0 : m == v && (g = !0)
            }
            d && g && !e && a.push(b)
        }
        return a
    }
    ;
    this.getNodeNameAndChildren = function(a) {
        for (var b = a.dbId, c = 2 * f[b + 1], d, b = 2 * f[b]; b < c; b += 2) {
            var e = k[b];
            e != t && (e == p ? (e = this.getValueAt(k[b + 1]),
            e = {
                dbId: e,
                parent: a
            },
            d ? d.push(e) : d = [e]) : e == v && (e = this.getValueAt(k[b + 1]),
            a.name = e))
        }
        return d
    }
    ;
    this.buildObjectTree = function(a, b, c, d) {
        c > d[0] && (d[0] = c);
        var e = this.getNodeNameAndChildren(a);
        if (e) {
            for (var f = 0; f < e.length; f++)
                this.buildObjectTree(e[f], b, c + 1, 
                d);
            for (f = 0; f < e.length; f++)
                if (e[f].children || void 0 !== e[f].fragIds)
                    a.children ? a.children.push(e[f]) : a.children = [e[f]]
        } else
            b = b[a.dbId],
            void 0 !== b && (a.fragIds = b)
    }
    ;
    this.bruteForceSearch = function(a) {
        a = a.toLowerCase();
        for (var b = [], c = [], d = 0, e = l.length; d < e; d++) {
            var g = this.getValueAt(d);
            "string" == typeof g ? -1 != g.toLowerCase().indexOf(a) && c.push(d) : -1 != g.toString().toLowerCase().indexOf(a) && c.push(d)
        }
        a = 1;
        for (e = f.length; a < e; a++)
            for (g = 2 * f[a + 1],
            d = 2 * f[a]; d < g; d += 2)
                if (-1 != c.indexOf(k[d + 1])) {
                    b.push(a);
                    break
                }
        return b
    }
}
;var Auth = function() {
    var a = function() {}
    ;
    a.prototype.configureOAuthNone = function() {
        this.oauthNone = !0;
        this.oauth2 = this.oauth1 = this.oauth0 = !1
    }
    ;
    a.prototype.configureOAuthZero = function(a) {
        this.oauthNone = !1;
        this.oauth0 = !0;
        this.oauth2 = this.oauth1 = !1;
        this.access_token = a
    }
    ;
    a.prototype.configureOAuthOne = function(a, c, e, d) {
        this.oauth0 = this.oauthNone = !1;
        this.oauth1 = !0;
        this.oauth2 = !1;
        this.oauth1msg = {
            method: "",
            action: "",
            parameters: {
                oauth_version: "1.0",
                oauth_consumer_key: a,
                oauth_timestamp: OAuth.timestamp(),
                oauth_nonce: OAuth.nonce(11),
                oauth_signature_method: "HMAC-SHA1",
                oauth_token: e
            }
        };
        this.oauth1accessor = {
            consumerSecret: c,
            tokenSecret: d
        }
    }
    ;
    a.prototype.configureOAuthTwo = function() {
        this.oauth1 = this.oauth0 = this.oauthNone = !1;
        this.oauth2 = !0;
        var a = new XMLHttpRequest;
        a.open("POST", "https://ec2-50-19-204-59.compute-1.amazonaws.com:19031/as/token.oauth2?client_id=vs-test-2leg&client_secret=Passw0rd1&grant_type=client_credentials", !1);
        a.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
        a.setRequestHeader("Access-Control-Allow-Origin", 
        "*");
        a.send();
        200 == a.status && (this.access_token = JSON.parse(a.responseText).access_token,
        console.log("access token : " + this.access_token))
    }
    ;
    a.prototype.getAuthHeader = function(a, c) {
        if (this.oauth2)
            return "Bearer " + this.access_token;
        this.oauth1msg.method = a;
        this.oauth1msg.action = c;
        OAuth.completeRequest(this.oauth1msg, this.oauth1accessor);
        var e = c;
        0 <= e.indexOf("?") && (e = e.substring(0, e.indexOf("?")));
        0 <= e.indexOf("#") && (e = e.substring(0, e.indexOf("#")));
        return OAuth.getAuthorizationHeader(e, this.oauth1msg.parameters)
    }
    ;
    return a
}
();
var OAuth;
null  == OAuth && (OAuth = {});
function b64_hmac_sha1(a, b, c, e) {
    function d(a, b) {
        var c = (a & 65535) + (b & 65535);
        return (a >> 16) + (b >> 16) + (c >> 16) << 16 | c & 65535
    }
    function g(a, b) {
        a[b >> 5] |= 128 << 24 - b % 32;
        a[(b + 64 >> 9 << 4) + 15] = b;
        for (var c = [80], e = 1732584193, f = -271733879, g = -1732584194, t = 271733878, v = -1009589776, r = 0; r < a.length; r += 16) {
            for (var u = e, w = f, x = g, A = t, y = v, z = 0; 80 > z; z++) {
                if (16 > z)
                    c[z] = a[r + z];
                else {
                    var E = c[z - 3] ^ c[z - 8] ^ c[z - 14] ^ c[z - 16];
                    c[z] = E << 1 | E >>> 31
                }
                var E = e << 5 | e >>> 27, C;
                C = 20 > z ? f & g | ~f & t : 40 > z ? f ^ g ^ t : 60 > z ? f & g | f & t | g & t : f ^ g ^ t;
                E = d(d(E, C), d(d(v, c[z]), 20 > z ? 1518500249 : 
                40 > z ? 1859775393 : 60 > z ? -1894007588 : -899497514));
                v = t;
                t = g;
                g = f << 30 | f >>> 2;
                f = e;
                e = E
            }
            e = d(e, u);
            f = d(f, w);
            g = d(g, x);
            t = d(t, A);
            v = d(v, y)
        }
        return [e, f, g, t, v]
    }
    function f(a) {
        for (var b = [], c = (1 << e) - 1, d = 0; d < a.length * e; d += e)
            b[d >> 5] |= (a.charCodeAt(d / 8) & c) << 32 - e - d % 32;
        return b
    }
    c || (c = "=");
    e || (e = 8);
    return function(a) {
        for (var b = "", d = 0; d < 4 * a.length; d += 3)
            for (var e = (a[d >> 2] >> 8 * (3 - d % 4) & 255) << 16 | (a[d + 1 >> 2] >> 8 * (3 - (d + 1) % 4) & 255) << 8 | a[d + 2 >> 2] >> 8 * (3 - (d + 2) % 4) & 255, f = 0; 4 > f; f++)
                b = 8 * d + 6 * f > 32 * a.length ? b + c : b + "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e >> 
                6 * (3 - f) & 63);
        return b
    }
    (function(a, b) {
        var c = f(a);
        16 < c.length && (c = g(c, a.length * e));
        for (var d = [16], n = [16], p = 0; 16 > p; p++)
            d[p] = c[p] ^ 909522486,
            n[p] = c[p] ^ 1549556828;
        c = g(d.concat(f(b)), 512 + b.length * e);
        return g(n.concat(c), 672)
    }
    (a, b))
}
OAuth.setProperties = function(a, b) {
    if (null  != a && null  != b)
        for (var c in b)
            a[c] = b[c];
    return a
}
;
OAuth.setProperties(OAuth, {
    percentEncode: function percentEncode(b) {
        if (null  == b)
            return "";
        if (b instanceof Array) {
            for (var c = ""; 0 < b.length; ++b)
                "" != c && (c += "&"),
                c += percentEncode(b[0]);
            return c
        }
        b = encodeURIComponent(b);
        b = b.replace(/\!/g, "%21");
        b = b.replace(/\*/g, "%2A");
        b = b.replace(/\'/g, "%27");
        b = b.replace(/\(/g, "%28");
        return b = b.replace(/\)/g, "%29")
    },
    decodePercent: function(a) {
        null  != a && (a = a.replace(/\+/g, " "));
        return decodeURIComponent(a)
    },
    getParameterList: function(a) {
        if (null  == a)
            return [];
        if ("object" != typeof a)
            return decodeForm(a + 
            "");
        if (a instanceof Array)
            return a;
        var b = [], c;
        for (c in a)
            b.push([c, a[c]]);
        return b
    },
    getParameterMap: function getParameterMap(b) {
        if (null  == b)
            return {};
        if ("object" != typeof b)
            return getParameterMap(decodeForm(b + ""));
        if (b instanceof Array) {
            for (var c = {}, e = 0; e < b.length; ++e) {
                var d = b[e][0];
                void 0 === c[d] && (c[d] = b[e][1])
            }
            return c
        }
        return b
    },
    getParameter: function(a, b) {
        if (a instanceof Array)
            for (var c = 0; c < a.length; ++c) {
                if (a[c][0] == b)
                    return a[c][1]
            }
        else
            return OAuth.getParameterMap(a)[b];
        return null 
    },
    formEncode: function(a) {
        var b = 
        "";
        a = OAuth.getParameterList(a);
        for (var c = 0; c < a.length; ++c) {
            var e = a[c][1];
            null  == e && (e = "");
            "" != b && (b += "&");
            b += OAuth.percentEncode(a[c][0]) + "=" + OAuth.percentEncode(e)
        }
        return b
    },
    decodeForm: function(a) {
        var b = [];
        a = a.split("&");
        for (var c = 0; c < a.length; ++c) {
            var e = a[c];
            if ("" != e) {
                var d = e.indexOf("="), g;
                0 > d ? (g = OAuth.decodePercent(e),
                e = null ) : (g = OAuth.decodePercent(e.substring(0, d)),
                e = OAuth.decodePercent(e.substring(d + 1)));
                b.push([g, e])
            }
        }
        return b
    },
    setParameter: function(a, b, c) {
        var e = a.parameters;
        if (e instanceof 
        Array) {
            for (a = 0; a < e.length; ++a)
                e[a][0] == b && (void 0 === c ? e.splice(a, 1) : (e[a][1] = c,
                c = void 0));
            void 0 !== c && e.push([b, c])
        } else
            e = OAuth.getParameterMap(e),
            e[b] = c,
            a.parameters = e
    },
    setParameters: function(a, b) {
        for (var c = OAuth.getParameterList(b), e = 0; e < c.length; ++e)
            OAuth.setParameter(a, c[e][0], c[e][1])
    },
    completeRequest: function(a, b) {
        null  == a.method && (a.method = "GET");
        var c = OAuth.getParameterMap(a.parameters);
        null  == c.oauth_consumer_key && OAuth.setParameter(a, "oauth_consumer_key", b.consumerKey || "");
        null  == c.oauth_token && 
        null  != b.token && OAuth.setParameter(a, "oauth_token", b.token);
        null  == c.oauth_version && OAuth.setParameter(a, "oauth_version", "1.0");
        null  == c.oauth_timestamp && OAuth.setParameter(a, "oauth_timestamp", OAuth.timestamp());
        null  == c.oauth_nonce && OAuth.setParameter(a, "oauth_nonce", OAuth.nonce(6));
        OAuth.SignatureMethod.sign(a, b)
    },
    setTimestampAndNonce: function(a) {
        OAuth.setParameter(a, "oauth_timestamp", OAuth.timestamp());
        OAuth.setParameter(a, "oauth_nonce", OAuth.nonce(6))
    },
    addToURL: function(a, b) {
        newURL = a;
        if (null  != b) {
            var c = 
            OAuth.formEncode(b);
            0 < c.length && (newURL = 0 > a.indexOf("?") ? newURL + "?" : newURL + "&",
            newURL += c)
        }
        return newURL
    },
    getAuthorizationHeader: function(a, b) {
        for (var c = 'OAuth realm="' + OAuth.percentEncode(a) + '"', e = OAuth.getParameterList(b), d = 0; d < e.length; ++d) {
            var g = e[d]
              , f = g[0];
            0 == f.indexOf("oauth_") && (c += "," + OAuth.percentEncode(f) + '="' + OAuth.percentEncode(g[1]) + '"')
        }
        return c
    },
    timestamp: function() {
        return Math.floor((new Date).getTime() / 1E3)
    },
    nonce: function(a) {
        for (var b = OAuth.nonce.CHARS, c = "", e = 0; e < a; ++e)
            var d = Math.floor(Math.random() * 
            b.length)
              , c = c + b.substring(d, d + 1);
        return c
    }
});
OAuth.nonce.CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
OAuth.declareClass = function(a, b, c) {
    var e = a[b];
    a[b] = c;
    if (null  != c && null  != e)
        for (var d in e)
            "prototype" != d && (c[d] = e[d]);
    return c
}
;
OAuth.declareClass(OAuth, "SignatureMethod", function() {}
);
OAuth.setProperties(OAuth.SignatureMethod.prototype, {
    sign: function(a) {
        var b = OAuth.SignatureMethod.getBaseString(a)
          , b = this.getSignature(b);
        OAuth.setParameter(a, "oauth_signature", b);
        return b
    },
    initialize: function(a, b) {
        var c;
        c = null  != b.accessorSecret && 9 < a.length && "-Accessor" == a.substring(a.length - 9) ? b.accessorSecret : b.consumerSecret;
        this.key = OAuth.percentEncode(c) + "&" + OAuth.percentEncode(b.tokenSecret)
    }
});
OAuth.setProperties(OAuth.SignatureMethod, {
    sign: function(a, b) {
        var c = OAuth.getParameterMap(a.parameters).oauth_signature_method;
        if (null  == c || "" == c)
            c = "HMAC-SHA1",
            OAuth.setParameter(a, "oauth_signature_method", c);
        OAuth.SignatureMethod.newMethod(c, b).sign(a)
    },
    newMethod: function(a, b) {
        var c = OAuth.SignatureMethod.REGISTERED[a];
        if (null  != c) {
            var e = new c;
            e.initialize(a, b);
            return e
        }
        var c = Error("signature_method_rejected")
          , d = "";
        for (e in OAuth.SignatureMethod.REGISTERED)
            "" != d && (d += "&"),
            d += OAuth.percentEncode(e);
        c.oauth_acceptable_signature_methods = d;
        throw c;
    },
    REGISTERED: {},
    registerMethodClass: function(a, b) {
        for (var c = 0; c < a.length; ++c)
            OAuth.SignatureMethod.REGISTERED[a[c]] = b
    },
    makeSubclass: function(a) {
        var b = OAuth.SignatureMethod
          , c = function() {
            b.call(this)
        }
        ;
        c.prototype = new b;
        c.prototype.getSignature = a;
        return c.prototype.constructor = c
    },
    getBaseString: function(a) {
        var b = a.action
          , c = b.indexOf("?");
        if (0 > c)
            c = a.parameters;
        else
            for (var c = OAuth.decodeForm(b.substring(c + 1)), e = OAuth.getParameterList(a.parameters), d = 0; d < e.length; ++d)
                c.push(e[d]);
        return OAuth.percentEncode(a.method.toUpperCase()) + "&" + OAuth.percentEncode(OAuth.SignatureMethod.normalizeUrl(b)) + "&" + OAuth.percentEncode(OAuth.SignatureMethod.normalizeParameters(c))
    },
    normalizeUrl: function(a) {
        var b = OAuth.SignatureMethod.parseUri(a);
        a = b.protocol.toLowerCase();
        var c = b.authority.toLowerCase();
        if ("http" == a && 80 == b.port || "https" == a && 443 == b.port) {
            var e = c.lastIndexOf(":");
            0 <= e && (c = c.substring(0, e))
        }
        (b = b.path) || (b = "/");
        return a + "://" + c + b
    },
    parseUri: function(a) {
        var b = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");
        a = /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*):?([^:@]*))?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(a);
        for (var c = {}, e = 14; e--; )
            c[b[e]] = a[e] || "";
        return c
    },
    normalizeParameters: function(a) {
        if (null  == a)
            return "";
        var b = OAuth.getParameterList(a);
        a = [];
        for (var c = 0; c < b.length; ++c) {
            var e = b[c];
            "oauth_signature" != e[0] && a.push([OAuth.percentEncode(e[0]) + " " + OAuth.percentEncode(e[1]), e])
        }
        a.sort(function(a, b) {
            return a[0] < b[0] ? -1 : a[0] > b[0] ? 1 : 0
        }
        );
        b = [];
        for (c = 0; c < a.length; ++c)
            b.push(a[c][1]);
        return OAuth.formEncode(b)
    }
});
OAuth.SignatureMethod.registerMethodClass(["PLAINTEXT", "PLAINTEXT-Accessor"], OAuth.SignatureMethod.makeSubclass(function(a) {
    return this.key
}
));
OAuth.SignatureMethod.registerMethodClass(["HMAC-SHA1", "HMAC-SHA1-Accessor"], OAuth.SignatureMethod.makeSubclass(function(a) {
    b64pad = "=";
    return b64_hmac_sha1(this.key, a, null , null )
}
));
function Viewer2DImpl(a) {
    this.eventCB = (this.config = a) ? a.eventCB : null ;
    this.parent = document.getElementById(a.domElement);
    this.baseURL = a && a.baseURL ? a.baseURL : VIEWING_URL + "/items/"
}
Viewer2DImpl.prototype.initialize = function() {
    var a = document.createElement("canvas");
    a.width = 1;
    a.height = 1;
    this.selCtx = a.getContext("2d");
    this.selCtx.globalCompositeOperation = "copy";
    this.selCtx.imageSmoothingEnabled = !1;
    this.container = document.createElement("div");
    this.container.style.width = "100%";
    this.container.style.height = "100%";
    this.parent.appendChild(this.container);
    return !0
}
;
Viewer2DImpl.prototype.load = function(a) {
    var b = !1
      , c = [-1, -1, -1, -1]
      , e = -1;
    this.whichSheet = a;
    var d = this.config.tileSize ? this.config.tileSize : 1024
      , g = this.config.maxZoom ? this.config.maxZoom : 6
      , f = [this.whichSheet]
      , k = [];
    for (a = 0; a < f.length; a++) {
        var h = L.tileLayer(this.baseURL + f[a] + "/{z}/{x}/c{y}.png", {
            maxZoom: g,
            noWrap: !0,
            continuousWorld: !1,
            detectRetina: !0,
            tileSize: d
        });
        k.push(h);
        var l = L.tileLayer(this.baseURL + f[a] + "/{z}/{x}/i{y}.png", {
            maxZoom: g,
            noWrap: !0,
            continuousWorld: !1,
            detectRetina: !0,
            tileSize: d
        });
        k.push(l);
        var m = L.tileLayer.canvas({
            maxZoom: g,
            noWrap: !0,
            continuousWorld: !1,
            tileSize: d,
            zIndex: 2 * f.length + a
        });
        m.idTileLayer = l;
        l.canvasLayer = m;
        h.canvasLayer = m;
        h.idTileLayer = l;
        m.drawTile = function(a, b, f) {
            var g = null 
              , k = this.idTileLayer.getContainer();
            if (k)
                for (k = k.children[1].getElementsByTagName("img"),
                b = f + "/" + b.x + "/i" + b.y,
                f = 0; f < k.length; f++)
                    if (-1 != k[f].src.indexOf(b)) {
                        g = k[f];
                        break
                    }
            k = parseInt(a.style.left);
            b = parseInt(a.style.top);
            void 0 !== n && (f = n.containerPointToLayerPoint([k, b]),
            k -= f.x - k,
            b -= f.y - b);
            f = a.width;
            var h = 
            a.height;
            if (!(k >= document.body.offsetWidth || 0 > k + f || b >= document.body.offsetHeight || 0 > b + h))
                if (k = a.getContext("2d"),
                !g || -1 == e)
                    k.fillStyle = "rgba(0, 0, 0, 0.0)",
                    k.fillRect(0, 0, d, d),
                    a.currentPixelSrc = null ;
                else if (a.currentPixelSrc != g.src) {
                    k.globalCompositeOperation = "copy";
                    k.drawImage(g, 0, 0, d, d);
                    b = k.getImageData(0, 0, d, d);
                    f = b.data;
                    for (var h = 0, l = f.length; h < l; h += 4)
                        f[h] == c[0] && f[h + 1] == c[1] && f[h + 2] == c[2] && f[h + 3] == c[3] ? (f[h] = 255,
                        f[h + 1] = 255,
                        f[h + 2] = 0,
                        f[h + 3] = 127) : (f[h] = 0,
                        f[h + 1] = 0,
                        f[h + 2] = 0,
                        f[h + 3] = 0);
                    k.putImageData(b, 
                    0, 0);
                    a.currentPixelSrc = g.src
                }
        }
        ;
        k.push(m)
    }
    var n = this.map = L.map(this.container, {
        center: new L.LatLng(0,0),
        zoom: 0,
        zoomControl: !1,
        attributionControl: !1,
        layers: [k[0], k[1], k[2]]
    });
    n.options.crs.scale = function(a) {
        return d * Math.pow(2, a)
    }
    ;
    g = {};
    for (a = 0; a < f.length; a++)
        g[f[a]] = k[3 * a];
    L.control.layers(g, void 0).addTo(n);
    f = document.getElementsByClassName("leaflet-control-layers");
    for (a = 0; a < f.length; a++)
        f[a].style.visibility = "hidden";
    n.on("baselayerchange", function(a) {
        console.log(a);
        var b = [], c;
        for (c in n._layers) {
            var d = 
            n._layers[c];
            d != a.layer && b.push(d)
        }
        for (c = 0; c < b.length; c++)
            n.removeLayer(b[c]);
        a.layer.idTileLayer && (n.addLayer(a.layer.idTileLayer),
        n.addLayer(a.layer.canvasLayer))
    }
    );
    n.on("mousedown", function(a) {
        b = !0
    }
    );
    n.on("mouseup", function(a) {
        b = !1
    }
    );
    var p = this;
    n.on("mousemove", function(a) {
        if (!b) {
            var d, f;
            for (f in n._layers) {
                var g = n._layers[f];
                if (g.idTileLayer && g.canvasLayer) {
                    d = g;
                    break
                }
            }
            if (d) {
                f = d.idTileLayer.getContainer().children[1].getElementsByTagName("img");
                g = n.containerPointToLayerPoint(a.containerPoint);
                a = g.x;
                for (var g = g.y, k = 0; k < f.length; k++) {
                    var h = f[k]
                      , l = parseInt(h.style.left)
                      , m = parseInt(h.style.top)
                      , z = parseInt(h.style.width)
                      , E = parseInt(h.style.height);
                    a < l || a >= l + z || g < m || g >= m + E || (p.selCtx.drawImage(h, l - a, m - g),
                    h = p.selCtx.getImageData(0, 0, 1, 1).data,
                    l = h[3] << 24 | h[0] << 16 | h[1] << 8 | h[2],
                    l != e && (e = l,
                    c[0] = h[0],
                    c[1] = h[1],
                    c[2] = h[2],
                    c[3] = h[3],
                    d.canvasLayer.redraw()))
                }
            }
        }
    }
    );
    n.fitWorld();
    return !0
}
;
Viewer2DImpl.prototype.uninitialize = function() {
    this.map.remove()
}
;
var Xhr = function() {
    var a = function(a, c, e) {
        this.xhr = new XMLHttpRequest;
        this.errorHandler = a;
        this.success = !1;
        this.viewing_url = e;
        void 0 != c && (this.auth = new Auth,
        c.oauth0 ? this.auth.configureOAuthZero(c.access_token) : c.oauth1 ? this.auth.configureOAuthOne(c.oauth1msg.parameters.oauth_consumer_key, c.oauth1accessor.consumerSecret, c.oauth1msg.parameters.oauth_token, c.oauth1accessor.tokenSecret) : c.oauth2 ? this.auth.configureOAuthTwo() : c.oauthNone && this.auth.configureOAuthNone())
    }
    ;
    a.prototype.get = function(a, c, e, 
    d) {
        function g() {
            4 === f.xhr.readyState && f.xhr.status && 200 != f.xhr.status ? f.errorHandler && f.errorHandler.unsuccessfulResponse(a, f.xhr.status, f.xhr.statusText) : f.success = !0
        }
        0 == a.indexOf("urn:") && (a = this.viewing_url + "/items/" + a,
        this.auth.oauth0 ? a = a + "?oauth_token=" + encodeURIComponent(this.auth.access_token) : 1 != this.auth.oauthNone ? c.Authorization = this.auth.getAuthHeader("GET", a) : this.auth.oauthNone && (c["Access-Control-Allow-Credentials"] = !0),
        c["Access-Control-Allow-Origin"] = "*");
        var f = this;
        try {
            this.xhr.open("GET", 
            a, !!d);
            this.xhr.responseType = e;
            this.success = !1;
            this.auth && this.auth.oauthNone && (this.xhr.withCredentials = !0);
            d && (this.xhr.onload = d);
            this.xhr.onerror = g;
            for (var k in c)
                this.xhr.setRequestHeader(k, c[k]);
            this.xhr.send()
        } catch (h) {
            return this.errorHandler && this.errorHandler.networkFailure(a, h),
            null 
        }
        g();
        return this.xhr.response
    }
    ;
    a.prototype.post = function(a, c, e, d) {
        try {
            this.xhr.open("POST", a, !1);
            this.xhr.responseType = d;
            this.success = !1;
            this.auth && this.auth.oauthNone && (this.xhr.withCredentials = !0);
            for (var g in c)
                this.xhr.setRequestHeader(g, 
                c[g]);
            this.xhr.send(e)
        } catch (f) {
            return this.errorHandler && this.errorHandler.networkFailure(a, f),
            null 
        }
        4 === this.xhr.readyState && this.xhr.status && 200 != this.xhr.status ? this.errorHandler && this.errorHandler.unsuccessfulResponse(a, this.xhr.status, this.xhr.statusText) : this.success = !0;
        return this.xhr.response
    }
    ;
    return a
}
()
  , XhrErrorHandler = function() {
    var a = function(a) {
        this.host = a;
        this.ignoreFileNotFound = !1
    }
    ;
    a.prototype.networkFailure = function(a, c) {
        this.host.raiseError(METADATA.BaseViewer3D.ErrorCodes.NETWORK_FAILURE, 
        "Network failure", {
            url: a,
            exception: c.toString(),
            stack: c.stack
        })
    }
    ;
    a.prototype.unsuccessfulResponse = function(a, c, e) {
        403 == c ? this.host.raiseError(METADATA.BaseViewer3D.ErrorCodes.NETWORK_ACCESS_DENIED, "Access denied to remote resource", {
            url: a,
            httpStatus: c,
            httpStatusText: e
        }) : 404 == c ? this.ignoreFileNotFound || this.host.raiseError(METADATA.BaseViewer3D.ErrorCodes.NETWORK_FILE_NOT_FOUND, "Remote resource not found", {
            url: a,
            httpStatus: c,
            httpStatusText: e
        }) : 500 <= c && 600 > c ? this.host.raiseError(METADATA.BaseViewer3D.ErrorCodes.NETWORK_SERVER_ERROR, 
        "Server error when accessing resource", {
            url: a,
            httpStatus: c,
            httpStatusText: e
        }) : this.host.raiseError(METADATA.BaseViewer3D.ErrorCodes.NETWORK_UNHANDLED_RESPONSE_CODE, "Unhandled response code from server", {
            url: a,
            httpStatus: c,
            httpStatusText: e
        })
    }
    ;
    return a
}
();
var propdb = null 
  , propdbFailed = !1;
function loadAsyncResource(a, b, c) {}
function loadPropertyPacks(a, b) {
    if (propdb)
        return !0;
    if (propdbFailed)
        return !1;
    var c = a.url, e = {
        ids: {},
        attrs: {},
        offsets: {},
        values: {},
        avs: {}
    }, d = 0, g, f;
    g = "objects_attrs.json.gz";
    f = requestFile(g, c + g, a);
    e.attrs[g] = f;
    d += !!f;
    g = "objects_vals.json.gz";
    f = requestFile(g, c + g, a);
    e.values[g] = f;
    d += !!f;
    g = "objects_avs.json.gz";
    f = requestFile(g, c + g, a);
    e.avs[g] = f;
    d += !!f;
    g = "objects_offs.json.gz";
    f = requestFile(g, c + g, a);
    e.offsets[g] = f;
    if (4 == d + !!f)
        return propdb = new PropertyDatabase(e),
        !0;
    propdbFailed = !0;
    return !1
}
function doPropertyGet(a, b) {
    var c = b.dbId
      , e = null ;
    loadPropertyPacks(b, c) && (e = propdb.getObjectProperties(c));
    a.postMessage(e)
}
function computeTreeBBoxes(a, b, c) {
    var e = 6 * a.dbId;
    b[e] = b[e + 1] = b[e + 2] = Infinity;
    b[e + 3] = b[e + 4] = b[e + 5] = -Infinity;
    var d = a.children;
    if (d)
        for (var g = 0, f = d.length; g < f; g++) {
            computeTreeBBoxes(d[g], b, c);
            for (var k = 6 * (d[g].dbId | 0), h = 0; 3 > h; h++)
                b[e + h] > b[k + h] && (b[e + h] = b[k + h]),
                b[e + h + 3] < b[k + h + 3] && (b[e + h + 3] = b[k + h + 3])
        }
    if (void 0 !== a.fragIds)
        if (!Array.isArray(a.fragIds))
            for (d = 6 * (a.fragIds | 0),
            h = 0; 3 > h; h++)
                b[e + h] > c[d + h] && (b[e + h] = c[d + h]),
                b[e + h + 3] < c[d + h + 3] && (b[e + h + 3] = c[d + h + 3]);
        else if (a.fragIds.length)
            for (g = 0; g < a.fragIds.length; g++)
                for (d = 
                6 * (a.fragIds[g] | 0),
                h = 0; 3 > h; h++)
                    b[e + h] > c[d + h] && (b[e + h] = c[d + h]),
                    b[e + h + 3] < c[d + h + 3] && (b[e + h + 3] = c[d + h + 3])
}
function buildDbIdToFragMap(a) {
    for (var b = {}, c = 0, e = a.length; c < e; c++) {
        var d = a[c]
          , g = b[d];
        void 0 === g ? b[d] = c : Array.isArray(g) ? g.push(c) : b[d] = [g, c]
    }
    return b
}
function doObjectTreeParse(a, b) {
    if (loadPropertyPacks(b, null )) {
        var c = buildDbIdToFragMap(b.fragToDbId), e = propdb.findRootNodes(), d, g = [0];
        if (1 == e.length)
            d = {
                dbId: e[0]
            },
            propdb.buildObjectTree(d, c, 0, g);
        else {
            d = {
                dbId: 0,
                children: []
            };
            for (var f = 0; f < e.length; f++) {
                var k = {
                    dbId: e[f]
                };
                d.children.push(k);
                propdb.buildObjectTree(k, c, 0, g)
            }
        }
        a.postMessage({
            instanceTree: d,
            maxTreeDepth: g[0]
        });
        b.fragBoxes && (c = new Float32Array(6 * propdb.getObjectCount()),
        computeTreeBBoxes(d, c, b.fragBoxes),
        a.postMessage({
            instanceBoxes: c
        }))
    }
}
function doPropertySearch(a, b) {
    var c = [];
    loadPropertyPacks(b, null ) && (c = propdb.bruteForceSearch(b.searchText));
    a.postMessage(c)
}
;function doGeomLoad(a, b) {
    var c = new Xhr(b.errorHandler,b.auth,b.viewing_url)
      , e = c.get(b.url, b.headers, "arraybuffer");
    if (c.success) {
        a.postMessage({
            url: b.url,
            workerId: b.workerId,
            progress: .5
        });
        try {
            var d = new PackFileReader(new Uint8Array(e))
        } catch (g) {
            a.raiseError(METADATA.BaseViewer3D.ErrorCodes.BAD_DATA, "Unhandled exception while reading pack file", {
                url: b.url,
                exception: g.toString(),
                stack: g.stack
            });
            a.postMessage(null );
            return
        }
        for (var e = c = !1, f = 0, k = d.getEntryCounts(); f < k; f++) {
            try {
                var h = readGeometry(d, f, null )
            } catch (g) {
                e || 
                (a.raiseError(METADATA.BaseViewer3D.ErrorCodes.BAD_DATA, "Unhandled exception while reading geometry", {
                    url: b.url,
                    exception: g.toString(),
                    stack: g.stack
                }),
                c = e = !0),
                h = null 
            }
            var l = {
                packId: b.packId,
                meshIndex: f,
                mesh: h,
                workerId: b.workerId,
                progress: .5 + (f + 1) / k * .5
            };
            h || c || (a.raiseError(METADATA.BaseViewer3D.ErrorCodes.BAD_DATA, "Unable to load geometry", {
                url: b.url
            }),
            c = !0);
            a.postMessage(l)
        }
    } else
        a.postMessage(null )
}
;function doLoadSvf(a, b) {
    b.basePath = "";
    var c = b.url.lastIndexOf("/");
    -1 != c && (b.basePath = b.url.substr(0, c + 1));
    var c = new Xhr(b.errorHandler,b.auth,b.viewing_url)
      , e = c.get(b.url, b.headers, "arraybuffer");
    if (c.success) {
        a.postMessage({
            progress: .5
        });
        var d = new Package;
        b.loadDoneCB = function(c) {
            c ? a.postMessage({
                svf: d
            }) : (a.raiseError(METADATA.BaseViewer3D.ErrorCodes.BAD_DATA, "Failure while loading SVF", {
                url: b.url
            }),
            a.postMessage(null ))
        }
        ;
        try {
            d.load(b, new Uint8Array(e))
        } catch (g) {
            a.raiseError(METADATA.BaseViewer3D.ErrorCodes.BAD_DATA, 
            "Unhandled exception while loading SVF", {
                url: b.url,
                exception: g.toString(),
                stack: g.stack
            }),
            a.postMessage(null )
        }
    } else
        a.postMessage(null )
}
;var elementId2DbId = null 
  , SKIP_OAUTH = !1;
function buildElementId2DbIdMapping(a) {
    if (elementId2DbId)
        return elementId2DbId;
    a = requestFile("objects_ids.json.gz", a + "objects_ids.json.gz", {});
    elementId2DbId = {};
    if (a)
        for (var b = 1; b < a.length; ++b)
            elementId2DbId[a[b]] = b;
    return elementId2DbId
}
function query(a, b) {
    var c = {
        query: {
            match: {
                type: "bool",
                query: "keyword",
                searchFields: [{
                    fieldName: "content.name",
                    searchFlags: ["generic", "simple", "startsWith"]
                }]
            }
        },
        options: {
            paging: {
                first: 0,
                count: 10
            },
            restrictions: {
                sourceIds: [{
                    sourceSystem: "",
                    type: "file",
                    id: "",
                    version: ""
                }],
                tipVersionOnly: !0,
                childObjects: {
                    childSearchType: "parentsAndChildren"
                },
                accessEntities: [{
                    id: "",
                    type: "user",
                    accessProvider: "",
                    idProvider: ""
                }]
            }
        }
    };
    c.query.match.query = a;
    b && 
    (c.options.restrictions.sourceIds[0] = {
        sourceSystem: b.sourceSystem,
        type: b.type,
        id: b.id,
        version: b.version
    });
    debug("keyword: " + a);
    var c = JSON.stringify(c)
      , e = new Xhr(new XhrErrorHandler(self),auth);
    SKIP_OAUTH ? c = e.post("", {
        "Content-Type": "application/json"
    }, c, "text") : (c = e.post("", {}, c, "text"),
    debug("search worker debug response : " + c));
    return c
}
function debug(a) {
    self.postMessage(JSON.stringify({
        type: "debug",
        debug: a
    }))
}
function doSearch(a, b) {
    try {
        for (var c = buildElementId2DbIdMapping(b.url), e = JSON.parse(query(b.keyword, b.id)).results, d = [], g = 0; g < e.length; ++g) {
            var f = e[g].elementId;
            debug("id : " + f);
            d.push(c[f])
        }
        debug(d);
        a.postMessage(JSON.stringify({
            type: "response",
            response: d
        }))
    } catch (k) {
        c = k.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@").split("\n"),
        debug(k + "\n" + c),
        a.raiseError(METADATA.BaseViewer3D.ErrorCodes.UNKNOWN_FAILURE, "Unhandled exception while performing search query", 
        {
            exception: k.toString(),
            stack: k.stack
        })
    }
}
;var ENABLE_OCTM_MG2 = !1
  , IS_WORKER = "undefined" !== typeof self && "undefined" === typeof window;
if (IS_WORKER) {
    var requestFile = function(a, b, c) {
        c.errorHandler.ignoreFileNotFound = !0;
        var e = new Xhr(c.errorHandler,c.auth,c.viewing_url);
        if (-1 !== a.indexOf(".gz", a.length - 3))
            if (a = e.get(b, c.headers, "arraybuffer"),
            e.success)
                try {
                    var d = new Uint8Array(a);
                    31 == d[0] && 139 == d[1] && (d = (new Zlib.Gunzip(d)).decompress());
                    return d
                } catch (g) {
                    return self.raiseError(METADATA.BaseViewer3D.ErrorCodes.BAD_DATA, "Malformed data received when requesting file", {
                        url: b,
                        exception: g.toString(),
                        stack: g.stack
                    }),
                    null 
                }
            else
                return null ;
        else
            return b = e.get(b, c.headers, "json"),
            e.success ? b : null 
    }
    ;
    IS_CONCAT_BUILD || (importScripts("../compatibility.js"),
    importScripts("../render/md_three.js"),
    importScripts("../zlib/gunzip.min.js"),
    importScripts("../zlib/unzip.min.js"),
    ENABLE_OCTM_MG2 && (importScripts("../zlib/inflate.min.js"),
    importScripts("../lmvtk/octm_mg2.js")),
    importScripts("../lmvtk/packreader.js"),
    importScripts("../lmvtk/geoms.js"),
    importScripts("../lmvtk/materials.js"),
    importScripts("../lmvtk/lights.js"),
    importScripts("../lmvtk/cameras.js"),
    importScripts("../lmvtk/fragments.js"),
    importScripts("../lmvtk/instances.js"),
    importScripts("../lmvtk/package.js"),
    importScripts("../lmvtk/packreader.js"),
    importScripts("../lmvtk/propdb.js"),
    importScripts("../net/xhr.js"),
    importScripts("../auth/auth.js"),
    importScripts("../auth/oauth1.js"),
    importScripts("geomworker.js"),
    importScripts("svfworker.js"),
    importScripts("propworker.js"),
    importScripts("searchworker.js"),
    importScripts("../../api/Viewer.js"),
    importScripts("../../api/BaseViewer3D.js"));
    self.addEventListener("message", 
    function(a) {
        var b = a.data;
        b.errorHandler = new XhrErrorHandler(self);
        a = a.data.operation;
        "LOAD_GEOMETRY" == a ? doGeomLoad(self, b) : "LOAD_SVF" == a ? doLoadSvf(self, b) : "GET_PROPERTIES" == a ? doPropertyGet(self, b) : "SEARCH_PROPERTIES" == a ? doPropertySearch(self, b) : "GET_OBJECT_TREE" == a ? doObjectTreeParse(self, b) : "SEARCH" == a && doSearch(self, b)
    }
    , !1);
    self.raiseError = function(a, b, c) {
        self.postMessage({
            error: {
                code: a,
                msg: b,
                args: c
            }
        })
    }
}
;function ViewController(a) {
    function b(a) {
        0 >= a && (a = 1E-4);
        a = 2 * Math.atan(12 / a);
        return THREE.Math.radToDeg(a)
    }
    function c(a) {
        l != a && (m.api.fireEvent({
            type: NAVIGATION_MODE_CHANGED_EVENT,
            value: a
        }),
        l = a)
    }
    function e(a, b, c) {
        b = 2 * b - 1;
        c = 2 * (1 - c) - 1;
        return (new CameraRaycaster(m,a)).castRayViewport(b, c, !1).intersectPoint
    }
    function d() {
        return 1 === w && !u.CONTROL && !u.SHIFT || 0 === w && (u.F2 || u.SPACE || u.LOCK_PAN) || 2 === w && !u.ALT && !u.LOCK_PAN
    }
    var g = .5 * Math.PI
      , f = 2 * Math.PI;
    this.NAVIGATION_MODE = {
        ORBIT: 0,
        PAN: 1,
        DOLLY: 2,
        ROLL: 3,
        FOV: 4,
        OTHER: 5
    };
    this.setClickBehavior = function(a) {
        this.clickConfig = a
    }
    ;
    var k = function() {
        var a = new THREE.Matrix4
          , b = new THREE.Vector3
          , c = new THREE.Vector3
          , d = new THREE.Vector3;
        return function(e, f, g, k) {
            var h = a.elements;
            d.subVectors(g, f).normalize();
            0 === d.lengthSq() && (d.z = 1);
            b.crossVectors(k, d).normalize();
            0 === b.lengthSq() && (k.z > k.y ? d.y -= 1E-4 : d.z += 1E-4,
            b.crossVectors(k, d).normalize());
            c.crossVectors(d, b);
            h[0] = b.x;
            h[4] = c.x;
            h[8] = d.x;
            h[1] = b.y;
            h[5] = c.y;
            h[9] = d.y;
            h[2] = b.z;
            h[6] = c.z;
            h[10] = d.z;
            e.setRotationFromMatrix(a)
        }
    }
    ();
    THREE.EventDispatcher.call(this);
    this.camera = a.camera;
    this.domElement = a.canvas;
    this.viewport = {
        left: 0,
        top: 0,
        width: 1,
        height: 1
    };
    this.downY = this.downX = -1;
    this.isDragging = !1;
    var h = new function(a) {
        var b = 0
          , c = 0
          , d = 0
          , e = 0
          , h = 4
          , l = .025
          , m = !1
          , n = !1
          , p = null 
          , r = {
            left: 0,
            top: 0,
            width: 1,
            height: 1
        }
          , t = new THREE.Vector3(0,0,0)
          , u = a.position.clone()
          , w = new THREE.Vector2(0,0)
          , v = a.up.clone();
        this.saveCOI = function() {
            p = this.getPivotPoint().clone()
        }
        ;
        this.restoreCOI = function() {
            null  !== p && (this.setPivotPoint(p, !0),
            p = null )
        }
        ;
        this.isDirty = 
        function() {
            return m
        }
        ;
        this.setScreenViewport = function(a) {
            r = a
        }
        ;
        this.getPosition = function() {
            return u.clone().add(this.getViewOffset())
        }
        ;
        this.setPosition = function(a) {
            this.setView(a, t)
        }
        ;
        this.getPivotDistance = function() {
            return d
        }
        ;
        this.setPivotPoint = function(a, b) {
            if (b) {
                var c = m
                  , d = this.getPosition()
                  , e = new THREE.Vector3;
                e.subVectors(a, d);
                var f = this.getCameraRightVector()
                  , g = this.getCameraUpVector()
                  , k = f.dot(e)
                  , e = g.dot(e);
                f.multiplyScalar(k);
                g.multiplyScalar(e);
                d.add(f);
                d.add(g);
                this.setView(d, a, -k, -e);
                m = c
            } else
                this.setView(u, 
                a)
        }
        ;
        this.getPivotPoint = function() {
            return t
        }
        ;
        this.getLookAtPoint = function() {
            return this.getEyeVector().add(u).add(this.getViewOffset())
        }
        ;
        this.getForwardLookAtPoint = function(b) {
            var c = this.getEyeVector().normalize()
              , d = this.getPosition();
            b = (b = b(a, .5, .5)) ? b.sub(d).length() : .5 * (a.near + a.far);
            return d.add(c.multiplyScalar(b))
        }
        ;
        this.getCameraUpVector = function() {
            var a = this.getCameraRightVector()
              , b = this.getEyeVector();
            return a.crossVectors(b, a).normalize()
        }
        ;
        this.getCameraRightVector = function() {
            var a = new THREE.Vector3
              , 
            b = this.getWorldUpVector()
              , c = this.getEyeVector();
            c.set(-c.x, -c.y, -c.z);
            a.crossVectors(c, b);
            0 === a.lengthSq() && (b.z > b.y ? c.y -= 1E-4 : c.z += 1E-4,
            a.crossVectors(c, b));
            return a.normalize()
        }
        ;
        this.setWorldUpVector = function(b) {
            v.copy(b);
            v.normalize();
            a.up = v;
            this.setView(u, t, w.x, w.y)
        }
        ;
        this.getWorldUpVector = function() {
            return v.clone()
        }
        ;
        this.getWorldRightVector = function() {
            var a = this.getWorldUpVector();
            Math.abs(a.z) <= Math.abs(a.y) ? a.set(a.y, -a.x, 0) : 0 <= a.z ? a.set(a.z, 0, -a.x) : a.set(-a.z, 0, a.x);
            return a.normalize()
        }
        ;
        this.getEyeVector = function() {
            var a = new THREE.Vector3;
            a.subVectors(t, u);
            n && a.set(-a.x, -a.y, -a.z);
            return a
        }
        ;
        this.setTrackingDistance = function(a) {
            e = a
        }
        ;
        this.getTrackingSpeed = function() {
            var b = r.width / r.height
              , c = 2 * e * Math.tan(THREE.Math.degToRad(.5 * a.fov));
            return new THREE.Vector2(c * b,c)
        }
        ;
        this.trackRelative = function(a, b) {
            var c = this.getTrackingSpeed();
            w.set(w.x + a * c.x, w.y + b * c.y);
            m = !0
        }
        ;
        this.getViewOffset = function() {
            var a = this.getCameraUpVector()
              , b = this.getCameraRightVector().multiplyScalar(w.x)
              , a = a.multiplyScalar(w.y);
            return b.add(a)
        }
        ;
        this.adjustDollyLookSpeed = function(a) {
            0 == a ? (l = .025,
            h = 4) : (l *= 0 < a ? 1.15 : .85,
            h *= 0 < a ? 1.05 : .95,
            1E-6 > l && (l = 1E-6),
            1E-6 > h && (h = 1E-6))
        }
        ;
        this.getDollySpeed = function() {
            var a = d * l;
            return .01 > a ? .01 : a
        }
        ;
        this.coiIsActive = function() {
            return !0
        }
        ;
        this.coiIsVisible = function() {
            if (n)
                return !1;
            var b = Math.abs(w.x)
              , c = Math.abs(w.y)
              , e = d * Math.tan(THREE.Math.degToRad(.5 * a.fov));
            return b < r.width / r.height * e && c < e
        }
        ;
        this.orbitRelative = function(a, e, f, g) {
            1E-6 < Math.abs(f) && this.dollyRelative(f, g);
            (1E-6 < Math.abs(a) || 1E-6 < Math.abs(e)) && 
            this.look(b - a * h, c + e * h, d, !0)
        }
        ;
        this.dollyRelative = function(a, b) {
            var c, d = this.coiIsActive() && this.coiIsVisible();
            d || (this.saveCOI(),
            c = this.getForwardLookAtPoint(b),
            this.setPivotPoint(c, !0));
            a *= this.getDollySpeed();
            c = t.clone().sub(u);
            var e = c.length()
              , f = e + a;
            .01 > f && (f = .01);
            e = f / e;
            1E-6 < Math.abs(e - 1) && (c.multiplyScalar(e),
            c.set(-c.x, -c.y, -c.z),
            c.add(t),
            this.setView(c, t, w.x * e, w.y * e));
            d || this.restoreCOI()
        }
        ;
        this.setView = function(a, b, c, d, e) {
            var f = new THREE.Vector3;
            f.subVectors(a, b);
            var g = 0
              , k = 0
              , h = 10
              , l = f.lengthSq();
            if (0 < l) {
                var k = this.getWorldUpVector()
                  , g = this.getWorldRightVector()
                  , h = g.clone().cross(k).normalize()
                  , k = k.dot(f)
                  , g = g.dot(f)
                  , h = h.dot(f)
                  , p = (new THREE.Vector2(g,h)).length()
                  , k = Math.atan2(k, p)
                  , g = Math.atan2(g, h)
                  , h = Math.sqrt(l);
                n = e ? !1 : 0 < f.dot(this.getEyeVector())
            }
            t.copy(b);
            u.copy(a);
            w.set(c || 0, d || 0);
            m = !0;
            this.look(g, k, h, !1)
        }
        ;
        this.look = function(a, k, h, l) {
            .01 > h && (h = .01);
            a > f ? a -= f : 0 > a && (a += f);
            k > g ? k = g - 1E-6 : k < -g && (k = -g + 1E-6);
            if (1E-6 < Math.abs(b - a) || 1E-6 < Math.abs(c - k) || 1E-6 < Math.abs(d - h))
                m = !0;
            b = a;
            c = k;
            e = d = h;
            l && (a = 
            new THREE.Quaternion,
            k = this.getWorldUpVector(),
            h = this.getWorldRightVector(),
            l = h.clone().cross(k).normalize(),
            a.setFromAxisAngle(h, -c),
            l.applyQuaternion(a),
            a.setFromAxisAngle(k, b),
            l.applyQuaternion(a),
            u.set(t.x, t.y, t.z),
            u.add(l.multiplyScalar(d)),
            m = !0)
        }
        ;
        this.updateCamera = function() {
            a.position = this.getPosition();
            k(a, this.getLookAtPoint(), a.position, a.up);
            m = !1
        }
        ;
        this.oneStepTowards = function(b, c, d, e) {
            if (0 < e) {
                e = 1 / e;
                var f = new THREE.Vector2(-w.x,-w.y);
                b = b.clone().sub(u);
                c = c.clone().sub(t);
                d -= a.fov;
                f.multiplyScalar(e).add(w);
                b.multiplyScalar(e).add(u);
                c.multiplyScalar(e).add(t);
                a.fov += d * e;
                this.setView(b, c, f.x, f.y, !0)
            }
        }
        ;
        this.changeFOV = function(e) {
            6.88 > e ? e = 6.88 : 100 < e && (e = 100);
            if (e !== a.fov) {
                if (this.coiIsVisible()) {
                    var f = THREE.Math.degToRad(a.fov)
                      , g = THREE.Math.degToRad(e)
                      , f = d * Math.tan(.5 * f) / Math.tan(.5 * g);
                    this.look(b, c, f, !0)
                }
                a.fov = e;
                m = !0
            }
        }
    }
    (this.camera), l = -1, m = a, n = new THREE.Vector3, p = new THREE.Vector3, t = new THREE.Vector3, v = [!1, !1, !1, !1, !1, !1], r, u = {
        SHIFT: 0,
        ALT: 0,
        CONTROL: 0,
        SPACE: 0,
        F1: 0,
        F2: 0,
        F3: 0,
        F4: 0,
        LOCK_PAN: 0,
        LOCK_DOLLY: 0
    }, 
    w = 0, x = !1, A = null , y = new function(a) {
        var b = 0
          , c = new THREE.SphereGeometry(1)
          , d = new THREE.MeshPhongMaterial({
            color: 32512,
            ambient: 32512,
            opacity: .6,
            transparent: !0
        })
          , e = new THREE.MeshPhongMaterial({
            color: 32512,
            ambient: 32512,
            opacity: .6,
            transparent: !0
        })
          , f = new THREE.Mesh(c,e);
        a.createOverlayScene("pivot", d, e);
        this.shown = function() {
            return f.visible
        }
        ;
        this.show = function(c, g, k) {
            f.scale.x = g;
            f.scale.y = g;
            f.scale.z = g;
            f.position.set(c.x, c.y, c.z);
            e.opacity = .6;
            d.opacity = .6;
            f.visible = !0;
            a.addOverlay("pivot", f);
            b = k ? (new Date).getTime() + 
            750 : 0
        }
        ;
        this.hide = function() {
            f.visible && (f.visible = !1,
            a.removeOverlay("pivot", f),
            b = 0)
        }
        ;
        this.fade = function() {
            if (0 < b) {
                var a = b - (new Date).getTime();
                if (0 >= a)
                    return this.hide(),
                    !0;
                a = a / 750 * .6;
                d.opacity = a;
                e.opacity = a;
                return !0
            }
            return !1
        }
        ;
        this.fading = function() {
            return 0 < b
        }
    }
    (a), z = new function(a, b) {
        function c(a, b, d, e) {
            a = new THREE.Vector3(a,b,d);
            b = e.dot(a);
            e = t.copy(e);
            e.multiplyScalar(b);
            return a.sub(e)
        }
        function d(a, b) {
            var c = Math.abs(a - b);
            return c > f ? c : Math.min(f - c, c)
        }
        function e(a) {
            return a > f ? a : 0 >= a ? a + Math.PI : a - 
            Math.PI
        }
        function g(a, b, f, h) {
            if (!E) {
                E = new THREE.Object3D;
                var l = new THREE.RingGeometry(.49,.5,60);
                x = l = new THREE.Mesh(l,n);
                var m = new THREE.BoxGeometry(.93,.007,.007)
                  , p = new THREE.BoxGeometry(.007,.93,.007)
                  , r = new THREE.BoxGeometry(.007,.007,.93);
                z = new THREE.Mesh(m,n);
                A = new THREE.Mesh(p,n);
                y = new THREE.Mesh(r,n);
                E.add(z);
                E.add(A);
                E.add(y);
                C = new THREE.Mesh(new THREE.CircleGeometry(.005),n);
                E.add(C);
                B = Array(6);
                K = Array(6);
                for (m = 0; 6 > m; ++m)
                    B[m] = new THREE.Mesh(new THREE.CircleGeometry(.005,16),n),
                    K[m] = new THREE.Mesh(new THREE.CircleGeometry(.0025,
                    16),n),
                    K[m].visible = !1,
                    B[m].add(K[m]),
                    l.add(B[m]);
                E.add(l)
            }
            a *= 2 * f.length() * Math.tan(THREE.Math.degToRad(.5 * w.fov));
            k(x, b, w.position, h);
            l = f.clone().normalize();
            m = Array(3);
            f = Array(6);
            m[0] = c(1, 0, 0, l);
            m[1] = c(0, 1, 0, l);
            m[2] = c(0, 0, 1, l);
            p = h.clone().cross(l).normalize();
            for (l = 0; 3 > l; ++l)
                r = m[l],
                f[l] = r.length(),
                .1 > f[l] ? F[l] = 1E3 : (r.multiplyScalar(1 / f[l]),
                F[l] = Math.atan2(p.dot(r), h.dot(r)));
            F[3] = e(F[0]);
            F[4] = e(F[1]);
            F[5] = e(F[2]);
            f[3] = f[0];
            f[4] = f[1];
            f[5] = f[2];
            h = O + Q + 2 * Math.PI / 180;
            for (l = 0; 6 > l; ++l)
                if (1E3 != F[l])
                    for (m = 
                    l + 1; 6 > m; ++m)
                        if (1E3 != F[m] && d(F[l], F[m]) < h)
                            if (f[l] < f[m]) {
                                F[l] = 1E3;
                                break
                            } else
                                F[m] = 1E3;
            for (l = 0; 6 > l; ++l)
                1E3 != F[l] ? (h = t.set(0, 0, 1),
                u.setFromAxisAngle(h, F[l]),
                h = t.set(0, .54, 0),
                h.applyQuaternion(u),
                B[l].position.copy(h),
                B[l].visible = !0) : B[l].visible = !1;
            E.scale.x = a;
            E.scale.y = a;
            E.scale.z = a;
            E.position.copy(b);
            return E
        }
        function h(a, b) {
            for (var c = d(F[0], a), e = 0, f = 1; 6 > f; ++f) {
                var g = d(F[f], a);
                g < c && (c = g,
                e = f)
            }
            return c < b ? e : -1
        }
        function l(a, b, c) {
            if (0 != a) {
                var d = 30 * Math.PI / 180;
                b = t.copy(w.position).sub(b).normalize();
                u.setFromAxisAngle(b, 
                a);
                a = r.copy(w.up);
                b = Math.abs(b.angleTo(a));
                (b < d || Math.PI - b < d) && a.copy(c.getCameraUp());
                a.applyQuaternion(u);
                c.setWorldUp(a)
            }
        }
        function m(a, b) {
            k(C, b, w.position, w.up);
            C.position.copy(a.multiplyScalar(.495));
            z.visible = H;
            A.visible = H;
            for (var c = (y.visible = H) ? Q : O, e = 0; 6 > e; ++e) {
                var f = d(F[e], G)
                  , g = f < c
                  , f = g ? 4 : 3 * (1 - 3 * f / Math.PI);
                1 > f && (f = 1);
                f *= v;
                K[e].visible = g;
                g = B[e];
                g.scale.x = f;
                g.scale.y = f;
                g.scale.z = f
            }
        }
        var n = new THREE.MeshLambertMaterial({
            color: 12303291,
            opacity: .5,
            transparent: !0
        })
          , p = new THREE.MeshLambertMaterial({
            color: 12303291,
            opacity: .5,
            transparent: !0
        })
          , r = new THREE.Vector3
          , t = new THREE.Vector3
          , u = new THREE.Quaternion
          , w = b
          , v = 1
          , x = null 
          , z = null 
          , A = null 
          , y = null 
          , E = null 
          , C = null 
          , B = null 
          , K = null 
          , F = Array(6)
          , G = 0
          , H = !0
          , M = 0
          , O = 6 * Math.PI / 180
          , Q = 8 * Math.PI / 180;
        a.createOverlayScene("roll", n, p);
        this.isSnapped = function() {
            return H
        }
        ;
        this.start = function(b, c) {
            v = .85 / .7;
            var d = r.copy(b).sub(w.position);
            a.addOverlay("roll", g(.7, b, d, c));
            M = G = 0;
            m(c, b)
        }
        ;
        this.handleRoll = function(a, b, c, d, e) {
            if (0 != a || 0 != b) {
                a = c.x - a - .5;
                b = c.y - b - .5;
                c = Math.atan2(c.y - .5, c.x - .5) - Math.atan2(b, 
                a);
                G += c;
                G > Math.PI ? G -= f : G <= -Math.PI && (G = f + G);
                a: {
                    if (!H && (b = h(G, O),
                    0 <= b)) {
                        H = !0;
                        G = F[b];
                        r.set(0, 0, 0);
                        0 <= b && (a = 3 <= b ? -1 : 1,
                        b %= 3,
                        0 == b && (r.x = a),
                        1 == b && (r.y = a),
                        2 == b && (r.z = a));
                        b = r;
                        break a
                    }
                    b = !1
                }
                b ? (M = G,
                e.setWorldUp(b)) : (H && 0 > h(G, Q) ? (H = !1,
                b = !0) : b = !1,
                b ? (l(G - M, d, e),
                M = 0) : H || l(c, d, e));
                d = e.getLookAtPoint();
                m(e.getCameraUp(), d);
                E.position.copy(d)
            }
        }
        ;
        this.end = function() {
            a.removeOverlay("roll", E)
        }
    }
    (a,this.camera), E = !1, C = !1, B = !1, K = !1, F = !1, O = !1, M = 0, G = null , Q = 0, R = null , S = null , U = null , H = this;
    this.homePosition = new THREE.Vector3(0,
    0,1);
    this.homeTarget = new THREE.Vector3(0,0,0);
    this.homeUp = new THREE.Vector3(0,1,0);
    this.homeFov = this.camera.fov;
    this.setViewpoint = function(a, b) {
        h.setView(a, b, 0, 0, !0)
    }
    ;
    this.setCOI = function(a, b) {
        h.setPivotPoint(a, b);
        y.shown() && this.activatePivot()
    }
    ;
    this.setSelector = function(a) {
        A = a
    }
    ;
    this.getNavigationMode = function() {
        return u.LOCK_DOLLY ? this.NAVIGATION_MODE.DOLLY : u.LOCK_PAN ? this.NAVIGATION_MODE.PAN : this.NAVIGATION_MODE.ORBIT
    }
    ;
    this.setNavigationMode = function(a) {
        if (a != this.getNavigationMode()) {
            switch (a) {
            case this.NAVIGATION_MODE.ORBIT:
                u.LOCK_DOLLY = 
                0;
                u.LOCK_PAN = 0;
                break;
            case this.NAVIGATION_MODE.PAN:
                u.LOCK_DOLLY = 0;
                u.LOCK_PAN = 1;
                break;
            case this.NAVIGATION_MODE.DOLLY:
                u.LOCK_DOLLY = 1,
                u.LOCK_PAN = 0
            }
            c(this.getNavigationMode())
        }
    }
    ;
    this.setSceneBounds = function(a) {
        r = a
    }
    ;
    this.recordHomeView = function() {
        this.homePosition.copy(h.getPosition());
        this.homeTarget.copy(h.getLookAtPoint());
        this.homeUp.copy(h.getWorldUpVector());
        this.homeFov = this.camera.fov
    }
    ;
    this.goHome = function() {
        this.changeWorldUp(this.homeUp.x, this.homeUp.y, this.homeUp.z);
        this.transitionView(this.homePosition, 
        this.homeTarget, this.homeFov, 10)
    }
    ;
    this.getBoundingBox = function() {
        var a;
        null  != A && (a = A.getSelectionBounds());
        a && !a.empty() || !m.modelQueue || m.modelQueue.areAllVisible() || (a = m.modelQueue.getVisibleBounds());
        if (!a || a.empty())
            a = r;
        return a
    }
    ;
    this.setWorldUp = function(a) {
        a && 1E-5 < h.getWorldUpVector().sub(a).lengthSq() && (h.setWorldUpVector(a),
        B = !0)
    }
    ;
    this.getCOI = function() {
        return h.getPivotPoint()
    }
    ;
    this.getLookAtPoint = function() {
        return h.getLookAtPoint()
    }
    ;
    this.changeWorldUp = function(a, b, c) {
        G = new THREE.Vector3(a,
        b,c);
        a = h.getWorldUpVector();
        M = 10;
        b = G.clone().sub(a);
        b.multiplyScalar(1 / M);
        this.setWorldUp(a.add(b));
        --M
    }
    ;
    this.getWorldUp = function() {
        return h.getWorldUpVector()
    }
    ;
    this.getCameraUp = function() {
        return h.getCameraUpVector()
    }
    ;
    this.getFOV = function() {
        return this.camera.fov
    }
    ;
    this.setFOV = function(a) {
        h.changeFOV(a)
    }
    ;
    this.getFocalLength = function() {
        var a = THREE.Math.degToRad(this.camera.fov);
        0 >= a && (a = 1E-4);
        return Math.round(12 / Math.tan(.5 * a))
    }
    ;
    this.setFocalLength = function(a) {
        h.changeFOV(b(a))
    }
    ;
    this.transitionView = 
    function(a, b, c, d) {
        Q = d - 1;
        R = a;
        S = b;
        U = c;
        h.oneStepTowards(a, b, c, d);
        this.pivotActive(!1)
    }
    ;
    this.fitToView = function(a, b) {
        b || (b = this.getBoundingBox());
        var c = h.getPosition()
          , d = b.center()
          , e = b.size()
          , e = .5 * Math.sqrt(e.x * e.x + e.y * e.y + e.z * e.z)
          , f = Math.max(1, .9 + this.camera.fov / 100 * .5)
          , e = e * f
          , f = h.getPivotDistance()
          , e = e / Math.tan(THREE.Math.degToRad(.5 * this.camera.fov)) / f
          , f = h.getViewOffset();
        if (1E-5 < Math.abs(e - 1) || 0 < f.lengthSq())
            f = new THREE.Vector3,
            f.subVectors(h.getLookAtPoint(), c),
            f.set(-f.x, -f.y, -f.z),
            f.multiplyScalar(e),
            c = d.clone(),
            c.add(f),
            a ? h.setView(c, d, 0, 0, !0) : (this.transitionView(c, d, this.camera.fov, 10),
            x = !0),
            y.shown() && this.activatePivot(y.fading())
    }
    ;
    this.handleEvent = function(a) {
        if ("function" == typeof this[a.type])
            this[a.type](a)
    }
    ;
    this.setViewport = function(a) {
        this.viewport = a;
        h.setScreenViewport(a)
    }
    ;
    this.activatePivot = function(a) {
        var b = 10 * h.getPivotDistance() * Math.tan(THREE.Math.degToRad(.5 * this.camera.fov)) / (this.viewport.height * (window.devicePixelRatio || 1));
        y.show(h.getPivotPoint(), b, a)
    }
    ;
    this.pivotActive = function(a, 
    b) {
        b = b || !1;
        !a && y.shown() ? y.hide() : a && this.activatePivot(b)
    }
    ;
    this.interactionStart = function(a, b) {
        if (b || a > w)
            w = a,
            O = !0,
            this.pivotActive(!0, -1 == a)
    }
    ;
    this.interactionEnd = function(a) {
        a == w && (-1 != a && this.pivotActive(!1),
        O = !1)
    }
    ;
    this.autoMove = function(a, b) {
        0 > a ? v[0] = v[1] = v[2] = v[3] = v[4] = v[5] = b : v[a] = b;
        b ? this.interactionStart(-2) : v[0] || v[1] || v[2] || v[3] || v[4] || v[5] || this.interactionEnd(-2)
    }
    ;
    this.getMotionDelta = function(a, b) {
        v[0] && (p.x -= .01);
        v[1] && (p.x += .01);
        v[2] && (p.y -= .01);
        v[3] && (p.y += .01);
        v[4] && (p.z -= -.4);
        v[5] && 
        (p.z += -.4);
        var c = p.x - n.x
          , d = p.y - n.y
          , e = p.z - n.z;
        .001 > Math.abs(c) && (c = 0);
        .001 > Math.abs(d) && (d = 0);
        .001 > Math.abs(e) && (e = 0);
        !b || 0 == c && 0 == d && 0 == e ? n.copy(p) : (n.x += .6 * c,
        n.y += .6 * d,
        n.z += .6 * e);
        a.set(c, d, e)
    }
    ;
    this.adjustSpeed = function(a) {
        h.adjustDollyLookSpeed(a)
    }
    ;
    this.update = function() {
        var a = !1
          , b = !1;
        this.getMotionDelta(t, !K && !d());
        var f = t.x
          , g = t.y
          , k = t.z;
        if (!E && u.ALT && u.SHIFT) {
            E = !0;
            var l = h.getLookAtPoint();
            h.saveCOI();
            h.setPivotPoint(l, !0);
            this.pivotActive(!0);
            this.interactionStart(-2);
            z.start(l, h.getCameraUpVector());
            B = !0;
            c(this.NAVIGATION_MODE.ROLL)
        }
        !C && u.CONTROL && u.SHIFT && (C = !0,
        this.interactionStart(-2),
        c(this.NAVIGATION_MODE.FOV));
        if (0 != f || 0 != g || 0 != k) {
            Q = M = 0;
            x = !1;
            !(2 === w && u.ALT && !u.SHIFT || 1 === w && u.CONTROL && !u.SHIFT || 0 === w && (u.F3 || u.LOCK_DOLLY)) || E || C || d() || (g = -g,
            k = Math.abs(f) > Math.abs(g) ? f : g,
            k *= -20,
            g = f = 0,
            c(this.NAVIGATION_MODE.DOLLY));
            if (E)
                K = !1,
                z.handleRoll(f, g, p, h.getLookAtPoint(), this);
            else if (C)
                K = !1,
                0 <= w ? (g = -g,
                k = Math.abs(f) > Math.abs(g) ? f : g,
                k *= -1) : k *= .01,
                0 !== k && h.changeFOV(this.camera.fov * (1 + k));
            else if (d()) {
                this.pivotActive(O);
                if (0 == K) {
                    var l = h.getPivotDistance()
                      , r = e(this.camera, p.x, p.y);
                    r && (l = r.sub(h.getPosition()),
                    r = h.getEyeVector().normalize(),
                    l = Math.abs(r.dot(l)));
                    h.setTrackingDistance(l);
                    K = !0;
                    c(this.NAVIGATION_MODE.PAN)
                }
                h.trackRelative(f, g)
            } else
                c(0 !== k ? this.NAVIGATION_MODE.DOLLY : this.NAVIGATION_MODE.ORBIT),
                h.orbitRelative(.6 * f, .6 * g, k, e),
                F = !0,
                K = !1;
            this.pivotActive(O, -1 === w)
        }
        -1 === w && 1E-6 > Math.abs(k) && (this.interactionEnd(-1),
        a = !0);
        if (E || C)
            u.ALT && u.SHIFT || u.CONTROL && u.SHIFT ? O || this.interactionStart(-2, !0) : (this.interactionEnd(-2),
            b = !0);
        if (a && !C && !E || b || !O && (E || K || C || -3 < w))
            F && !z.isSnapped() && this.setWorldUp(h.getCameraUpVector()),
            E && (z.end(),
            E = !1,
            h.restoreCOI(),
            B = !0),
            -1 < w && n.copy(p),
            F = C = K = !1,
            b || (w = -3),
            c(this.getNavigationMode());
        0 < M && G && (a = h.getWorldUpVector(),
        b = G.clone().sub(a),
        b.multiplyScalar(1 / M),
        this.setWorldUp(a.add(b)),
        --M);
        0 < Q && R && S && (h.oneStepTowards(R, S, U, Q),
        --Q,
        0 == Q && x && (this.pivotActive(!0, !0),
        x = !1));
        y.shown() && y.fade() && (m.overlayDirty = !0);
        return B || h.isDirty() ? (h.updateCamera(),
        B = !1,
        !0) : !1
    }
    ;
    this.clientToCanvasCoords = 
    function(a, b) {
        var c = this.domElement.getBoundingClientRect()
          , d = c.width
          , e = c.height
          , f = a.clientX - c.left
          , c = a.clientY - c.top;
        a.canvasX = f;
        a.canvasY = c;
        a.normalizedX = f / d * 2 - 1;
        a.normalizedY = (e - c) / e * 2 - 1;
        null  !== b && b.set(f / d, c / e, 0)
    }
    ;
    this.handleResize = function() {
        this.setViewport(m.api.container.getBoundingClientRect())
    }
    ;
    this.setCOIFromMouse = function(a, b) {
        var c = (new CameraRaycaster(m,this.camera)).castRayViewport(a, b, !0);
        c.intersectPoint && this.setCOI(c.intersectPoint, !0)
    }
    ;
    this.handleSingleClick = function(a) {
        if (0 == 
        w) {
            a = (new CameraRaycaster(m,this.camera)).castRay(a.clientX, a.clientY, !1);
            var b = "click";
            u.CONTROL && (b += "Ctrl");
            u.SHIFT && (b += "Shift");
            u.ALT && (b += "Alt");
            u.SPACE && (b += "Space");
            u.F1 && (b += "F1");
            u.F2 && (b += "F2");
            u.F3 && (b += "F3");
            u.F4 && (b += "F4");
            var c = ""
              , c = a.node || a.intersectPoint ? "onObject" : "offObject";
            this.clickConfig && this.clickConfig[b] && this.clickConfig[b][c] && this.handleAction(this.clickConfig[b][c], a)
        }
    }
    ;
    this.handleAction = function(a, b) {
        for (var c = 0; c < a.length; ++c)
            switch (a[c]) {
            case "selectOnly":
                A && b.node && 
                A.setSelection([b.node]);
                break;
            case "deselectAll":
                A && A.setSelection([]);
                break;
            case "selectToggle":
                A && b.node && A.toggleSelection(b.node);
                break;
            case "isolate":
                b.node && m.api.isolate(b.node);
                break;
            case "showAll":
                m.visibilityManager.isolateNone();
                break;
            case "setCOI":
                b.intersectPoint && (this.setCOI(b.intersectPoint, !0),
                this.pivotActive(!0, !0));
                break;
            case "hide":
                b.node && m.hideMultiple([b.node]);
                break;
            case "show":
                b.node && m.showMultiple([b.node]);
                break;
            case "toggleVisibility":
                b.node && m.toggleVisibility(b.node);
                break;
            case "focus":
                A && (b.node ? A.setSelection([b.node]) : A.setSelection([]),
                this.fitToView())
            }
    }
    ;
    this.handleDoubleClick = function(a) {
        null  != A && 0 == a.button && (A.clearSelection(),
        a = (new CameraRaycaster(m,this.camera)).castRay(a.clientX, a.clientY, !1),
        a.node && A.toggleSelection(a.node),
        this.fitToView())
    }
    ;
    this.handleWheelInput = function(a) {
        p.z += -.1 * a;
        0 != a && this.interactionStart(-1)
    }
    ;
    this.applyKepMappings = function(a) {
        switch (a.keyCode) {
        case 91:
            return 17;
        case 93:
            return 17;
        case 224:
            return 17;
        case 17:
            if (-1 != navigator.userAgent.search("Mac OS"))
                return null ;
            break;
        case 188:
        case 186:
            return 37;
        case 190:
        case 222:
            return 39;
        case 219:
            return 33;
        case 191:
            return 34;
        case 72:
            return 36
        }
        return a.keyCode
    }
    ;
    this.handleKeyDown = function(a) {
        switch (this.applyKepMappings(a)) {
        case 16:
            u.SHIFT = 1;
            break;
        case 17:
            u.CONTROL = 1;
            break;
        case 18:
            u.ALT = 1;
            break;
        case 32:
            u.SPACE = 1;
            break;
        case 112:
            u.F1 = 1;
            break;
        case 113:
            u.F2 = 1;
            break;
        case 114:
            u.F3 = 1;
            break;
        case 115:
            u.F4 = 1;
            break;
        case 36:
            this.goHome();
            break;
        case 70:
            this.fitToView();
            break;
        case 187:
            this.adjustSpeed(1);
            break;
        case 189:
            this.adjustSpeed(-1);
            break;
        case 48:
            this.adjustSpeed(0);
            break;
        case 88:
            this.changeWorldUp(1, 0, 0);
            break;
        case 89:
            this.changeWorldUp(0, 1, 0);
            break;
        case 90:
            this.changeWorldUp(0, 0, 1);
            break;
        case 37:
            this.autoMove(0, !0);
            break;
        case 39:
            this.autoMove(1, !0);
            break;
        case 33:
            this.autoMove(2, !0);
            break;
        case 34:
            this.autoMove(3, !0);
            break;
        case 38:
            this.autoMove(4, !0);
            break;
        case 40:
            this.autoMove(5, !0);
            break;
        default:
            return !1
        }
        return !0
    }
    ;
    this.handleKeyUp = function(b) {
        switch (this.applyKepMappings(b)) {
        case 16:
            u.SHIFT = 0;
            break;
        case 17:
            u.CONTROL = 0;
            break;
        case 18:
            u.ALT = 0;
            break;
        case 32:
            u.SPACE = 0;
            break;
        case 112:
            u.F1 = 0;
            break;
        case 113:
            u.F2 = 0;
            break;
        case 114:
            u.F3 = 0;
            break;
        case 115:
            u.F4 = 0;
            break;
        case 36:
        case 70:
            break;
        case 37:
            this.autoMove(0, !1);
            break;
        case 39:
            this.autoMove(1, !1);
            break;
        case 33:
            this.autoMove(2, !1);
            break;
        case 34:
            this.autoMove(3, !1);
            break;
        case 38:
            this.autoMove(4, !1);
            break;
        case 40:
            this.autoMove(5, !1);
            break;
        case 27:
            if (a.objectContextMenu.hide())
                break;
            a.api.fireEvent({
                type: ESCAPE_EVENT
            });
            this.autoMove(-1, !1);
            u.SHIFT = 0;
            u.CONTROL = 0;
            u.ALT = 0;
            u.SPACE = 0;
            u.F1 = 0;
            u.F2 = 0;
            u.F3 = 0;
            u.F4 = 0;
            break;
        default:
            return !1
        }
        return !0
    }
    ;
    this.handleButtonDown = function(a) {
        this.interactionStart(a)
    }
    ;
    this.handleButtonUp = function(a) {
        this.interactionEnd(a)
    }
    ;
    this.resize = function(a) {
        H.handleResize()
    }
    ;
    this.keydown = function(a) {
        "INPUT" != document.activeElement.nodeName && H.handleKeyDown(a) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.keyup = function(a) {
        "INPUT" != document.activeElement.nodeName && H.handleKeyUp(a) && (a.preventDefault(),
        a.stopPropagation())
    }
    ;
    this.updateModifierState = function(a) {
        var b = 
        -1 != navigator.userAgent.search("Mac OS");
        u.CONTROL = b && a.metaKey || !b && a.ctrlKey ? 1 : 0;
        u.SHIFT = a.shiftKey ? 1 : 0;
        u.ALT = a.altKey ? 1 : 0
    }
    ;
    this.mousedown = function(a) {
        function b(a) {
            a.button === c && (document.removeEventListener("mouseup", b),
            H.mouseup(a))
        }
        if (!H.isDragging) {
            document.activeElement.blur();
            a.preventDefault();
            a.stopPropagation();
            H.updateModifierState(a);
            H.clientToCanvasCoords(a, n);
            p.copy(n);
            H.handleButtonDown(a.button);
            H.downX = a.canvasX;
            H.downY = a.canvasY;
            H.isDragging = !0;
            var c = a.button;
            document.addEventListener("mouseup", 
            b, !1)
        }
    }
    ;
    this.mousemove = function(a) {
        if (H.isDragging) {
            a.preventDefault();
            a.stopPropagation();
            H.updateModifierState(a);
            H.clientToCanvasCoords(a, p);
            var b = H.downY - a.canvasY;
            if (2 < Math.abs(H.downX - a.canvasX) || 2 < Math.abs(b))
                H.downX = -1,
                H.downY = -1
        }
    }
    ;
    this.mouseup = function(a) {
        a.preventDefault();
        a.stopPropagation();
        H.updateModifierState(a);
        H.clientToCanvasCoords(a, p);
        H.handleButtonUp(a.button);
        var b = H.downY - a.canvasY;
        (2 >= Math.abs(H.downX - a.canvasX) || 2 >= Math.abs(b)) && H.handleSingleClick(a);
        H.downX = -1;
        H.downY = -1;
        H.isDragging = !1
    }
    ;
    this.doubleclick = function(a) {
        a.preventDefault();
        a.stopPropagation();
        H.clientToCanvasCoords(a, n);
        p.copy(n);
        H.downX = a.canvasX;
        H.downY = a.canvasY;
        H.handleDoubleClick(a)
    }
    ;
    this.mousewheel = function(a) {
        a.preventDefault();
        a.stopPropagation();
        var b = 0;
        a.wheelDelta ? b = a.wheelDelta / 40 : a.detail && (b = 3 * -a.detail);
        H.handleWheelInput(b)
    }
    ;
    this.touchstart = function(a) {
        H.mousedown(a)
    }
    ;
    this.touchmove = function(a) {
        H.mousemove(a)
    }
    ;
    this.touchend = function(a) {
        H.mouseup(a)
    }
    ;
    this.domElement.addEventListener("mousedown", 
    this.mousedown, !1);
    this.domElement.addEventListener("mousemove", this.mousemove, !1);
    this.domElement.addEventListener("dblclick", this.doubleclick, !1);
    this.domElement.addEventListener("mousewheel", this.mousewheel, !1);
    this.domElement.addEventListener("DOMMouseScroll", this.mousewheel, !1);
    this.domElement.addEventListener("touchstart", this.touchstart, !1);
    this.domElement.addEventListener("touchend", this.touchend, !1);
    this.domElement.addEventListener("touchmove", this.touchmove, !1);
    window.addEventListener("keydown", 
    this.keydown, !1);
    window.addEventListener("keyup", this.keyup, !1);
    window.addEventListener("resize", this.resize, !1);
    this.handleResize()
}
ViewController.prototype = Object.create(THREE.EventDispatcher.prototype);
Selector = function(a) {
    function b(a) {
        var c = a.dbId || a.fragIds;
        if (0 < g[c]) {
            if (g[c]--,
            0 == g[c] && (c = a.fragIds,
            "undefined" != typeof c)) {
                Array.isArray(c) || (c = [c]);
                for (var e = 0; e < c.length; ++e) {
                    var l = d.viewer.modelQueue.vizmeshes[c[e]];
                    1 == l.highlighted && (l.highlighted = !1,
                    d.viewer.needsClear = !0);
                    l.selectionProxy && (d.viewer.removeOverlay("selection", l.selectionProxy),
                    delete l.selectionProxy)
                }
            }
        } else if (0 > g[c])
            throw "Selection State machine broken. Negatively selected object!";
        if (a.children)
            for (e = 0; e < a.children.length; e++)
                b(a.children[e])
    }
    function c(a, b) {
        var e = a.dbId || a.fragIds;
        if (g[e])
            g[e]++;
        else {
            var l = a.fragIds;
            if ("undefined" != typeof l) {
                Array.isArray(l) || (l = [l]);
                for (var m = 0; m < l.length; ++m) {
                    var n = d.viewer.modelQueue.vizmeshes[l[m]];
                    b ? n.highlighted = !0 : (n.selectionProxy = new THREE.Mesh(n.geometry,n.material,!0),
                    n.selectionProxy.matrixWorld = n.matrixWorld,
                    d.viewer.addOverlay("selection", n.selectionProxy))
                }
            }
            g[e] = 1
        }
        if (a.children)
            for (m = 0; m < a.children.length; m++)
                c(a.children[m], !0);
        b && (d.viewer.needsClear = !0)
    }
    function e(a) {
        -1 == d.findSelection(a) && 
        (d.selectedObjects.push(a),
        c(a))
    }
    var d = this;
    this.viewer = a;
    this.projector = new THREE.Projector;
    this.raycaster = new THREE.Raycaster;
    this.selectedObjects = [];
    this.intersectPoint = null ;
    var g = {};
    this.setIntersectPoint = function(a) {
        d.intersectPoint = a
    }
    ;
    this.getIntersectPoint = function() {
        return d.intersectPoint
    }
    ;
    this.getSelectionLength = function() {
        return d.selectedObjects.length
    }
    ;
    this.getSelection = function() {
        objects = [];
        for (var a = 0; a < d.selectedObjects.length; a++)
            objects.push(d.selectedObjects[a]);
        return objects
    }
    ;
    this.clearSelection = function() {
        if (0 < this.selectedObjects.length) {
            for (var a = 0; a < d.selectedObjects.length; a++)
                b(d.selectedObjects[a]);
            d.selectedObjects.length = 0;
            this.fireSelectionChangedEvent()
        }
    }
    ;
    this.fireSelectionChangedEvent = function() {
        for (var a = [], b = [], c = 0; c < d.selectedObjects.length; c++)
            a.push(d.selectedObjects[c].dbId),
            b.push(d.selectedObjects[c].fragIds);
        a = {
            type: SELECTION_CHANGED_EVENT,
            dbIdArray: a,
            fragIdsArray: b,
            nodeArray: this.getSelection()
        };
        this.viewer.api.fireEvent(a)
    }
    ;
    this.isSelected = function(a) {
        return -1 != 
        this.findSelection(a)
    }
    ;
    this.findSelection = function(a) {
        return this.selectedObjects.indexOf(a)
    }
    ;
    this.toggleSelection = function(a) {
        if (a) {
            if (this.isSelected(a)) {
                var c = d.findSelection(a);
                0 <= c && (b(a),
                d.selectedObjects.splice(c, 1))
            } else
                e(a);
            d.fireSelectionChangedEvent()
        }
    }
    ;
    this.setSelectionIds = function(a) {
        this.setSelection(this.viewer.getNodesByIds(a))
    }
    ;
    this.setSelection = function(a) {
        this.clearSelection();
        if (null  != a) {
            for (var b = 0; b < a.length; b++)
                e(a[b]);
            0 < a.length && this.fireSelectionChangedEvent()
        }
    }
    ;
    this.toggleSelectionId = 
    function(a) {
        this.toggleSelection(this.viewer.getNodesByIds([a])[0])
    }
    ;
    this.isSelectedOrParentIsSelected = function(a) {
        for (; a; ) {
            if (0 <= this.findSelection(a))
                return !0;
            a = a.parent
        }
        return !1
    }
    ;
    this.getSelectionMeshes = function() {
        for (var a = [], b = 0; b < d.selectedObjects.length; ++b) {
            var c = d.selectedObjects[b].fragIds;
            Array.isArray(c) || (c = [c]);
            for (var e = 0; e < c.length; ++e)
                a.push(d.viewer.modelQueue.vizmeshes[c[e]])
        }
        return a
    }
    ;
    this.getSelectionFragIds = function() {
        for (var a = Array(this.selectedObjects.length), b = 0; b < d.selectedObjects.length; ++b) {
            var c = 
            function(b) {
                var d = b.fragIds;
                Array.isArray(d) || (d = [d]);
                for (var e = 0; e < d.length; ++e)
                    a.push(d[e]);
                if (b.children)
                    for (d = 0; d < b.children.length; d++)
                        c(b.children[d])
            }
            ;
            c(d.selectedObjects[b])
        }
        return a
    }
    ;
    this.getSelectionBounds = function() {
        var a = new THREE.Box3
          , b = new THREE.Vector3
          , c = new THREE.Vector3
          , e = new THREE.Box3
          , g = 0 < d.viewer.explodeScale
          , n = this.viewer.svf.fragments
          , p = n.boxes
          , t = d.getSelectionFragIds();
        if (g)
            var v = d.viewer.modelQueue.vizmeshes
              , r = n.transforms;
        for (n = 0; n < t.length; ++n) {
            var u = 6 * t[n];
            b.x = p[u];
            b.y = 
            p[u + 1];
            b.z = p[u + 2];
            c.x = p[u + 3];
            c.y = p[u + 4];
            c.z = p[u + 5];
            if (g && t[n]) {
                var w = t[n]
                  , u = 16 * w
                  , w = v[w].matrixWorld.elements;
                b.x += w[12] - r[u + 12];
                c.x += w[12] - r[u + 12];
                b.y += w[13] - r[u + 13];
                c.y += w[13] - r[u + 13];
                b.z += w[14] - r[u + 14];
                c.z += w[14] - r[u + 14]
            }
            e.set(b, c);
            a.union(e)
        }
        return a
    }
}
;
VisibilityManager = function(a) {
    this.viewerImpl = a
}
;
VisibilityManager.prototype.isolate = function(a) {
    a ? this.isolateMultiple([a]) : this.isolateNone()
}
;
VisibilityManager.prototype.isolateNone = function() {
    this.viewerImpl.modelQueue.setAllVisibility(!0);
    this.viewerImpl.svf.instanceTree && this.setVisibiltyOnNode(this.viewerImpl.svf.instanceTree, !0);
    this.viewerImpl.modelQueue.setOverrideMaterial(null );
    this.viewerImpl.needGhostedPass = !1;
    this.viewerImpl.needsClear = !0;
    this.viewerImpl.api.fireEvent({
        type: ISOLATE_EVENT,
        nodeIdArray: []
    })
}
;
VisibilityManager.prototype.isolateMultiple = function(a) {
    var b = (new Date).getTime();
    if (a && 0 != a.length) {
        this.viewerImpl.svf.instanceTree && this.setVisibiltyOnNode(this.viewerImpl.svf.instanceTree, !1);
        this.viewerImpl.modelQueue.setAllVisibility(!1);
        for (var c = 0; c < a.length; c++)
            this.setVisibiltyOnNode(a[c], !0),
            this.viewerImpl.needGhostedPass = !0;
        this.viewerImpl.api.fireEvent({
            nodeIdArray: a,
            type: "isolate"
        })
    } else
        this.isolateNone();
    a = (new Date).getTime() - b;
    stderr("Isolate time: " + a);
    this.viewerImpl.needsClear = 
    !0
}
;
VisibilityManager.prototype.hideMultiple = function(a) {
    for (var b = 0; b < a.length; ++b)
        this.setVisibiltyOnNode(a[b], !1);
    0 < a.length && this.viewerImpl.api.fireEvent({
        type: HIDE_EVENT,
        nodeIdArray: a
    })
}
;
VisibilityManager.prototype.hide = function(a) {
    this.setVisibiltyOnNode(a, !1);
    this.viewerImpl.api.fireEvent({
        type: HIDE_EVENT,
        nodeIdArray: [a]
    })
}
;
VisibilityManager.prototype.showMultiple = function(a) {
    for (var b = 0; b < a.length; ++b)
        this.setVisibiltyOnNode(a[b], !0);
    0 < a.length && this.viewerImpl.api.fireEvent({
        type: SHOW_EVENT,
        nodeIdArray: a
    })
}
;
VisibilityManager.prototype.show = function(a) {
    this.setVisibiltyOnNode(a, !0);
    this.viewerImpl.api.fireEvent({
        type: SHOW_EVENT,
        nodeIdArray: [a]
    })
}
;
VisibilityManager.prototype.toggleVisibility = function(a) {
    var b = this.isVisible(a);
    this.setVisibiltyOnNode(a, !b);
    this.viewerImpl.api.fireEvent(b ? {
        type: HIDE_EVENT,
        nodeIdArray: [a]
    } : {
        type: SHOW_EVENT,
        nodeIdArray: [a]
    })
}
;
VisibilityManager.prototype.setVisibiltyOnNode = function(a, b) {
    var c = (new Date).getTime()
      , e = this.viewerImpl;
    (function g(a) {
        a.visible = b;
        var c = a.fragIds;
        if (void 0 !== c)
            if (Array.isArray(c))
                for (var h = 0; h < c.length; h++)
                    e.modelQueue.setVisibility(c[h], b);
            else
                e.modelQueue.setVisibility(c, b);
        if (a.children)
            for (c = 0; c < a.children.length; c++)
                g(a.children[c])
    }
    )(a);
    this.viewerImpl.needGhostedPass = !0;
    c = (new Date).getTime() - c;
    stderr("Hide time: " + c);
    this.viewerImpl.needsClear = !0
}
;
VisibilityManager.prototype.isVisible = function(a) {
    return null  != a.visible ? a.visible : !0
}
;
VisibilityManager.prototype.areAllVisible = function() {
    return this.viewerImpl.modelQueue.areAllVisible()
}
;
var backimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAwBJREFUeF7tl8GNIjEQRUmADIiADEiADIiAAAiABLgTAGfuBEAIG9I+8T2W1d2s5oNpadF/B9Qum5qpN2W7ZxE8/oRfEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWUQWQaRZRBZBpFlEFkGkWXQX1bJOGKz2RwOh/v9Xtb15nK56AeV8QdQ/jlkifV6/SFf/7GsMvgBQefzeblcMrXb7Uq0K98jS+CLKZSVcVe+TRZMzlLndrtV38FqtaL7brdbmf6B9uTUY1bL2NGn06nMPZF1vV6Vtl35Mso/kyzVQ7Vl/ID69ZUBFNn6qmUPqJt6LKuvKVD+j8tqz6zj8Viij3q0nqAOfj55VnC/32sZ0EdE+EQKw3aZIgNZ3U2B8veX9Yy2fmBIcHzkEyHO24aG9bCT0Er79VbWJ0yB8s8ni7NpUPAk2ptVloZjpy1V1odMgfL3l1UGDRSDKaYmX7WIsIDy8IIjJamyFGFKw0mqLG1YoB/LXCeUdg5ZQmW3xxYl1QtuwGuyQH+V8bZ9EyWfT5Y2FMVoqMMIKAwjnEEsoGwte02Wdp/6a3BEvonyzy2rWlBPjS3o5K7Lnt0DLVXWYMiDIu+jhPPJ0h+8bkMtHtTD65VO6Crr2W0oI8TrM2gKpHjwWvcOyj+HLC6pepTUt011FnFFcMEmkimoskCW+axmMaiVasyxLLK1C95H+fvL+gftjc5ziTZgsL5wlnUP15P3APrUbmNZUPOP/3l6AaWaQxZVceiMf2kaRF0D6KALKL42BY7KukenMFuV8a32Vp2UBboc2iZ9GeXvKeuLiSyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsg8gyiCyDyDKILIPIMogsgyIr/IrF4i9O3m/GBVQ86AAAAABJRU5ErkJggg=="
  , 
frontimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAkhJREFUeF7t18Ft4kAcRnEaoINUQAc0QAdUQAEUQAPcKYAz9xRACVvSfsl/MrLW68gvjiJE3u+AmPEw4CfjkJWYP5rBWICxAGMBxgKMBRgLMBZgLMBYgLEAYwHGAowFGAswFmAswFiAsQBjAcYCjAUYCzAWYCzAWICxAGMBxgKMBRgLMBZgLMBYgLEAYwHGAn5FrPv93p4t852x2l7TttttW/pTrtfry8tLHtt4mXYabbRM22vaz8fKO+Z9HzdWGzwGYwHPEOt4PGZlzuFwONSrht/QzO92u/V6nfk87vf72+3Wjr3LgnpJ7tw5OlzZ7+X1FkOZqUNf1jZqo2Xmb1VnkiL1ksjz4aGx8/lcC6Ji5c5dmYYyWb2eLVbUtRCvr6+Zv1wufb5m8tib9uurYkVi9Yin06km86Rm4tG/hlOGn7hi5VTb+MNms8l8v8q6OucUrGGPlbg1U7JguCyeJ9bwPhW5vmplXVNDdcX1uD1WDbvxto8eqw0+VWeVxzZ+N5WgDA/Vyn9ah7Ga4SFjGWvCf2PRe9avjhWf/zXs88Z6g35nzY81fqOvefsQ0UbLzN9qKlbUobHxL/g5seqXV1merG3URsvM3+qTWJEW/WrKfSonPPW/YRt/GMfKfbBvNf52U7XP98R6esYCjAUYCzAWYCzAWICxAGMBxgKMBRgLMBZgLMBYgLEAYwHGAowFGAswFmAswFiAsQBjAcYCjAUYCzAWYCzAWICxAGMBxgKMBRgLMBZgLMBYgLEAYwHGAowFtFiaZbX6C2hay0Y0gxV3AAAAAElFTkSuQmCC"
  , 
leftimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAh5JREFUeF7t1sGt2kAYRWEaoAMqoAMaoAMqoAAKoAH2FJA1ewqghJSUK//ziGWZxEexF3k+Z4GYwYzlTxjPxlg/bUJigcQCiQUSCyQWSCyQWCCxQGKBxAKJBRILJBZILJBYILFAYoHEAokFEgskFkgskFggsUBigcQCiQUSCyQWSCyQWCCxQGKBxAKJBRILJBZILNA3wXq9Xu3dki2LNfviQTkej9vttlb+0bXb7fLajliyOul/g3U4HGrNKkY1I9ZIteD1em3jLz6xRqoF+zRrxMqf0eVy2e/39ZW8ybB91jW4AUcbfGX22mnaaO4mLh6pN1O/TL4fc2K1CiI09/u9ZvKm+PLsq5mqW2/Ft+Hj8cgxefwP9koZ1hbh+Xy2KbFy7+SY0TvofD7no/6zr1tvxVh//TPqO9aMWB8T63d1tRMfZLXgerHqj+l0OrXxH6sF14uVXUIdlsdim/qqdg+3262NxUp1wdkoxKU2EIHLDiuTgy1Ft94I1sS7+B+rsy+L9alcZx0WjtEdfPgGP7ea72Pl/q3JtDRZO00bzV1b/UNvrBSvXOqbLD+oKPS3o1V92sfKF+s3mAbb/dmrsyyF9c0SCyQWSCyQWCCxQGKBxAKJBRILJBZILJBYILFAYoHEAokFEgskFkgskFggsUBigcQCiQUSCyQWSCyQWCCxQGKBxAKJBRILJBZILJBYILFAYoHEAokFalg2qc3mF7emV+lhX3Y0AAAAAElFTkSuQmCC"
  , 
rightimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAwdJREFUeF7tl8GV4jAQREmADIiADEiADIiAAAiABLgTAGfuBEAIhLQ1rqafVzaMa+RZDFv/MM/dljTSpyXEzGjczAAsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS+DzZV2v13iqZjRZMVAfi8Vis9mcz+doeodvIxjM6XRCr9VqFfFj0BL/Gn8jroYT/l1ZyfF4jNYNTEYwmOGy0AYtpysrgr+Bo+Vyibfz+TxSFXy4LICDA6bQoH7qny8LdKfe2yXLEKzXa5x0u90Oz2knZeEDwCucSgjxSeBYzLOcXdogw1c1xFgRVfB8nN7K6nbZbrdMJugFZXgoZEFoOk2Qoa93lYXZHw4HLgxVENmGogstACyMa0aVUTEoZAG8wshsud/vmUSGzUC3livhvxhN1hOwtuL2wHwEtxsrCMUVcQO6sFlXVtsLwDZEst39LWWhrLAGlkAbvo3gHl4ul4jv9G5DwDDh1stmYOqyImjAJ49qAo/Oi3aXRwpAYYEt21LIe8sCqaDYXISv+GxZX3ANoLi+A+b5bFkBvwqxH4tjq+jCcOCZ9bGysmqKzchkBHcpWHPEDXDHZv+LLABNbNC+PTATQcspls0aRIYXdPBjWYX9Gr7mASKq4Pk4WDy2IRpgS0aqr0s6TdCrqLjhsnjzIqMoi7EiquDbcXCTYBvctplhyOfk0W/DH8jCJ0TRAA+RrYBDjSDr92CBjFIaldDVJGRxJsUNI/dv9+bx7+EMJyGLWwZ7ML1gD3JLFr/AX0WjahqyoIZFVIBk+zv0hcSEIno1uFXhhMrrAh4Qdq+pr4KzmvQBPx0sS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgQsS8CyBCxLwLIELEvAsgRClhnEbPYH0gUbEtCHMj0AAAAASUVORK5CYII="
  , 
topimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAldJREFUeF7t10FxAkEYRGEM4AAFOMAADlCAAARggDsCOHNHABIiKV30ZGprIcl2yGSS1HsndpnwL18NsJlR1gtNCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACgIrCKwgsILACmqLtdvtyoDPKn/wu2t7rWA91Wq10jghluM/la3AmpStfgXW5XLZbDaLxcKXtF6vj8djee7W6XTyU3qsV/DK+Xyuv7per17TNE/vjyUXvW1fzDBBlBUDLJ30g5r+VtZlXbPKsHLUvodYep+WWi6X5/NZZ7RTtOZ2abP9fu9lFUtp31lHJ73F9Mpe1i6P7oy13W51Uu959Gmyl877sGKNXOTr84Zul6d0xtKG0snD4VCO35Ld7eqKQsXSAy+oaaPp/Ohlvz1P74zla7gnUF7vpyqWnxrmPSiyctwmT/8nWFpcjtvk6f8Ea/jT2SJP74yVfmfdf5H7O6v+bjbK0ztjffxrqLsKH1as0Q6qv4atb7U8pTPWF+6z9Kxl691s68+g8ujOWCq6g/fHdpjOjHZli8qwctS+97CU9pdoKtkH/xvKRZ/cuhkfvlqLPP3nsJ6pYpXjH8/TwZqUp4M1KU8Ha1KeDtakPP1vYHUPrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKAisIrCCwgsAKKlg0qdnsFfMOaseS92wDAAAAAElFTkSuQmCC"
  , 
bottomimage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAxtJREFUeF7tlssN4kAQREmADIiADEiADIiAAAiABLgTAGfuBEAIhLS1rnZvawzGhVbCEvUOiJnp+T33jL0wGg8zAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsgRnJut/v8a9nWPNdNFkRPWCz2RwOh4/3drlcVqsVfqPccTwel8tlFOZB7DZK74joF6zX6898wTW6N7I4ZhTmAZekyYpCDwSdz2dkAZp2u13UKvyQLAJfaPrs4PycLPC09Xa7Id1wJbF1u91Ca7Q9HrjpWJ+ghu4q1SP+YxAmMn4x+PV6jbYOjolBkPJoZSQWkPPiNuR62H361YEuf4nSO0aCsQc0YRFR7sjj2ZCnVZU1jCen04kBgDG4QAFbE6wHU0ehB9NFz3dEhyi942lwvbPw0KK2yylWYtF8+IjM3dbIiccQs7ASG8bgqMEvsoyVmV85Rb5hEUZxuUhmE/50gf/6jsNgTdYr9vt9xHWgiEqsuMlzbqbm4ERZ3DDsRLmH3YfZWhUw8QFao6qDY9YnNwJH+D+ysI3qheuoB4QghvG5mSmyshdzqsKMQ9awSFmYncWk690mEaduDL6CI2iyolDAPnkcsMT0xeBGAWnsTJGF1qamUpsoC2OymNSY5AuyCCfOlGawZT2Hq8w7hcGW9Zxmld+9s+Yuq3mzjL8Nc29giizA8V+9DbN+7rKQI7zgoSCfPP7wuwabZBLBGncC6tv66YoZVg1K31lzkTVCc+jyY7Uhv4lI/arOdSMlo6ooS9cNwy/4+cpC7uTTbkAlmlIZEgEGo60HGZcJkqcJmcJzB2oaQlwGY1gMnjlF5iLrx7EsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLErAsAcsSsCwByxKwLAHLEghZZhKLxR8vGE8Vs0exkQAAAABJRU5ErkJggg==";
function ViewCube(a, b) {
    var c = new FireflyWebGLRenderer({
        alpha: !0
    });
    c.setSize(150, 150);
    a.appendChild(c.domElement);
    var e = new THREE.PerspectiveCamera(45,1,1,1E3);
    e.position.z = 600;
    var d = new THREE.Scene
      , g = new THREE.Vector3(0,0,0)
      , f = new THREE.BoxGeometry(200,200,200)
      , k = c.getMaxAnisotropy()
      , h = [];
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(rightimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(leftimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(topimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(bottomimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(frontimage),
        anisotropy: k
    }));
    h.push(new THREE.MeshBasicMaterial({
        map: textureFromString(backimage),
        anisotropy: k
    }));
    var k = new THREE.MeshFaceMaterial(h)
      , l = new THREE.Mesh(f,k);
    d.add(l);
    b.addEventListener("cameraChanged", function(a) {
        var b = a.camera.matrixWorldInverse.elements;
        g.set(b[2], b[6], b[10]);
        e.position.set(600 * g.x, 600 * g.y, 600 * g.z);
        g.set(0, 
        0, 0);
        e.lookAt(g);
        e.up = a.camera.up;
        g.set(0, 1, 0);
        a = g.angleTo(e.up);
        b = g.cross(e.up).normalize();
        0 == b.lengthSq() && b.set(0, 0, 1);
        l.setRotationFromAxisAngle(b, a);
        c.render(d, e)
    }
    );
    c.render(d, e)
}
function textureFromString(a) {
    var b = document.createElement("img")
      , c = new THREE.Texture(b);
    b.addEventListener("load", function(a) {
        c.needsUpdate = !0
    }
    );
    b.src = a;
    return c
}
;var CameraRaycaster = function(a, b) {
    this.projector = new THREE.Projector;
    this.raycaster = new THREE.Raycaster;
    this.camera = b;
    this.viewer = a;
    this.viewer.svf.fragments.fragToCachedNode || (this.viewer.svf.fragments.fragToCachedNode = [])
}
;
CameraRaycaster.prototype.castRay = function(a, b, c) {
    var e = this.viewer.canvas.getBoundingClientRect();
    return this.castRayViewport((a - e.left) / e.width * 2 - 1, 2 * -((b - e.top) / e.height) + 1, c)
}
;
CameraRaycaster.prototype.castRayViewport = function(a, b, c) {
    a = new THREE.Vector3(a,b,1);
    this.projector.unprojectVector(a, this.camera);
    this.raycaster.set(this.camera.position, a.sub(this.camera.position).normalize());
    var e = this.raycaster.intersectObjects(this.viewer.modelQueue.geomScenes, !0);
    b = a = null ;
    for (var d = 0; d < e.length; d++) {
        var g = e[d].object
          , f = g.visible;
        void 0 !== g.fragId && (f = 1 == (this.viewer.modelQueue.vizflags[g.fragId] & 3));
        if (f && (!c || !e[d].object.material.transparent)) {
            a = e[d].object;
            b = e[d].point;
            break
        }
    }
    c = null ;
    a && (this.viewer.svf.fragments.fragToDbNode && this.viewer.svf.fragments.fragToDbNode[a.fragId] ? c = this.viewer.svf.fragments.fragToDbNode[a.fragId] : (this.viewer.svf.fragments.fragToCachedNode[a.fragId] || (this.viewer.svf.fragments.fragToCachedNode[a.fragId] = {
        dbId: 0,
        fragIds: a.fragId
    }),
    c = this.viewer.svf.fragments.fragToCachedNode[a.fragId]));
    return {
        node: c,
        intersectPoint: b
    }
}
;
var USE_WORKER_POOL = !0
  , USE_SERVER_SIDE_SEARCH = !1
  , NUM_WORKER_THREADS = 3
  , NUM_PARALLEL_DOWNLOADS = 2
  , WORKER_SCRIPT = null ;
LMV_WORKER_URL || (LMV_WORKER_URL = "src/workers/mainworker.js");
void 0 == ENABLE_INLINE_WORKER && (ENABLE_INLINE_WORKER = !1);
ENABLE_DEBUG && (NUM_PARALLEL_DOWNLOADS = NUM_WORKER_THREADS = 6);
var WORKER_LOAD_GEOMETRY = "LOAD_GEOMETRY"
  , WORKER_LOAD_SVF = "LOAD_SVF"
  , WORKER_SEARCH = "SEARCH"
  , WORKER_GET_PROPERTIES = "GET_PROPERTIES"
  , WORKER_SEARCH_PROPERTIES = "SEARCH_PROPERTIES"
  , WORKER_GET_OBJECT_TREE = "GET_OBJECT_TREE";
function SvfLoader(a) {
    this.viewer3DImpl = a;
    this.next_pack = 0;
    this.loading = !1;
    this.tmpMatrix = new THREE.Matrix4
}
SvfLoader.prototype.pathToURL = function(a) {
    if ("http://" == a.substr(0, 7) || "https://" == a.substr(0, 8) || "file:///" == a.substr(0, 8) || "urn:" == a.substr(0, 4))
        return a;
    var b = window.location.pathname
      , c = b.lastIndexOf("/")
      , b = b.substr(0, c + 1);
    return window.location.protocol + "//" + window.location.host + b + a
}
;
SvfLoader.prototype.loadSvf = function(a, b, c) {
    if (this.loading)
        return stderr("loading of SVF already in progress."),
        !1;
    if (ENABLE_INLINE_WORKER) {
        var e = new XMLHttpRequest;
        e.open("GET", RESOURCE_ROOT + LMV_WORKER_URL, !0);
        e.setRequestHeader("Access-Control-Allow-Credentials", !0);
        e.withCredentials = !0;
        var d = this;
        e.onload = function() {
            WORKER_SCRIPT = e.responseText;
            d.loadSvfCB(a, b, c)
        }
        ;
        e.send();
        return !0
    }
    return this.loadSvfCB(a, b, c)
}
;
SvfLoader.prototype.loadSvfCB = function(a, b, c) {
    this.t0 = (new Date).getTime();
    var e = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker()
      , d = this;
    e.addEventListener("message", function(b) {
        if (b.data && b.data.svf) {
            b = d.svf = b.data.svf;
            b.geomPolyCount = 0;
            b.instancePolyCount = 0;
            b.geomMemory = 0;
            b.fragments.numLoaded = 0;
            b.meshCount = 0;
            b.gpuNumMeshes = 0;
            b.gpuMeshMemory = 0;
            b.basePath = "";
            var g = a.lastIndexOf("/");
            -1 != g && (b.basePath = a.substr(0, g + 1));
            d.onSvfLoadDone(b);
            c && c.call(d);
            for (var g = Math.min(b.geompacks.length, 
            NUM_PARALLEL_DOWNLOADS), h = 0; h < g; h++) {
                var l = b.geompacks[h];
                d.loadGeometryPack(l.id, l.uri);
                d.next_pack = h + 1
            }
            d.loading = !1;
            e.terminate()
        } else
            b.data && b.data.progress || (b.data && b.data.error ? d.viewer3DImpl.raiseError(b.data.error.code, b.data.error.msg, b.data.error.args) : (stderr("SVF download failed."),
            d.loading = !1,
            e.terminate()))
    }
    , !1);
    var g = this.pathToURL(a);
    e.postMessage({
        operation: WORKER_LOAD_SVF,
        url: g,
        headers: {},
        objectIds: b,
        auth: auth,
        viewing_url: VIEWING_URL
    });
    return !0
}
;
SvfLoader.prototype.loadGeometryPack = function(a, b) {
    var c, e, d, g = this;
    if (USE_WORKER_POOL) {
        if (!this.pack_workers)
            for (this.pack_workers = [],
            e = 0; e < NUM_WORKER_THREADS; e++) {
                var f = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker();
                f.addEventListener("message", function(a) {
                    if (a.data && a.data.mesh) {
                        if (g.processReceivedMesh(a.data),
                        1 <= a.data.progress) {
                            --g.pack_workers[a.data.workerId].queued;
                            a = !0;
                            for (d = 0; d < g.pack_workers.length; d++)
                                0 != g.pack_workers[d].queued && (a = !1);
                            if (a) {
                                for (d = 0; d < 
                                NUM_WORKER_THREADS; d++)
                                    g.pack_workers[d].terminate();
                                g.pack_wokers = null 
                            }
                            g.svf.fragments.numLoaded == g.svf.fragments.length && (g.onGeomLoadDone(),
                            g.loadTextures())
                        }
                    } else
                        a.data && a.data.progress ? (--g.pack_workers[a.data.workerId].queued,
                        g.next_pack < g.svf.geompacks.length && (a = g.svf.geompacks[g.next_pack++],
                        g.loadGeometryPack(a.id, a.uri))) : a.data && a.data.error ? g.viewer3DImpl.raiseError(a.data.error.code, a.data.error.msg, a.data.error.args) : g.pack_workers[a.data.workerId].queued -= 2
                }
                , !1);
                f.queued = 0;
                this.pack_workers.push(f)
            }
        var f = 
        0
          , k = this.pack_workers[0].queued;
        for (e = 1; e < NUM_WORKER_THREADS; e++)
            this.pack_workers[e].queued < k && (f = e);
        c = this.pack_workers[f];
        c.queued += 2;
        e = f
    } else
        c = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker(),
        c.addEventListener("message", function(a) {
            a.data && a.data.mesh ? (g.processReceivedMesh(a.data),
            1 <= a.data.progress && (c.terminate(),
            g.svf.fragments.numLoaded == g.svf.fragments.length && (g.onGeomLoadDone(),
            g.loadTextures()))) : a.data && a.data.progress ? g.next_pack < g.svf.geompacks.length && 
            (a = g.svf.geompacks[g.next_pack++],
            g.loadGeometryPack(a.id, a.uri)) : a.data && a.data.error && g.viewer3DImpl.raiseError(a.data.error.code, a.data.error.msg, a.data.error.args)
        }
        , !1);
    f = this.pathToURL(this.svf.basePath + b);
    e = {
        operation: WORKER_LOAD_GEOMETRY,
        url: f,
        packId: parseInt(a),
        headers: {},
        workerId: e,
        auth: auth,
        viewing_url: VIEWING_URL
    };
    c.postMessage(e)
}
;
SvfLoader.prototype.convertMaterials = function() {
    var a = this.svf, b = a.materials.materials, c;
    for (c in b)
        if (b = a.simplemats[c]) {
            b.color = (new THREE.Color).copy(b.color);
            b.ambient = (new THREE.Color).copy(b.ambient);
            b.specular = (new THREE.Color).copy(b.specular);
            b.emissive = (new THREE.Color).copy(b.emissive);
            var e = new THREE.MeshPhongMaterial(b);
            e.metal = b.metal;
            !_isIE11 && (b.doubleSided || a.metadata && a.metadata.hasOwnProperty("double sided geometry") && a.metadata["double sided geometry"].value) && (e.side = THREE.DoubleSide);
            for (var d in b)
                0 == d.indexOf("uri_") && (e[d] = b[d]),
                0 == d.indexOf("uscale_") && (e[d] = b[d]),
                0 == d.indexOf("vscale_") && (e[d] = b[d]);
            this.viewer3DImpl.addMaterial(c, e)
        } else
            this.viewer3DImpl.addMaterial(c, new THREE.MeshPhongMaterial({
                ambient: 197379,
                color: 7829367,
                specular: 3355443,
                shininess: 30,
                shading: THREE.SmoothShading
            }))
}
;
SvfLoader.prototype.loadTextures = function() {
    var a = this.svf
      , b = this;
    b.textures = {};
    for (var c in b.viewer3DImpl.materials) {
        var e = b.viewer3DImpl.materials[c];
        if (e) {
            var d = function(a) {
                for (var c = b.textures[a.name], d = 0; d < c.mats.length; d++)
                    c.mats[d][c.slots[d]] = a;
                b.viewer3DImpl.addTexture(c)
            }
              , g = ["map", "bumpMap", "specularMap", "normalMap", "envMap"];
            e.bumpScale && 1 <= e.bumpScale && (e.bumpScale = .03);
            for (var f = 0; f < g.length; f++) {
                var k = e["uri_" + g[f]];
                if (k)
                    if (b.textures[k])
                        b.textures[k].mats.push(e),
                        b.textures[k].slots.push(g[f]);
                    else {
                        var h = "envMap" == g[f], l = b.pathToURL(a.basePath + k), m, n = e["uscale_" + g[f]], p = e["vscale_" + g[f]];
                        n || (n = 1);
                        p || (p = 1);
                        if (0 == l.indexOf("urn:") && (auth.oauth1 || auth.oauth2)) {
                            var t = function(a) {
                                viewer.fireEvent({
                                    type: ERROR_EVENT,
                                    code: METADATA.BaseViewer3D.ErrorCodes.NETWORK_FAILURE,
                                    message: a
                                })
                            }
                            ;
                            b.textures[k] = {
                                mats: [e],
                                slots: [g[f]],
                                tex: m
                            };
                            var l = VIEWING_URL + "/items/" + l
                              , v = auth.getAuthHeader("GET", l)
                              , r = new XMLHttpRequest;
                            r.open("GET", l, !0);
                            r.setRequestHeader("Authorization", v);
                            r.setRequestHeader("Access-Control-Allow-Origin", 
                            "*");
                            r.overrideMimeType("text/plain; charset=x-user-defined");
                            (function(a, c) {
                                r.onload = function(e) {
                                    r.status && 200 != r.status ? t("An unexpected status code was received while loading texture: " + r.status) : (e = new Image,
                                    e.src = "data:image/png;base64," + base64Encode(this.response),
                                    c = h ? new THREE.Texture(e,new THREE.SphericalReflectionMapping) : new THREE.Texture(e,new THREE.UVMapping),
                                    c.needsUpdate = !0,
                                    c.name = a,
                                    c.repeat.set(n, p),
                                    c.wrapS = THREE.RepeatWrapping,
                                    c.wrapT = THREE.RepeatWrapping,
                                    c.anisotropy = b.viewer3DImpl.renderer.getMaxAnisotropy(),
                                    c.flipY = !h,
                                    d(c))
                                }
                            }
                            )(k, m);
                            r.onerror = function(a) {
                                t("An error occurred while loading texture.")
                            }
                            ;
                            r.ontimeout = function(a) {
                                t("A timeout occurred while loading texture.")
                            }
                            ;
                            try {
                                r.send(null )
                            } catch (u) {
                                t("An exception occurred while loading the texture : " + u.toString())
                            }
                        } else
                            auth && auth.oauth0 && (l = VIEWING_URL + "/items/" + l + "?oauth_token=" + encodeURIComponent(auth.access_token)),
                            auth && auth.oauthNone && (THREE.ImageUtils.crossOrigin = "use-credentials",
                            l = VIEWING_URL + "/items/" + l),
                            m = h ? THREE.ImageUtils.loadTexture(l, new THREE.SphericalReflectionMapping, 
                            d) : THREE.ImageUtils.loadTexture(l, new THREE.UVMapping, d),
                            m.name = k,
                            b.textures[k] = {
                                mats: [e],
                                slots: [g[f]],
                                tex: m
                            },
                            m.repeat.set(n, p),
                            m.wrapS = THREE.RepeatWrapping,
                            m.wrapT = THREE.RepeatWrapping,
                            m.anisotropy = b.viewer3DImpl.renderer.getMaxAnisotropy(),
                            m.flipY = !h
                    }
            }
        }
    }
}
;
function base64Encode(a) {
    for (var b = "", c = 0, e = a.length, d, g, f; c < e; ) {
        d = a.charCodeAt(c++) & 255;
        if (c == e) {
            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(d >> 2);
            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((d & 3) << 4);
            b += "==";
            break
        }
        g = a.charCodeAt(c++);
        if (c == e) {
            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(d >> 2);
            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((d & 3) << 4 | (g & 240) >> 4);
            b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((g & 
            15) << 2);
            b += "=";
            break
        }
        f = a.charCodeAt(c++);
        b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(d >> 2);
        b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((d & 3) << 4 | (g & 240) >> 4);
        b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt((g & 15) << 2 | (f & 192) >> 6);
        b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(f & 63)
    }
    return b
}
function meshToGeometry(a) {
    var b = a.mesh
      , c = new THREE.BufferGeometry;
    a.byteSize = 0;
    if (b.vb) {
        c.vb = b.vb;
        c.vbstride = b.vbstride;
        for (var e in b.vblayout) {
            var d = b.vblayout[e];
            c.attributes[e] = {
                itemSize: d.itemSize,
                itemOffset: d.offset,
                isPattern: d.isPattern
            }
        }
        a.byteSize += b.vb.byteLength
    } else {
        c.attributes.position = {
            itemSize: 3,
            array: b.vertices
        };
        a.byteSize += b.vertices.byteLength;
        b.normals && (c.attributes.normal = {
            itemSize: 3,
            array: b.normals
        },
        a.byteSize += b.normals.byteLength);
        b.colors && (c.attributes.color = {
            itemSize: 3,
            array: b.colors
        },
        a.byteSize += b.colors.byteLength);
        if (b.uvs)
            for (e = 0; e < b.uvs.length; e++)
                d = "uv",
                e && (d += (e + 1).toString()),
                c.attributes[d] = {
                    itemSize: 2,
                    array: b.uvs[e].data,
                    isPattern: b.uvs[e].isPattern
                },
                a.byteSize += b.uvs[e].data.byteLength;
        a.mesh.isLines || b.normals.length || (stderr("Mesh without normals, consider computing them in loader thread"),
        c.computeVertexNormals())
    }
    c.attributes.index = {
        itemSize: 1,
        array: b.indices
    };
    a.byteSize += b.indices.byteLength;
    c.offsets.push({
        start: 0,
        index: 0,
        count: b.indices.length
    });
    c.freeCPUBuffers = !1;
    65535 < b.indices.length && stderr("Mesh with >65535 indices. May have to break up the draw calls.");
    c.boundingBox = (new THREE.Box3).copy(b.boundingBox);
    c.boundingSphere = (new THREE.Sphere).copy(b.boundingSphere);
    a.geometry = c;
    a.geometry.isLines = !0 === a.mesh.isLines;
    delete a.mesh
}
function getFragmentTransform(a, b, c) {
    c *= 16;
    b = b.transforms;
    for (var e = !0, d = 0; 16 > d; d++)
        if (d % 5 && 0 != b[c + d] || !(d % 5) && 1 != b[c + d]) {
            e = !1;
            break
        }
    if (e)
        return null ;
    for (e = 0; 16 > e; e++)
        a.elements[e] = b[c + e];
    return a
}
SvfLoader.prototype.processReceivedMesh = function(a) {
    meshToGeometry(a);
    var b = a.packId + ":" + a.meshIndex
      , c = this.svf
      , e = c.fragments
      , d = e.mesh2frag[b];
    if (void 0 === d)
        stderr("Mesh " + b + " was not referenced by any fragments.");
    else {
        c.meshCount++;
        var g = MAX_FRAGS_PER_GROUP;
        if (!a.geometry.isLines)
            if (67108864 > c.gpuMeshMemory && c.gpuNumMeshes < g)
                a.geometry.streamingDraw = !1,
                a.geometry.streamingIndex = !1;
            else if (134217728 < c.gpuMeshMemory || 2E3 < c.gpuNumMeshes)
                a.geometry.streamingDraw = !0,
                a.geometry.streamingIndex = !0;
            else {
                var f;
                Array.isArray(d) ? f = d.length * a.byteSize : 300 > (0 | d) ? (a.geometry.streamingDraw = !1,
                a.geometry.streamingIndex = !1) : f = a.byteSize;
                1E5 > f && (a.geometry.streamingDraw = !0,
                a.geometry.streamingIndex = !0)
            }
        a.geometry.streamingDraw || (c.gpuMeshMemory += a.byteSize,
        c.gpuNumMeshes += 1);
        if (Array.isArray(d))
            for (f = 0; f < d.length; f++) {
                var k = 0 | d[f]
                  , g = e.materials[k];
                this.viewer3DImpl.addMeshInstance(a.geometry, k, g, getFragmentTransform(this.tmpMatrix, e, k))
            }
        else
            f = getFragmentTransform(this.tmpMatrix, e, 0 | d),
            g = e.materials[d],
            this.viewer3DImpl.addMeshInstance(a.geometry, 
            0 | d, g, f);
        delete e.mesh2frag[b];
        b = a.geometry.attributes.index.array.length / 3;
        c.geomPolyCount += b;
        c.instancePolyCount += b * (d.length || 1);
        c.geomMemory += a.byteSize;
        a = !e.numLoaded;
        e.numLoaded += d.length || 1;
        d = e.numLoaded;
        e = e.length;
        c = d / e;
        b = 0 | e / d;
        if (a || 0 == (b & b - 1) && this.lastRepaintFract != b)
            this.lastRepaintFract = b,
            this.viewer3DImpl.needsRender = !0;
        1 > c && 0 == d % 10 && this.viewer3DImpl.signalProgress(100 * c, "fragment " + d + " / " + e)
    }
}
;
SvfLoader.prototype.onSvfLoadDone = function(a) {
    var b = (new Date).getTime();
    stderr("SVF load: " + (b - this.t0));
    this.viewer3DImpl.signalProgress(5, "Hold on, getting the model...");
    this.t0 = b;
    this.convertMaterials();
    this.viewer3DImpl.initScene(a)
}
;
SvfLoader.prototype.onGeomLoadDone = function() {
    this.svf.loadDone = !0;
    delete this.svf.fragments.entityIndexes;
    delete this.svf.fragments.packIds;
    var a = "Fragments load time: " + ((new Date).getTime() - this.t0);
    this.viewer3DImpl.signalProgress(100, a);
    this.viewer3DImpl.api.fireEvent({
        type: GEOMETRY_LOADED_EVENT
    });
    stderr(a);
    stderr("Total geometry size: " + this.svf.geomMemory / 1048576 + " MB");
    stderr("Number of meshes: " + this.svf.meshCount);
    stderr("Num Meshes on GPU: " + this.svf.gpuNumMeshes);
    stderr("Net GPU geom memory used: " + 
    this.svf.gpuMeshMemory);
    this.viewer3DImpl.needsRender = !0
}
;
SvfLoader.prototype.getProperties = function(a, b) {
    this.propWorker || (this.propWorker = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker());
    var c = this
      , e = function(a) {
        a.data && a.data.error ? c.viewer3DImpl.raiseError(a.data.error.code, a.data.error.msg, a.data.error.args) : (b(a.data),
        c.propWorker.removeEventListener("message", e))
    }
    ;
    this.propWorker.addEventListener("message", e, !1);
    var d = this.pathToURL(this.svf.basePath);
    this.propWorker.postMessage({
        operation: WORKER_GET_PROPERTIES,
        url: d,
        dbId: a,
        headers: {},
        auth: auth,
        viewing_url: VIEWING_URL
    })
}
;
SvfLoader.prototype.searchProperties = function(a, b) {
    var c = this;
    if (USE_SERVER_SIDE_SEARCH) {
        this.searchWorker || (this.searchWorker = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker());
        var e = function(a) {
            a.data && a.data.error ? c.viewer3DImpl.raiseError(a.data.error.code, a.data.error.msg, a.data.error.args) : (a = JSON.parse(a.data),
            "debug" == a.type ? stderr(a.debug) : "response" == a.type && (b(a.response),
            c.searchWorker.removeEventListener("message", e)))
        }
        ;
        this.searchWorker.addEventListener("message", 
        e, !1);
        this.searchWorker.postMessage({
            operation: WORKER_SEARCH,
            keyword: a,
            url: this.pathToURL(this.svf.basePath),
            id: this.svf.manifest.adskID
        })
    } else {
        this.propWorker || (this.propWorker = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker());
        e = function(a) {
            a.data && a.data.error ? c.viewer3DImpl.raiseError(a.data.error.code, a.data.error.msg, a.data.error.args) : (b(a.data),
            c.propWorker.removeEventListener("message", e))
        }
        ;
        this.propWorker.addEventListener("message", e, !1);
        var d = this.pathToURL(this.svf.basePath);
        this.propWorker.postMessage({
            operation: WORKER_SEARCH_PROPERTIES,
            url: d,
            headers: {},
            searchText: a
        })
    }
}
;
SvfLoader.prototype.createFragToNodeMapping = function() {
    var a = this.svf
      , b = a.fragments.fragId2dbId;
    if (a.instanceTree && b) {
        var c = a.fragments.fragToDbNode = Array(b.length);
        (function d(a) {
            var b = a.fragIds;
            if (void 0 !== b)
                if (Array.isArray(b))
                    for (var k = 0; k < b.length; k++)
                        c[b[k]] = a;
                else
                    c[b] = a;
            if (a.children)
                for (b = 0; b < a.children.length; b++)
                    d(a.children[b])
        }
        )(a.instanceTree)
    }
}
;
SvfLoader.prototype.getObjectTree = function(a) {
    var b = this
      , c = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker();
    c.addEventListener("message", function(d) {
        if (!d.data || !d.data.error) {
            var e = d.data.instanceTree
              , f = d.data.instanceBoxes;
            e && (b.svf.instanceTree = e,
            b.svf.maxTreeDepth = d.data.maxTreeDepth,
            b.createFragToNodeMapping(),
            a(e));
            f && (b.svf.instanceBoxes = f,
            c.terminate())
        }
    }
    , !1);
    var e = this.pathToURL(this.svf.basePath);
    c.postMessage({
        operation: WORKER_GET_OBJECT_TREE,
        url: e,
        headers: {},
        fragToDbId: this.svf.fragments.fragId2dbId,
        fragBoxes: this.svf.fragments.boxes,
        auth: auth,
        viewing_url: VIEWING_URL
    })
}
;
SvfLoader.prototype.testSearchQuery = function() {
    stderr("debug : test search query...");
    try {
        var a = this
          , b = ENABLE_DEBUG || !ENABLE_INLINE_WORKER ? new Worker(LMV_WORKER_URL) : createWorker();
        b.addEventListener("message", function(b) {
            b.data && b.data.error ? a.viewer3DImpl.raiseError(b.data.error.code, b.data.error.msg, b.data.error.args) : (b = JSON.parse(b.data),
            "debug" == b.type ? stderr(b.debug) : "response" == b.type && stderr(JSON.stringify(b.response)))
        }
        , !1);
        b.postMessage({
            operation: WORKER_SEARCH,
            keyword: "walkway",
            url: this.pathToURL(this.svf.basePath)
        })
    } catch (c) {
        stderr("exception : " + 
        c.message)
    }
}
;
function createWorker() {
    var a;
    window.BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
    window.URL = window.URL || window.webkitURL;
    try {
        a = new Blob([WORKER_SCRIPT],{
            type: "application/javascript"
        })
    } catch (b) {
        a = new BlobBuilder,
        a.append(WORKER_SCRIPT),
        a = a.getBlob()
    }
    return new Worker(URL.createObjectURL(a))
}
;var Stats = function() {
    var a = Date.now()
      , b = a
      , c = 0
      , e = Infinity
      , d = 0
      , g = 0
      , f = Infinity
      , k = 0
      , h = 0
      , l = 0
      , m = document.createElement("div");
    m.id = "stats";
    m.addEventListener("mousedown", function(a) {
        a.preventDefault();
        x(++l % 2)
    }
    , !1);
    m.style.cssText = "width:80px;opacity:0.9;cursor:pointer";
    var n = document.createElement("div");
    n.id = "fps";
    n.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#002";
    m.appendChild(n);
    var p = document.createElement("div");
    p.id = "fpsText";
    p.style.cssText = "color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    p.innerHTML = "FPS";
    n.appendChild(p);
    var t = document.createElement("div");
    t.id = "fpsGraph";
    t.style.cssText = "position:relative;width:74px;height:30px;background-color:#0ff";
    for (n.appendChild(t); 74 > t.children.length; ) {
        var v = document.createElement("span");
        v.style.cssText = "width:1px;height:30px;float:left;background-color:#113";
        t.appendChild(v)
    }
    var r = document.createElement("div");
    r.id = "ms";
    r.style.cssText = "padding:0 0 3px 3px;text-align:left;background-color:#020;display:none";
    m.appendChild(r);
    var u = document.createElement("div");
    u.id = "msText";
    u.style.cssText = "color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px";
    u.innerHTML = "MS";
    r.appendChild(u);
    var w = document.createElement("div");
    w.id = "msGraph";
    w.style.cssText = "position:relative;width:74px;height:30px;background-color:#0f0";
    for (r.appendChild(w); 74 > w.children.length; )
        v = document.createElement("span"),
        v.style.cssText = "width:1px;height:30px;float:left;background-color:#131",
        w.appendChild(v);
    var x = function(a) {
        l = a;
        switch (l) {
        case 0:
            n.style.display = 
            "block";
            r.style.display = "none";
            break;
        case 1:
            n.style.display = "none",
            r.style.display = "block"
        }
    }
    ;
    return {
        REVISION: 11,
        domElement: m,
        setMode: x,
        begin: function() {
            a = Date.now()
        },
        end: function() {
            var l = Date.now();
            c = l - a;
            e = Math.min(e, c);
            d = Math.max(d, c);
            u.textContent = c + " MS (" + e + "-" + d + ")";
            var m = Math.min(30, 30 - c / 200 * 30);
            w.appendChild(w.firstChild).style.height = m + "px";
            h++;
            l > b + 2E3 && (g = Math.round(1E3 * h / (l - b)),
            f = Math.min(f, g),
            k = Math.max(k, g),
            p.textContent = g + " FPS (" + f + "-" + k + ")",
            m = Math.min(30, 30 - g / 100 * 30),
            t.appendChild(t.firstChild).style.height = 
            m + "px",
            b = l,
            h = 0,
            e = Infinity,
            d = 0);
            return l
        },
        update: function() {
            a = this.end()
        }
    }
}
;
var MAX_FRAGS_PER_GROUP = 333;
function RenderQueue(a, b) {
    this.currentScene = 0;
    this.vizmeshes = Array(a.length);
    this.vizflags = new Uint8Array(a.length);
    this.prototypeScene = b;
    this.drawMode = RenderQueue.NORMAL;
    var c = 0 | (a.length + MAX_FRAGS_PER_GROUP - 1) / MAX_FRAGS_PER_GROUP;
    this.geomScenes = Array(c);
    for (var e = 0; e < c; e++)
        (this.geomScenes[e] = new THREE.Scene(!0)).__lights = b.__lights;
    this.boundingboxes = a.boxes;
    this.allVisible = !0;
    this.allVisibleDirty = !1
}
RenderQueue.NORMAL = 0;
RenderQueue.HIGHLIGHTED = 1;
RenderQueue.HIDDEN = 2;
RenderQueue.MESH_VISIBLE = 1;
RenderQueue.MESH_HIGHLIGHTED = 2;
RenderQueue.prototype.addMesh = function(a, b) {
    var c = this.vizmeshes[a];
    c && (stderr("duplicate fragment."),
    c.parent.remove(c));
    this.vizmeshes[a] = b;
    this.vizflags[a] = 1;
    b.fragId = a;
    var c = 0 | a / MAX_FRAGS_PER_GROUP
      , e = this.geomScenes[c];
    e || (this.geomScenes[c] = e = new THREE.Scene(!0),
    e.__lights = this.prototypeScene.__lights);
    e.add(b)
}
;
RenderQueue.prototype.renderSome = function(a, b) {
    var c, e, d = this.vizflags, g = Date.now(), f = !0;
    c = this.currentScene;
    for (e = this.geomScenes.length; c < e; c++) {
        var k = this.geomScenes[c];
        if (f) {
            if (0 >= b)
                break;
            f = !1
        } else if (b <= .5 * k.avgFrameTime)
            break;
        var h = k.children;
        if (this.drawMode == RenderQueue.HIDDEN)
            for (var l = 0, m = h.length; l < m; l++) {
                var n = h[l];
                n.visible = !(d[n.fragId] & 1)
            }
        else if (this.drawMode == RenderQueue.HIGHLIGHTED)
            for (l = 0,
            m = h.length; l < m; l++)
                n = h[l],
                n.visible = !!(d[n.fragId] & 2);
        else
            for (l = 0,
            m = h.length; l < m; l++)
                n = h[l],
                n.visible = 1 == d[n.fragId];
        a(k);
        h = Date.now();
        l = h - g;
        g = h;
        k.avgFrameTime = void 0 === k.avgFrameTime ? l : .8 * k.avgFrameTime + .2 * l;
        this.currentScene = c + 1;
        b -= k.avgFrameTime
    }
    return b
}
;
RenderQueue.prototype.isDone = function() {
    return this.currentScene == this.geomScenes.length
}
;
RenderQueue.prototype.reset = function(a) {
    this.camera = a;
    this.currentScene = 0
}
;
RenderQueue.prototype.drawNormalObjectsOnly = function() {
    this.drawMode = RenderQueue.NORMAL
}
;
RenderQueue.prototype.drawHighlightedObjectsOnly = function() {
    this.drawMode = RenderQueue.HIGHLIGHTED
}
;
RenderQueue.prototype.drawHiddenObjectsOnly = function() {
    this.drawMode = RenderQueue.HIDDEN
}
;
RenderQueue.prototype.setOverrideMaterial = function(a) {
    for (var b = 0, c = this.geomScenes.length; b < c; b++)
        this.geomScenes[b].overrideMaterial = a
}
;
RenderQueue.prototype.toggleHightlighted = function(a, b) {
    var c = this.vizflags[a];
    this.vizflags[a] = b ? c | 2 : c & -3
}
;
RenderQueue.prototype.toggleAllHighlighted = function(a) {
    var b = this.vizflags;
    if (a) {
        a = 0;
        for (var c = b.length; a < c; a++)
            b[a] |= 2
    } else
        for (a = 0,
        c = b.length; a < c; a++)
            b[a] &= -3
}
;
RenderQueue.prototype.setVisibility = function(a, b) {
    this.vizflags[a] = b ? this.vizflags[a] | 1 : this.vizflags[a] & -2;
    this.allVisibleDirty = !0
}
;
RenderQueue.prototype.setAllVisibility = function(a) {
    var b = this.vizflags;
    if (a)
        for (var c = 0, e = b.length; c < e; c++)
            b[c] |= 1;
    else
        for (c = 0,
        e = b.length; c < e; c++)
            b[c] &= -2;
    this.allVisible = a;
    this.allVisibleDirty = !1
}
;
RenderQueue.prototype.isFragVisible = function(a) {
    return 0 != (this.vizflags[a] & 1)
}
;
RenderQueue.prototype.areAllVisible = function() {
    if (this.allVisibleDirty) {
        this.allVisible = !0;
        this.allVisibleDirty = !1;
        for (var a = this.vizflags, b = 0, c = a.length; b < c; b++)
            if (0 == (a[b] & 1)) {
                this.allVisible = !1;
                break
            }
    }
    return this.allVisible
}
;
RenderQueue.prototype.getVisibleBounds = function() {
    for (var a = new THREE.Box3, b = new THREE.Vector3, c = new THREE.Vector3, e = new THREE.Box3, d = this.boundingboxes, g = this.vizflags, f = 0, k = g.length; f < k; f++)
        if (g[f] & 1) {
            var h = 6 * f;
            b.x = d[h];
            b.y = d[h + 1];
            b.z = d[h + 2];
            c.x = d[h + 3];
            c.y = d[h + 4];
            c.z = d[h + 5];
            e.set(b, c);
            a.union(e)
        }
    return a
}
;
function RenderContext() {
    var a, b, c, e, d, g, f, k, h, l, m, n, p = null , t = null , v = null , r = null , u = null , w, x, A = {
        r: 0,
        g: 0,
        b: 0
    }, y = {
        antialias: !0,
        sao: !1,
        useHdrTarget: !1,
        haveTwoSided: !1
    };
    this.settings = y;
    this.init = function(a, c, d) {
        b = a;
        w = c;
        x = d;
        this.initPostPipeline(!1)
    }
    ;
    this.beginScene = function(b, c, g) {
        e = c;
        g && (a.setClearColor(A, 0),
        a.clearTarget(t, !1, !0, !1),
        d.render(a, t, null ));
        a.render(b, c, t, !1);
        y.sao && (g && (a.setClearColor(A, 0),
        a.clearTarget(n, !0, !1, !1)),
        a.render(b, c, n, !1),
        f.uniforms.cameraNear.value = c.near,
        f.uniforms.cameraFar.value = 
        c.far,
        h.uniforms.cameraNear.value = c.near,
        h.uniforms.cameraInvNearFar.value = 1 / (c.near - c.far),
        b = c.projectionMatrix.elements,
        f.uniforms.projInfo.value.set(-2 / (t.width * b[0]), -2 / (t.height * b[5]), (1 - b[8]) / b[0], (1 - b[9]) / b[5]),
        f.uniforms.projScale.value = .125 * t.height * b[5])
    }
    ;
    this.renderScenePart = function(b, d) {
        if (this.hasMRT())
            y.sao ? a.render(b, e, [t, n]) : a.render(b, e, t);
        else if (a.render(b, e, t),
        y.sao && !d) {
            var f = b.overrideMaterial;
            b.overrideMaterial = c;
            a.render(b, e, n);
            b.overrideMaterial = f
        }
    }
    ;
    this.clearAllOverlays = 
    function() {
        a.clearTarget(v, !0, !1, !1)
    }
    ;
    this.renderOverlays = function(b) {
        var c = 0, d;
        for (d in b)
            if (b.hasOwnProperty(d)) {
                var f = b[d]
                  , g = f.scene;
                g.children.length && (c || (c = 1,
                a.setClearColor(A, 0),
                a.clearTarget(v, !0, !1, !1)),
                f.materialPre && (g.overrideMaterial = f.materialPre,
                a.render(g, e, v, !1)),
                f.materialPost && (g.overrideMaterial = f.materialPost,
                a.context.depthFunc(a.context.GREATER),
                a.render(g, e, v, !1),
                a.context.depthFunc(a.context.LEQUAL)),
                g.overrideMaterial = null )
            }
        m.uniforms.useOverlay.value = c
    }
    ;
    this.composeFinalFrame = 
    function(b) {
        if (!b && y.sao) {
            if (p) {
                b = p[0];
                h.uniforms.resolution.value.set(1 / b.width, 1 / b.height);
                h.render(a, b, n);
                for (var c = 1; c < p.length; c++) {
                    var d = p[c];
                    k.uniforms.resolution.value.set(1 / d.width, 1 / d.height);
                    k.render(a, d, b);
                    b = d
                }
            }
            f.render(a, r, t);
            g.uniforms.axis.value.set(1, 0);
            g.render(a, u, r);
            g.uniforms.axis.value.set(0, 1);
            g.render(a, r, u)
        }
        l ? (m.render(a, u, t),
        l.render(a, null , u)) : m.render(a, null , t);
        a.endFrame()
    }
    ;
    this.setSize = function(b, c, d) {
        w = b;
        x = c;
        a.setSize(b, c);
        b = 0 | b * a.devicePixelRatio;
        c = 0 | c * a.devicePixelRatio;
        if (d || !t || t.width != b || t.height != c)
            t = new THREE.WebGLRenderTarget(b,c,{
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBFormat,
                type: y.useHdrTarget ? THREE.FloatType : THREE.UnsignedByteType,
                stencilBuffer: !1
            }),
            v = new THREE.WebGLRenderTarget(b,c,{
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: !1
            }),
            v.shareDepthFrom = t;
        if (y.sao && (d || !n || n.width != b || n.height != c)) {
            n = new THREE.WebGLRenderTarget(b,c,{
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBFormat,
                type: THREE.FloatType,
                stencilBuffer: !1
            });
            n.shareDepthFrom = t;
            p = [];
            for (d = 0; 5 > d; d++) {
                var e = new THREE.WebGLRenderTarget(0 | b / (2 << d),0 | c / (2 << d),{
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat,
                    depthBuffer: !1,
                    stencilBuffer: !1
                });
                p.push(e);
                f.uniforms["tDepth_mip" + (d + 1)].value = e
            }
            r = new THREE.WebGLRenderTarget(b,c,{
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer: !1,
                depthBuffer: !1
            });
            u = r.clone()
        }
        f && (f.uniforms.size.value.set(b, 
        c),
        f.uniforms.tDepth.value = n,
        g.uniforms.size.value.set(b, c),
        g.uniforms.resolution.value.set(1 / b, 1 / c));
        l && l.uniforms.resolution.value.set(1 / b, 1 / c);
        m.uniforms.tOverlay.value = v;
        m.uniforms.tAO.value = r;
        m.uniforms.useAO.value = y.sao ? 1 : 0;
        m.uniforms.resolution.value.set(1 / b, 1 / c)
    }
    ;
    this.getMaxAnisotropy = function() {
        return a.getMaxAnisotropy()
    }
    ;
    this.hasMRT = function() {
        return a.supportsMRT()
    }
    ;
    this.initPostPipeline = function(e, p) {
        function r(a) {
            a.blending = THREE.NoBlending;
            a.depthWrite = !1;
            a.depthTest = !1
        }
        y.sao = e && !_isIE11;
        y.antialias = p && !_isIE11;
        if (!a) {
            var u = window.devicePixelRatio;
            u || (u = 1);
            a = new FireflyWebGLRenderer({
                canvas: b,
                antialias: !1,
                alpha: !1,
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !1,
                stencil: !1,
                depth: !1,
                devicePixelRatio: u
            });
            a.autoClear = !1;
            a.sortObjects = !1
        }
        y.sao && !f && (u = NormalsShader,
        c = new THREE.ShaderMaterial({
            fragmentShader: u.fragmentShader,
            vertexShader: u.vertexShader,
            uniforms: THREE.UniformsUtils.clone(u.uniforms)
        }),
        c.blending = THREE.NoBlending,
        y.haveTwoSided && (c.side = THREE.DoubleSide),
        f = new THREE.ShaderPass(SAOShader),
        r(f.material),
        g = new THREE.ShaderPass(SAOBlurShader),
        r(g.material),
        h = new THREE.ShaderPass(SAOMinifyFirstShader),
        r(h.material),
        k = new THREE.ShaderPass(SAOMinifyShader),
        r(k.material));
        y.antialias ? l || (l = new THREE.ShaderPass(FXAAShader),
        r(l.material)) : l = null ;
        m || (m = new THREE.ShaderPass(BlendShader),
        r(m.material));
        d || (d = new THREE.ShaderPass(BackgroundShader),
        r(d.material));
        this.setSize(w, x);
        a.supportsMRT() && y.sao && a.verifyMRTWorks([t, n])
    }
    ;
    this.setClearColors = function(a, b) {
        d.uniforms.color2.value.copy(a);
        b ? d.uniforms.color1.value.copy(b) : d.uniforms.color1.value.set(0, 0, 0, 1)
    }
    ;
    this.setAOOptions = function(a, b) {
        f && (f.uniforms.radius.value = .1 * a,
        f.uniforms.intensity.value = .01 * b)
    }
    ;
    this.setGamma = function(a) {
        m && (m.uniforms.gamma.value = 1 / a)
    }
    ;
    this.setExposureBias = function(a) {
        m && (m.uniforms.exposureBias.value = Math.pow(2, a))
    }
    ;
    this.setWhiteScale = function(a) {
        m && (m.uniforms.whiteScale.value = a)
    }
    ;
    this.setTonemapMethod = function(b) {
        m && (0 == b ? (y.useHdrTarget && (y.useHdrTarget = !1,
        this.setSize(w, x, !0)),
        a.gammaInput = !1) : (y.useHdrTarget || 
        (y.useHdrTarget = !0,
        this.setSize(w, x, !0)),
        a.gammaInput = !0),
        m.uniforms.toneMapMethod.value = b)
    }
    ;
    this.toggleTwoSided = function(a) {
        y.haveTwoSided != a && c && (c.side = a ? THREE.DoubleSide : THREE.FrontSide,
        c.needsUpdate = !0);
        y.haveTwoSided = a
    }
}
;FXAAShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null 
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 1024,1 / 512)
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\n#define FXAA_SPAN_MAX     8.0\n#define FXAA_EDGE_THRESHOLD_MIN (1.0/24.0)\n#define FXAA_EDGE_THRESHOLD (1.0/8.0)\n#define FXAA_SEARCH_THRESHOLD (1.0/4.0)\n#define FXAA_SEARCH_STEPS 24\n#define FXAA_SUBPIX_TRIM (1.0/4.0)\n#define FXAA_SUBPIX_TRIM_SCALE (1.0/(1.0 - FXAA_SUBPIX_TRIM))\n#define FXAA_SUBPIX_CAP (3.0/4.0)\nvec4 getColor(sampler2D tex, vec2 uv) {\nvec4 c = texture2D(tex, uv);\nreturn c;\n}\nfloat FxaaLuma(vec3 rgb) {\nreturn rgb.y * (0.587/0.299) + rgb.x; }\nvec4 FxaaFilterReturn(vec4 rgba) {\nreturn rgba;}\nvec3 FxaaLerp3(vec3 a, vec3 b, float amountOfA) {\nreturn (vec3(-amountOfA) * b) +\n((a * vec3(amountOfA)) + b); }\nvec4 FxaaTex(sampler2D tex, vec2 pos) {\nreturn getColor(tex, pos.xy);}\nvec4 FxaaTexOff(sampler2D tex, vec2 pos, vec2 offset, vec2 resolution) {\nvec2 uv = pos.xy + offset * resolution;\nreturn getColor(tex, uv);}\nvoid main() {\nvec3 rgbN = FxaaTexOff( tDiffuse, vUv, vec2(0.0,-1.0), resolution ).xyz;\nvec3 rgbE = FxaaTexOff( tDiffuse, vUv, vec2(1.0, 0.0), resolution ).xyz;\nvec3 rgbW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,0.0), resolution ).xyz;\nvec3 rgbS = FxaaTexOff( tDiffuse, vUv, vec2(0.0, 1.0), resolution ).xyz;\nvec4 rgbaM = FxaaTex( tDiffuse, vUv);\nvec3 rgbM  = rgbaM.xyz;\nfloat lumaN = FxaaLuma(rgbN);\nfloat lumaE = FxaaLuma(rgbE);\nfloat lumaW = FxaaLuma(rgbW);\nfloat lumaS = FxaaLuma(rgbS);\nfloat lumaM = FxaaLuma(rgbM);\nfloat rangeMin = min(lumaM, min(min(lumaN, lumaW), min(lumaS, lumaE)));\nfloat rangeMax = max(lumaM, max(max(lumaN, lumaW), max(lumaS, lumaE)));\nfloat range = rangeMax - rangeMin;\nif(range < max(FXAA_EDGE_THRESHOLD_MIN, rangeMax * FXAA_EDGE_THRESHOLD)) {\ngl_FragColor = FxaaFilterReturn(rgbaM); return;}\nvec3 rgbL = rgbN + rgbW + rgbM + rgbE + rgbS;\nfloat lumaL = (lumaN + lumaW + lumaE + lumaS) * 0.25;\nfloat rangeL = abs(lumaL - lumaM);\nfloat blendL = max(0.0, (rangeL / range) - FXAA_SUBPIX_TRIM) * FXAA_SUBPIX_TRIM_SCALE;\nblendL = min(FXAA_SUBPIX_CAP, blendL);\nvec3 rgbNW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,-1.0), resolution ).xyz;\nvec3 rgbNE = FxaaTexOff( tDiffuse, vUv, vec2(1.0,-1.0), resolution ).xyz;\nvec3 rgbSW = FxaaTexOff( tDiffuse, vUv, vec2(-1.0,1.0), resolution ).xyz;\nvec3 rgbSE = FxaaTexOff( tDiffuse, vUv, vec2(1.0,1.0), resolution ).xyz;\nfloat opacity  = rgbaM.w;\nrgbL += (rgbNW + rgbNE + rgbSW + rgbSE);\nrgbL *= vec3(1.0/9.0);\nfloat lumaNW = FxaaLuma( rgbNW);\nfloat lumaNE = FxaaLuma( rgbNE);\nfloat lumaSW = FxaaLuma( rgbSW);\nfloat lumaSE = FxaaLuma( rgbSE);\nfloat edgeVert = abs((0.25 * lumaNW) + (-0.5 * lumaN) + (0.25 * lumaNE)) +\nabs((0.50 * lumaW ) + (-1.0 * lumaM) + (0.50 * lumaE )) +\nabs((0.25 * lumaSW) + (-0.5 * lumaS) + (0.25 * lumaSE));\nfloat edgeHorz = abs((0.25 * lumaNW) + (-0.5 * lumaW) + (0.25 * lumaSW)) +\nabs((0.50 * lumaN ) + (-1.0 * lumaM) + (0.50 * lumaS )) +\nabs((0.25 * lumaNE) + (-0.5 * lumaE) + (0.25 * lumaSE));\nbool horzSpan = edgeHorz >= edgeVert;\nfloat lengthSign = horzSpan ? -resolution.y : -resolution.x;\nif(!horzSpan) lumaN = lumaW;\nif(!horzSpan) lumaS = lumaE;\nfloat gradientN = abs(lumaN - lumaM);\nfloat gradientS = abs(lumaS - lumaM);\nlumaN = (lumaN + lumaM) * 0.5;\nlumaS = (lumaS + lumaM) * 0.5;\nbool pairN = gradientN >= gradientS;\nif(!pairN) lumaN = lumaS;\nif(!pairN) gradientN = gradientS;\nif(!pairN) lengthSign *= -1.0;\nvec2 posN;\nposN.x = vUv.x + (horzSpan ? 0.0 : lengthSign * 0.5);\nposN.y = vUv.y + (horzSpan ? lengthSign * 0.5 : 0.0);\ngradientN *= FXAA_SEARCH_THRESHOLD;\nvec2 posP = posN;\nvec2 offNP = horzSpan ? vec2(resolution.x, 0.0) : vec2(0.0, resolution.y);\nfloat lumaEndN = lumaN;\nfloat lumaEndP = lumaN;\nbool doneN = false;\nbool doneP = false;\nposN += offNP * vec2(-1.0, -1.0);\nposP += offNP * vec2( 1.0,  1.0);\nfor(int i = 0; i < FXAA_SEARCH_STEPS; i++) {\nif(!doneN) lumaEndN = FxaaLuma(FxaaTex( tDiffuse, posN.xy).xyz);\nif(!doneP) lumaEndP = FxaaLuma(FxaaTex( tDiffuse, posP.xy).xyz);\ndoneN = doneN || (abs(lumaEndN - lumaN) >= gradientN);\ndoneP = doneP || (abs(lumaEndP - lumaN) >= gradientN);\nif(doneN && doneP) break;\nif(!doneN) posN -= offNP;\nif(!doneP) posP += offNP; }\nfloat dstN = horzSpan ? vUv.x - posN.x : vUv.y - posN.y;\nfloat dstP = horzSpan ? posP.x - vUv.x : posP.y - vUv.y;\nbool directionN = dstN < dstP;\nlumaEndN = directionN ? lumaEndN : lumaEndP;\nif(((lumaM - lumaN) < 0.0) == ((lumaEndN - lumaN) < 0.0))\nlengthSign = 0.0;\nfloat spanLength = (dstP + dstN);\ndstN = directionN ? dstN : dstP;\nfloat subPixelOffset = (0.5 + (dstN * (-1.0/spanLength))) * lengthSign;\nvec3 rgbF = FxaaTex(tDiffuse, vec2(\nvUv.x + (horzSpan ? 0.0 : subPixelOffset),\nvUv.y + (horzSpan ? subPixelOffset : 0.0))).xyz;\ngl_FragColor = FxaaFilterReturn(vec4(FxaaLerp3(rgbL, rgbF, blendL), opacity));\n}"
};
BlendShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null 
        },
        tAO: {
            type: "t",
            value: null 
        },
        useAO: {
            type: "i",
            value: 0
        },
        tOverlay: {
            type: "t",
            value: null 
        },
        useOverlay: {
            type: "i",
            value: 0
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 1024,1 / 512)
        },
        gamma: {
            type: "f",
            value: 1
        },
        whiteScale: {
            type: "f",
            value: 1
        },
        exposureBias: {
            type: "f",
            value: 1
        },
        toneMapMethod: {
            type: "i",
            value: 0
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D tDiffuse;\nuniform sampler2D tAO;\nuniform int useAO;\nuniform sampler2D tOverlay;\nuniform int useOverlay;\nuniform vec2 resolution;\nuniform float whiteScale;\nuniform float gamma;\nuniform float exposureBias;\nuniform int toneMapMethod;\nvarying vec2 vUv;\nfloat exposure = log(1.0 - 0.6) / (whiteScale * 0.5);\nvec4 fetchOverlayTexel(vec2 uv, vec2 offset) {\nreturn texture2D(tOverlay, uv + resolution * offset);\n}\nfloat luminance_post(vec3 rgb) {\nreturn dot(rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luminance_pre(vec3 rgb) {\nreturn dot(rgb, vec3(0.212671, 0.715160, 0.072169));\n}\nvec3 xyz2rgb(vec3 xyz) {\nvec3 R = vec3( 3.240479, -1.537150, -0.498535);\nvec3 G = vec3(-0.969256,  1.875992,  0.041556);\nvec3 B = vec3( 0.055648, -0.204043,  1.057311);\nvec3 rgb;\nrgb.b = dot(xyz, B);\nrgb.g = dot(xyz, G);\nrgb.r = dot(xyz, R);\nreturn rgb;\n}\nvec3 rgb2xyz(vec3 rgb) {\nvec3 X = vec3(0.412453, 0.35758, 0.180423);\nvec3 Y = vec3(0.212671, 0.71516, 0.0721688);\nvec3 Z = vec3(0.0193338, 0.119194, 0.950227);\nvec3 xyz;\nxyz.x = dot(rgb, X);\nxyz.y = dot(rgb, Y);\nxyz.z = dot(rgb, Z);\nreturn xyz;\n}\nvec3 xyz2xyY(vec3 xyz) {\nfloat sum = xyz.x + xyz.y + xyz.z;\nsum = 1.0 / sum;\nvec3 xyY;\nxyY.z = xyz.y;\nxyY.x = xyz.x * sum;\nxyY.y = xyz.y * sum;\nreturn xyY;\n}\nvec3 xyY2xyz(vec3 xyY) {\nfloat x = xyY.x;\nfloat y = xyY.y;\nfloat Y = xyY.z;\nvec3 xyz;\nxyz.y = Y;\nxyz.x = x * (Y / y);\nxyz.z = (1.0 - x - y) * (Y / y);\nreturn xyz;\n}\nvec3 toneMapUncharted2(vec3 x)\n{\nfloat A = 0.22;\nfloat B = 0.30;\nfloat C = 0.10;\nfloat D = 0.20;\nfloat E = 0.01;\nfloat F = 0.30;\nreturn ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMapReinhard(vec3 rgb, float scale, float Lmax) {\nfloat L = luminance_pre(rgb);\nfloat sL = L * scale;\nfloat tmL = scale * (1.0 + sL / (Lmax * Lmax))/ (1.0 + sL);\nrgb *= tmL;\nreturn rgb;\n}\nvec3 toneMapReinhardYxy(vec3 rgb, float scale, float Lmax) {\nvec3 xyY = xyz2xyY(rgb2xyz(rgb));\nfloat L = xyY.z;\nfloat sL = L * scale;\nfloat tmL = scale * (1.0 + sL / (Lmax * Lmax))/ (1.0 + sL);\nxyY.z *= tmL;\nreturn xyz2rgb(xyY2xyz(xyY));\n}\nvec3 toneMapExpRgb(vec3 rgb) {\nrgb = vec3(1.0) - vec3(exp(rgb * vec3(exposure)));\nreturn rgb;\n}\nfloat TonemapMin = -2.152529302052785809;\nfloat TonemapMax = 1.163792197947214113;\nvec3 log10(vec3 x) { return log(x) * (1.0 / log(10.0));}\nfloat toneMapCanon(float x) {\nfloat x2 = x  * x;\nfloat x3 = x  * x2;\nfloat x4 = x2 * x2;\nfloat x5 = x2 * x3;\nfloat x6 = x3 * x3;\nvec3 coeff1 = vec3( 23.921, -70.678,  71.943);\nvec4 coeff2 = vec4(-29.707,  5.9189, -0.4027, 0.0071);\nreturn dot(coeff1, vec3(x6, x5, x4)) + dot(coeff2, vec4(x3, x2, x, 1.0));\n}\nvec4 overlayEdgeDetect(vec2 vUv) {\nint has_zero = 0;\nvec4 center;\nvec4 non_zero_pixel;\nfloat max_alpha = 0.0;\nfor (int j=-1; j<=1; j++) {\nfor (int i=-1; i<=1; i++) {\nvec4 c = fetchOverlayTexel(vUv, vec2(i, j));\nmax_alpha = max(max_alpha, c.a);\nif (i==0 && j==0)\ncenter = c;\nif (c.a == 0.0)\nhas_zero++;\nelse\nnon_zero_pixel = c;\n}\n}\nif (has_zero != 0 && has_zero != 9)\n{\nif (center == vec4(0.0))\ncenter = non_zero_pixel;\nfloat maxComponent = max(center.r, max(center.g, center.b));\ncenter.rgb /= maxComponent;\ncenter.rgb = sqrt(center.rgb);\ncenter.a = 0.5 + 0.5 * max_alpha * 0.125 * float(has_zero);\n}\nif (has_zero == 0) {\ncenter.a = -center.a;\n}\nreturn center;\n}\nvoid main() {\nvec4 texel = texture2D( tDiffuse, vUv );\nfloat ao = (useAO != 0) ? texture2D(tAO, vUv).r : 1.0;\ntexel.rgb *= ao;\nif (toneMapMethod == 1) {\ntexel.rgb *= exposureBias / whiteScale;\n} else if (toneMapMethod == 2) {\ntexel.rgb = toneMapReinhard(texel.rgb, exposureBias, whiteScale);\n} else if (toneMapMethod == 3) {\ntexel.rgb = toneMapUncharted2(texel.rgb * exposureBias);\ntexel.rgb *= 1.0 / toneMapUncharted2(vec3(whiteScale));\n} else if (toneMapMethod == 4) {\ntexel.rgb = toneMapExpRgb(texel.rgb * exposureBias);\n} else if (toneMapMethod == 5) {\nvec3 indexColor = log10(max(vec3(0.000000001), texel.rgb * exposureBias));\nindexColor = min(vec3(1.0), max(vec3(0.0), (indexColor.rgb - TonemapMin) / (TonemapMax - TonemapMin)));\ntexel.rgb = vec3(toneMapCanon(indexColor.r), toneMapCanon(indexColor.g), toneMapCanon(indexColor.b));\ntexel.rgb = pow(texel.rgb, vec3(2.2));\n}\ntexel.rgb = pow(texel.rgb, vec3(gamma));\nif (useOverlay!=0) {\nvec4 overlay = overlayEdgeDetect(vUv);\nif (overlay.a < 0.0) {\noverlay.a = -overlay.a;\nif (overlay.a >= 0.99) {\noverlay.a = 0.75;\ntexel.rgb = vec3(luminance_post(texel.rgb));\n}\n}\ntexel.rgb = mix(texel.rgb, overlay.rgb, overlay.a);\n}\ngl_FragColor = texel;\n}"
};
THREE.ShaderPass = function(a, b) {
    this.textureID = void 0 !== b ? b : "tDiffuse";
    this.uniforms = THREE.UniformsUtils.clone(a.uniforms);
    this.material = new THREE.ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader
    });
    this.renderToScreen = !1;
    this.needsSwap = this.enabled = !0;
    this.clear = !1;
    this.camera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
    this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2,2),this.material);
    this.scene = new THREE.Scene;
    this.scene.add(this.quad)
}
;
THREE.ShaderPass.prototype = {
    render: function(a, b, c, e) {
        this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = c);
        this.renderToScreen || !b ? a.render(this.scene, this.camera) : a.render(this.scene, this.camera, b, this.clear)
    }
};
SAOShader = {
    uniforms: {
        tDepth: {
            type: "t",
            value: null 
        },
        size: {
            type: "v2",
            value: new THREE.Vector2(512,512)
        },
        cameraNear: {
            type: "f",
            value: 1
        },
        cameraFar: {
            type: "f",
            value: 100
        },
        radius: {
            type: "f",
            value: 10
        },
        bias: {
            type: "f",
            value: .01
        },
        projScale: {
            type: "f",
            value: 500
        },
        projInfo: {
            type: "v4",
            value: new THREE.Vector4(0,0,0,0)
        },
        intensity: {
            type: "f",
            value: .75
        },
        tDepth_mip1: {
            type: "t",
            value: null 
        },
        tDepth_mip2: {
            type: "t",
            value: null 
        },
        tDepth_mip3: {
            type: "t",
            value: null 
        },
        tDepth_mip4: {
            type: "t",
            value: null 
        },
        tDepth_mip5: {
            type: "t",
            value: null 
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "#extension GL_OES_standard_derivatives : enable\n#define USE_MIPMAP 1\nuniform float cameraNear;\nuniform float cameraFar;\nuniform vec2 size;\nuniform float lumInfluence;\nvarying vec2 vUv;\n#define NUM_SAMPLES (17)\n#define LOG_MAX_OFFSET (3)\n#define MAX_MIP_LEVEL (5)\n#define NUM_SPIRAL_TURNS (7)\nuniform float           projScale;\nuniform sampler2D tDepth;\n#ifdef USE_MIPMAP\nuniform sampler2D tDepth_mip1;\nuniform sampler2D tDepth_mip2;\nuniform sampler2D tDepth_mip3;\nuniform sampler2D tDepth_mip4;\nuniform sampler2D tDepth_mip5;\n#endif\nuniform float radius;\nuniform float bias;\nuniform float intensity;\nfloat intensityDivR6 = intensity / pow(radius, 6.0);\nvec2 tapLocation(int sampleNumber, float spinAngle, out float ssR){\nfloat alpha = float(float(sampleNumber) + 0.5) * (1.0 / float(NUM_SAMPLES));\nfloat angle = alpha * (float(NUM_SPIRAL_TURNS) * 6.28) + spinAngle;\nssR = alpha;\nreturn vec2(cos(angle), sin(angle));\n}\nfloat CSZToKey(float z) {\nreturn clamp(z * (1.0 / -cameraFar), 0.0, 1.0);\n}\nvoid packKey(float key, out vec2 p) {\nfloat temp = floor(key * 256.0);\np.x = temp * (1.0 / 256.0);\np.y = key * 256.0 - temp;\n}\nfloat unpackDepth( const in vec4 rgba_depth ) {\nfloat depth = dot( rgba_depth, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\nif (depth == 0.0)\nreturn -cameraFar * 1.0e10;\nreturn depth * (cameraNear - cameraFar) - cameraNear;\n}\nuniform vec4 projInfo;\nvec3 reconstructCSPosition(vec2 S, float z) {\nreturn vec3((S.xy * projInfo.xy + projInfo.zw) * z, z);\n}\nvec3 reconstructCSFaceNormal(vec3 C) {\nreturn normalize(cross(dFdy(C), dFdx(C)));\n}\nvec3 reconstructNonUnitCSFaceNormal(vec3 C) {\nreturn cross(dFdy(C), dFdx(C));\n}\nvec2 sizeM1 = vec2(1.0/(size.x), 1.0/(size.y));\nvec3 getPosition(ivec2 ssP, float depth) {\nvec3 P;\nP = reconstructCSPosition(vec2(ssP) + vec2(0.5), depth);\nreturn P;\n}\nvec3 getOffsetPosition(ivec2 ssC, vec2 unitOffset, float ssR) {\nivec2 ssP = ivec2(ssR * unitOffset) + ssC;\nvec3 P;\nvec2 screenUV = (vec2(ssP) + vec2(0.5)) * sizeM1;\n#ifdef USE_MIPMAP\nint mipLevel = int(max(0.0, min(floor(log2(ssR)) - float(LOG_MAX_OFFSET), float(MAX_MIP_LEVEL))));\nif (mipLevel == 0) {\nP.z = texture2D(tDepth, screenUV).z;\nif (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n}\nelse if (mipLevel == 1)\nP.z = unpackDepth(texture2D(tDepth_mip1, screenUV));\nelse if (mipLevel == 2)\nP.z = unpackDepth(texture2D(tDepth_mip2, screenUV));\nelse if (mipLevel == 3)\nP.z = unpackDepth(texture2D(tDepth_mip3, screenUV));\nelse if (mipLevel == 4)\nP.z = unpackDepth(texture2D(tDepth_mip4, screenUV));\nelse if (mipLevel == 5)\nP.z = unpackDepth(texture2D(tDepth_mip5, screenUV));\n#else\nP.z = texture2D(tDepth, screenUV).z;\nif (P.z == 0.0) P.z = -cameraFar * 1.0e10;\n#endif\nP = reconstructCSPosition(vec2(ssP) + vec2(0.5), P.z);\nreturn P;\n}\nfloat radius2 = radius * radius;\nfloat invRadius2 = 1.0 / radius2;\nfloat sampleAO(in ivec2 ssC, in vec3 C, in vec3 n_C, in float ssDiskRadius, in int tapIndex, in float randomPatternRotationAngle) {\nfloat ssR;\nvec2 unitOffset = tapLocation(tapIndex, randomPatternRotationAngle, ssR);\nssR *= ssDiskRadius;\nvec3 Q = getOffsetPosition(ssC, unitOffset, ssR);\nvec3 v = Q - C;\nfloat vv = dot(v, v);\nfloat vn = dot(v, n_C);\nconst float epsilon = 0.01;\nfloat f = max(radius2 - vv, 0.0); return f * f * f * max((vn - bias) / (epsilon + vv), 0.0);\n}\nconst bool useNoise = true;\nvec2 rand( const vec2 coord ) {\nvec2 noise;\nif ( useNoise ) {\nfloat nx = dot ( coord, vec2( 12.9898, 78.233 ) );\nfloat ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );\nnoise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );\n} else {\nfloat ff = fract( 1.0 - coord.s * ( size.x / 2.0 ) );\nfloat gg = fract( coord.t * ( size.y / 2.0 ) );\nnoise = vec2( 0.25, 0.75 ) * vec2( ff ) + vec2( 0.75, 0.25 ) * gg;\n}\nreturn ( noise * 2.0  - 1.0 );\n}\nfloat getRandomAngle(vec2 pos) {\nvec2 rnd = rand(pos);\nreturn atan(rnd.y, rnd.x);\n}\nvoid main() {\nivec2 ssC = ivec2(gl_FragCoord.xy);\nvec4 nrmz = texture2D(tDepth, vUv);\nif (nrmz.z == 0.0) {\ngl_FragColor.r = 1.0;\ngl_FragColor.a = 0.0;\npackKey(1.0, gl_FragColor.gb);\nreturn;\n}\nvec3 C = getPosition(ssC, nrmz.z);\npackKey(CSZToKey(C.z), gl_FragColor.gb);\nfloat randomPatternRotationAngle = getRandomAngle(vUv);\nvec3 n_C = vec3(nrmz.x, nrmz.y, sqrt(1.0 - dot(nrmz.xy, nrmz.xy)));\nfloat ssDiskRadius = -projScale * radius / C.z;\nfloat sum = 0.0;\nfor (int i = 0; i < NUM_SAMPLES; ++i) {\nsum += sampleAO(ssC, C, n_C, ssDiskRadius, i, randomPatternRotationAngle);\n}\nfloat A = max(0.0, 1.0 - sum * intensityDivR6 * (5.0 / float(NUM_SAMPLES)));\nif (abs(dFdx(C.z)) < 0.02) {\nA -= dFdx(A) * (mod(float(ssC.x), 2.0) - 0.5);\n}\nif (abs(dFdy(C.z)) < 0.02) {\nA -= dFdy(A) * (mod(float(ssC.y), 2.0) - 0.5);\n}\ngl_FragColor.r = A;\ngl_FragColor.a = 1.0;\n}"
};
SAOBlurShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null 
        },
        size: {
            type: "v2",
            value: new THREE.Vector2(512,512)
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 512,1 / 512)
        },
        axis: {
            type: "v2",
            value: new THREE.Vector2(1,0)
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "#define EDGE_SHARPNESS     (1.0)\n#define SCALE               (2)\n#define R                   (4)\n#define VALUE_TYPE        float\n#define VALUE_COMPONENTS   r\n#define VALUE_IS_KEY       0\n#define KEY_COMPONENTS     gb\n#if __VERSION__ >= 330\nconst float gaussian[R + 1] =\nfloat[](0.153170, 0.144893, 0.122649, 0.092902, 0.062970);  // stddev = 2.0\n#endif\nuniform sampler2D   tDiffuse;\nuniform vec2 size;\nuniform vec2 resolution;\nuniform vec2       axis;\nivec2 axisi = ivec2(axis);\n#define  result         gl_FragColor.VALUE_COMPONENTS\n#define  keyPassThrough gl_FragColor.KEY_COMPONENTS\nfloat unpackKey(vec2 p) {\nreturn p.x * (256.0 / 257.0) + p.y * (1.0 / 257.0);\n}\nvarying vec2 vUv;\nvoid main() {\n#   if __VERSION__ < 330\nfloat gaussian[R + 1];\n#       if R == 3\ngaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902;  // stddev = 2.0\n#       elif R == 4\ngaussian[0] = 0.153170; gaussian[1] = 0.144893; gaussian[2] = 0.122649; gaussian[3] = 0.092902; gaussian[4] = 0.062970;  // stddev = 2.0\n#       elif R == 6\ngaussian[0] = 0.111220; gaussian[1] = 0.107798; gaussian[2] = 0.098151; gaussian[3] = 0.083953; gaussian[4] = 0.067458; gaussian[5] = 0.050920; gaussian[6] = 0.036108;\n#       endif\n#   endif\nivec2 ssC = ivec2(gl_FragCoord.xy);\nvec4 temp = texture2D(tDiffuse, vUv);\ngl_FragColor.gb = temp.KEY_COMPONENTS;\ngl_FragColor.a = temp.a;\nVALUE_TYPE sum = temp.VALUE_COMPONENTS;\nif (temp.a == 0.0) {\nresult = sum;\nreturn;\n}\nfloat key = unpackKey(keyPassThrough);\nfloat BASE = gaussian[0];\nfloat totalWeight = BASE;\nsum *= totalWeight;\nfor (int r = -R; r <= R; ++r) {\nif (r != 0) {\nvec2 ssUV = vec2(ssC + axisi * (r * SCALE))*resolution;\ntemp = texture2D(tDiffuse, ssUV);\nfloat      tapKey = unpackKey(temp.KEY_COMPONENTS);\nVALUE_TYPE value  = temp.VALUE_COMPONENTS;\nfloat weight = 0.3 + gaussian[r<0?-r:r];\nfloat dz = tapKey - key;\nweight *= max(0.0, 1.0 - (EDGE_SHARPNESS * 2000.0) * abs(dz));\nsum += value * weight;\ntotalWeight += weight;\n}\n}\nconst float epsilon = 0.0001;\nresult = sum / (totalWeight + epsilon);\n}"
};
SAOMinifyFirstShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null 
        },
        cameraNear: {
            type: "f",
            value: 1
        },
        cameraInvNearFar: {
            type: "f",
            value: 100
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 512,1 / 512)
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nuniform float cameraNear;\nuniform float cameraInvNearFar;\nvarying vec2 vUv;\nvec4 packDepth( const in float depth ) {\nvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\nenc = fract(enc);\nenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\nreturn enc;\n}\nvoid main() {\nvec2 ssP = vec2(gl_FragCoord.xy);\nssP = ssP * 2.0 + mod(ssP, 2.0);\nssP = (ssP + 0.5) * resolution * 0.5;\nfloat depth = texture2D(tDiffuse, ssP).z;\nif (depth != 0.0)\ndepth = (depth + cameraNear) * cameraInvNearFar;\ngl_FragColor = packDepth(depth);\n}"
};
SAOMinifyShader = {
    uniforms: {
        tDiffuse: {
            type: "t",
            value: null 
        },
        resolution: {
            type: "v2",
            value: new THREE.Vector2(1 / 512,1 / 512)
        }
    },
    vertexShader: "varying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "uniform sampler2D tDiffuse;\nuniform vec2 resolution;\nvarying vec2 vUv;\nvoid main() {\nvec2 ssP = vec2(gl_FragCoord.xy);\nssP = ssP * 2.0 + mod(ssP, 2.0);\nssP = (ssP + 0.5) * resolution * 0.5;\ngl_FragColor = texture2D(tDiffuse, ssP);\n}"
};
NormalsShader = {
    uniforms: {},
    vertexShader: "varying vec3 vNormal;\nvarying float depth;\nvoid main() {\nvNormal = normalize( normalMatrix * normal );\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\ndepth = mvPosition.z;\nvec4 p_Position = projectionMatrix * mvPosition;\ngl_Position = p_Position;\n}",
    fragmentShader: "varying vec3 vNormal;\nvarying float depth;\nvoid main() {\nvec3 n = vNormal;\nn = n * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\nn = normalize( n );\ngl_FragColor = vec4(n.x, n.y, depth, 1.0);\n}"
};
BackgroundShader = {
    uniforms: {
        color1: {
            type: "v4",
            value: new THREE.Vector4(1 / 255,2 / 255,3 / 255,1)
        },
        color2: {
            type: "v4",
            value: new THREE.Vector4(41 / 255,76 / 255,120 / 255,1)
        }
    },
    vertexShader: "uniform vec4 color1;\nuniform vec4 color2;\nvarying vec4 vcolor;\nvoid main() {\nif (uv.y == 0.0)\nvcolor = color1;\nelse\nvcolor = color2;\ngl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    fragmentShader: "const vec4 c0 = vec4(1.0, 13.0, 4.0, 16.0);\nconst vec4 c1 = vec4(9.0, 5.0, 12.0, 8.0);\nconst vec4 c2 = vec4(3.0, 15.0, 2.0, 14.0);\nconst vec4 c3 = vec4(11.0, 7.0, 10.0, 6.0);\nvarying vec4 vcolor;\nvoid main() {\nvec4 c = vcolor;\nint i = int(mod(float(gl_FragCoord.x), 4.0));\nint j = int(mod(float(gl_FragCoord.y), 4.0));\nvec4 col;\nif (i==0) col = c0; else if (i==1) col = c1; else if (i==2) col = c2; else col = c3;\nfloat bias;\nif (j==0) bias = col.x; else if (j==1) bias = col.y; else if (j==2) bias = col.z; else bias = col.w;\nc.xyz += bias * (1.0/(17.0*256.0));\ngl_FragColor = c;\n}"
};
FireflyWebGLRenderer = function(a) {
    function b(a, b) {
        var f = b.geometry
          , g = a.faces3
          , k = 3 * g.length
          , h = 1 * g.length
          , l = 3 * g.length
          , g = c(b, a)
          , m = d(g)
          , n = e(g)
          , p = g.vertexColors ? g.vertexColors : !1;
        a.__vertexArray = new Float32Array(3 * k);
        n && (a.__normalArray = new Float32Array(3 * k));
        f.hasTangents && (a.__tangentArray = new Float32Array(4 * k));
        p && (a.__colorArray = new Float32Array(3 * k));
        m && (0 < f.faceVertexUvs.length && (a.__uvArray = new Float32Array(2 * k)),
        1 < f.faceVertexUvs.length && (a.__uv2Array = new Float32Array(2 * k)));
        b.geometry.skinWeights.length && 
        b.geometry.skinIndices.length && (a.__skinIndexArray = new Float32Array(4 * k),
        a.__skinWeightArray = new Float32Array(4 * k));
        a.__faceArray = new Uint16Array(3 * h);
        a.__lineArray = new Uint16Array(2 * l);
        a.__webglFaceCount = 3 * h;
        a.__webglLineCount = 2 * l;
        if (g.attributes) {
            void 0 === a.__webglCustomAttributesList && (a.__webglCustomAttributesList = []);
            for (var r in g.attributes) {
                var f = g.attributes[r], h = {}, t;
                for (t in f)
                    h[t] = f[t];
                if (!h.__webglInitialized || h.createUniqueBuffers)
                    h.__webglInitialized = !0,
                    l = 1,
                    "v2" === h.type ? l = 2 : "v3" === 
                    h.type ? l = 3 : "v4" === h.type ? l = 4 : "c" === h.type && (l = 3),
                    h.size = l,
                    h.array = new Float32Array(k * l),
                    h.buffer = q.createBuffer(),
                    h.buffer.belongsToAttribute = r,
                    f.needsUpdate = !0,
                    h.__original = f;
                a.__webglCustomAttributesList.push(h)
            }
        }
        a.__inittedArrays = !0
    }
    function c(a, b) {
        return a.material instanceof THREE.MeshFaceMaterial ? a.material.materials[b.materialIndex] : a.material
    }
    function e(a) {
        return a instanceof THREE.MeshBasicMaterial && !a.envMap || a instanceof THREE.MeshDepthMaterial ? !1 : a && void 0 !== a.shading && a.shading === THREE.SmoothShading ? 
        THREE.SmoothShading : THREE.FlatShading
    }
    function d(a) {
        return a.map || a.lightMap || a.bumpMap || a.normalMap || a.specularMap || a instanceof THREE.ShaderMaterial ? !0 : !1
    }
    function g(a, b, c, d) {
        var e, f, g, h, l = !1;
        if (c.vb) {
            c.streamingDraw ? (g = xa.interleavedVB,
            g || (g = q.createBuffer(),
            xa.interleavedVB = g),
            q.bindBuffer(q.ARRAY_BUFFER, g),
            q.bufferData(q.ARRAY_BUFFER, c.vb, q.STATIC_DRAW)) : q.bindBuffer(q.ARRAY_BUFFER, c.vbbuffer);
            var m = c.vbstride;
            for (h in b)
                "index" != h && (f = b[h],
                e = c.attributes[h],
                0 <= f && e && (void 0 !== e.itemOffset ? (g = 
                e.itemSize,
                k(f),
                q.vertexAttribPointer(f, g, q.FLOAT, !1, 4 * m, 4 * (e.itemOffset + d * m))) : l = !0))
        } else
            l = !0;
        if (l)
            for (h in b)
                "index" != h && (f = b[h],
                e = c.attributes[h],
                0 <= f && (e ? void 0 === e.itemOffset && (c.streamingDraw ? (g = xa[h],
                g || (g = q.createBuffer(),
                xa[h] = g),
                q.bindBuffer(q.ARRAY_BUFFER, g),
                q.bufferData(q.ARRAY_BUFFER, e.array, q.STATIC_DRAW)) : q.bindBuffer(q.ARRAY_BUFFER, e.buffer),
                g = e.itemSize,
                k(f),
                q.vertexAttribPointer(f, g, q.FLOAT, !1, 0, d * g * 4)) : a.defaultAttributeValues && (2 === a.defaultAttributeValues[h].length ? q.vertexAttrib2fv(f, 
                a.defaultAttributeValues[h]) : 3 === a.defaultAttributeValues[h].length && q.vertexAttrib3fv(f, a.defaultAttributeValues[h]))))
    }
    function f(a, b, c, d) {
        var e, f, g, h;
        for (f in b)
            g = b[f],
            e = c[f],
            0 <= g && (e ? (h = e.itemSize,
            q.bindBuffer(q.ARRAY_BUFFER, e.buffer),
            k(g),
            q.vertexAttribPointer(g, h, q.FLOAT, !1, 0, d * h * 4)) : a.defaultAttributeValues && a.defaultAttributeValues[f] && (2 === a.defaultAttributeValues[f].length ? q.vertexAttrib2fv(g, a.defaultAttributeValues[f]) : 3 === a.defaultAttributeValues[f].length && q.vertexAttrib3fv(g, a.defaultAttributeValues[f])))
    }
    function k(a) {
        wa[a] || (q.enableVertexAttribArray(a),
        wa[a] = !0)
    }
    function h() {
        for (var a = 0, b = wa.length; a < b; a++)
            wa[a] && (q.disableVertexAttribArray(a),
            wa[a] = !1)
    }
    function l(a, b) {
        return a.z !== b.z ? b.z - a.z : a.id - b.id
    }
    function m(a, b, c) {
        if (a.length)
            for (var d = 0, e = a.length; d < e; d++)
                ya = fa = null ,
                aa = oa = Ka = ma = Ta = Za = za = -1,
                Va = !0,
                a[d].render(b, c, pa, Aa),
                ya = fa = null ,
                aa = oa = Ka = ma = Ta = Za = za = -1,
                Va = !0
    }
    function n(a, b, c, d, e, f, g, k) {
        var h, l, m, n;
        b ? (l = a.length - 1,
        n = b = -1) : (l = 0,
        b = a.length,
        n = 1);
        for (var q = l; q !== b; q += n)
            if (h = a[q],
            h.render) {
                l = 
                h.object;
                m = h.buffer;
                if (k)
                    h = k;
                else {
                    h = h[c];
                    if (!h)
                        continue;g && J.setBlending(h.blending, h.blendEquation, h.blendSrc, h.blendDst);
                    J.setDepthTest(h.depthTest);
                    J.setDepthWrite(h.depthWrite);
                    E(h.polygonOffset, h.polygonOffsetFactor, h.polygonOffsetUnits)
                }
                J.setMaterialFaces(h);
                m instanceof THREE.BufferGeometry ? J.renderBufferDirect(d, e, f, h, m, l) : J.renderBuffer(d, e, f, h, m, l)
            }
    }
    function p(a, c) {
        var d, e, f, g;
        if (void 0 === a.__webglInit && (a.__webglInit = !0,
        a._modelViewMatrix = new THREE.Matrix4,
        a._normalMatrix = new THREE.Matrix3,
        void 0 !== a.geometry && void 0 === a.geometry.__webglInit && (a.geometry.__webglInit = !0,
        a.geometry.addEventListener("dispose", eb)),
        e = a.geometry,
        void 0 !== e))
            if (e instanceof THREE.BufferGeometry)
                if (e.streamingDraw)
                    !e.streamingIndex && (e = e.attributes.index) && (e.buffer = q.createBuffer(),
                    q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, e.buffer),
                    q.bufferData(q.ELEMENT_ARRAY_BUFFER, e.array, q.STATIC_DRAW));
                else {
                    e.vb && (e.vbbuffer = q.createBuffer(),
                    q.bindBuffer(q.ARRAY_BUFFER, e.vbbuffer),
                    q.bufferData(q.ARRAY_BUFFER, e.vb, q.STATIC_DRAW));
                    var k, h;
                    for (k in e.attributes)
                        g = e.attributes[k],
                        g.array && (h = "index" === k ? q.ELEMENT_ARRAY_BUFFER : q.ARRAY_BUFFER,
                        g.buffer = q.createBuffer(),
                        q.bindBuffer(h, g.buffer),
                        q.bufferData(h, g.array, q.STATIC_DRAW))
                }
            else if (a instanceof THREE.Mesh) {
                f = a.material;
                if (void 0 === e.geometryGroups) {
                    h = e;
                    var l, m, n;
                    k = {};
                    var p = h.morphTargets.length
                      , r = h.morphNormals.length
                      , u = f instanceof THREE.MeshFaceMaterial;
                    h.geometryGroups = {};
                    f = 0;
                    for (l = h.faces.length; f < l; f++)
                        m = h.faces[f],
                        m = u ? m.materialIndex : 0,
                        void 0 === k[m] && (k[m] = {
                            hash: m,
                            counter: 0
                        }),
                        n = k[m].hash + "_" + k[m].counter,
                        void 0 === h.geometryGroups[n] && (h.geometryGroups[n] = {
                            faces3: [],
                            materialIndex: m,
                            vertices: 0,
                            numMorphTargets: p,
                            numMorphNormals: r
                        }),
                        65535 < h.geometryGroups[n].vertices + 3 && (k[m].counter += 1,
                        n = k[m].hash + "_" + k[m].counter,
                        void 0 === h.geometryGroups[n] && (h.geometryGroups[n] = {
                            faces3: [],
                            materialIndex: m,
                            vertices: 0,
                            numMorphTargets: p,
                            numMorphNormals: r
                        })),
                        h.geometryGroups[n].faces3.push(f),
                        h.geometryGroups[n].vertices += 3;
                    h.geometryGroupsList = [];
                    for (g in h.geometryGroups)
                        h.geometryGroups[g].id = 
                        Da++,
                        h.geometryGroupsList.push(h.geometryGroups[g])
                }
                for (d in e.geometryGroups)
                    g = e.geometryGroups[d],
                    g.__webglVertexBuffer || (h = g,
                    h.__webglVertexBuffer = q.createBuffer(),
                    h.__webglNormalBuffer = q.createBuffer(),
                    h.__webglTangentBuffer = q.createBuffer(),
                    h.__webglColorBuffer = q.createBuffer(),
                    h.__webglUVBuffer = q.createBuffer(),
                    h.__webglUV2Buffer = q.createBuffer(),
                    h.__webglSkinIndicesBuffer = q.createBuffer(),
                    h.__webglSkinWeightsBuffer = q.createBuffer(),
                    h.__webglFaceBuffer = q.createBuffer(),
                    h.__webglLineBuffer = q.createBuffer(),
                    J.info.memory.geometries++,
                    b(g, a),
                    e.verticesNeedUpdate = !0,
                    e.morphTargetsNeedUpdate = !0,
                    e.elementsNeedUpdate = !0,
                    e.uvsNeedUpdate = !0,
                    e.normalsNeedUpdate = !0,
                    e.tangentsNeedUpdate = !0,
                    e.colorsNeedUpdate = !0)
            } else if (a instanceof THREE.Line && !e.__webglVertexBuffer) {
                g = e;
                g.__webglVertexBuffer = q.createBuffer();
                g.__webglColorBuffer = q.createBuffer();
                g.__webglLineDistanceBuffer = q.createBuffer();
                J.info.memory.geometries++;
                g = e;
                k = g.vertices.length;
                g.__vertexArray = new Float32Array(3 * k);
                g.__colorArray = new Float32Array(3 * 
                k);
                g.__lineDistanceArray = new Float32Array(1 * k);
                g.__webglLineCount = k;
                k = g.vertices.length;
                p = a.material;
                if (p.attributes)
                    for (h in void 0 === g.__webglCustomAttributesList && (g.__webglCustomAttributesList = []),
                    p.attributes) {
                        r = p.attributes[h];
                        if (!r.__webglInitialized || r.createUniqueBuffers)
                            r.__webglInitialized = !0,
                            f = 1,
                            "v2" === r.type ? f = 2 : "v3" === r.type ? f = 3 : "v4" === r.type ? f = 4 : "c" === r.type && (f = 3),
                            r.size = f,
                            r.array = new Float32Array(k * f),
                            r.buffer = q.createBuffer(),
                            r.buffer.belongsToAttribute = h,
                            r.needsUpdate = !0;
                        g.__webglCustomAttributesList.push(r)
                    }
                e.verticesNeedUpdate = 
                !0;
                e.colorsNeedUpdate = !0;
                e.lineDistancesNeedUpdate = !0
            }
        if (void 0 === a.__webglActive) {
            if (a instanceof THREE.Mesh)
                if (e = a.geometry,
                e instanceof THREE.BufferGeometry)
                    t(c.__webglObjects, e, a);
                else {
                    if (e instanceof THREE.Geometry)
                        for (d in e.geometryGroups)
                            g = e.geometryGroups[d],
                            t(c.__webglObjects, g, a)
                }
            else
                a instanceof THREE.Line && (e = a.geometry,
                t(c.__webglObjects, e, a));
            a.__webglActive = !0
        }
    }
    function t(a, b, c) {
        a.push({
            id: null ,
            buffer: b,
            object: c,
            opaque: null ,
            transparent: null ,
            z: 0
        })
    }
    function v(a) {
        for (var b in a.attributes)
            if (a.attributes[b].needsUpdate)
                return !0;
        return !1
    }
    function r(a) {
        for (var b in a.attributes)
            a.attributes[b].needsUpdate = !1
    }
    function u(a, b) {
        if (a instanceof THREE.Mesh || a instanceof THREE.Line)
            for (var c = b.__webglObjects, d = c.length - 1; 0 <= d; d--)
                c[d].object === a && c.splice(d, 1);
        delete a.__webglActive
    }
    function w(a, b, c, d, e) {
        Ra = 0;
        d.needsUpdate && (d.program && mb(d),
        J.initMaterial(d, b, c, e),
        d.needsUpdate = !1);
        var f = !1
          , g = d.program
          , k = g.uniforms
          , h = d.uniforms;
        g !== fa && (q.useProgram(g),
        fa = g,
        f = !0);
        d.id !== aa && (aa = d.id,
        f = !0);
        if (f || a !== ya)
            q.uniformMatrix4fv(k.projectionMatrix, 
            !1, a.projectionMatrix.elements),
            a !== ya && (ya = a);
        if (f) {
            c && d.fog && (h.fogColor.value = c.color,
            c instanceof THREE.Fog ? (h.fogNear.value = c.near,
            h.fogFar.value = c.far) : c instanceof THREE.FogExp2 && (h.fogDensity.value = c.density));
            if (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d.lights) {
                if (Va) {
                    var l, m = 0, n = 0, p = 0, r, t, u, w = nb, v = w.directional.colors, z = w.directional.positions, E = w.point.colors, C = w.point.positions, G = w.point.distances, B = w.spot.colors, H = w.spot.positions, P = w.spot.distances, 
                    O = w.spot.directions, Q = w.spot.anglesCos, T = w.spot.exponents, R = w.hemi.skyColors, S = w.hemi.groundColors, N = w.hemi.positions, U = 0, Z = 0, Y = 0, ca = 0, ia = 0, ja = 0, ka = 0, X = 0, W = l = 0;
                    c = u = W = 0;
                    for (f = b.length; c < f; c++)
                        if (l = b[c],
                        !l.onlyShadow)
                            if (r = l.color,
                            t = l.intensity,
                            u = l.distance,
                            l instanceof THREE.AmbientLight)
                                l.visible && (J.gammaInput ? (m += r.r * r.r,
                                n += r.g * r.g,
                                p += r.b * r.b) : (m += r.r,
                                n += r.g,
                                p += r.b));
                            else if (l instanceof THREE.DirectionalLight) {
                                if (ia += 1,
                                l.visible && (ga.setFromMatrixPosition(l.matrixWorld),
                                ba.setFromMatrixPosition(l.target.matrixWorld),
                                ga.sub(ba),
                                ga.normalize(),
                                0 !== ga.x || 0 !== ga.y || 0 !== ga.z))
                                    l = 3 * U,
                                    z[l] = ga.x,
                                    z[l + 1] = ga.y,
                                    z[l + 2] = ga.z,
                                    J.gammaInput ? A(v, l, r, t * t) : y(v, l, r, t),
                                    U += 1
                            } else
                                l instanceof THREE.PointLight ? (ja += 1,
                                l.visible && (W = 3 * Z,
                                J.gammaInput ? A(E, W, r, t * t) : y(E, W, r, t),
                                ba.setFromMatrixPosition(l.matrixWorld),
                                C[W] = ba.x,
                                C[W + 1] = ba.y,
                                C[W + 2] = ba.z,
                                G[Z] = u,
                                Z += 1)) : l instanceof THREE.SpotLight ? (ka += 1,
                                l.visible && (W = 3 * Y,
                                J.gammaInput ? A(B, W, r, t * t) : y(B, W, r, t),
                                ba.setFromMatrixPosition(l.matrixWorld),
                                H[W] = ba.x,
                                H[W + 1] = ba.y,
                                H[W + 2] = ba.z,
                                P[Y] = u,
                                ga.copy(ba),
                                ba.setFromMatrixPosition(l.target.matrixWorld),
                                ga.sub(ba),
                                ga.normalize(),
                                O[W] = ga.x,
                                O[W + 1] = ga.y,
                                O[W + 2] = ga.z,
                                Q[Y] = Math.cos(l.angle),
                                T[Y] = l.exponent,
                                Y += 1)) : l instanceof THREE.HemisphereLight && (X += 1,
                                l.visible && (ga.setFromMatrixPosition(l.matrixWorld),
                                ga.normalize(),
                                0 !== ga.x || 0 !== ga.y || 0 !== ga.z)) && (u = 3 * ca,
                                N[u] = ga.x,
                                N[u + 1] = ga.y,
                                N[u + 2] = ga.z,
                                r = l.color,
                                l = l.groundColor,
                                J.gammaInput ? (t *= t,
                                A(R, u, r, t),
                                A(S, u, l, t)) : (y(R, u, r, t),
                                y(S, u, l, t)),
                                ca += 1);
                    c = 3 * U;
                    for (f = Math.max(v.length, 3 * ia); c < f; c++)
                        v[c] = 0;
                    c = 3 * Z;
                    for (f = Math.max(E.length, 
                    3 * ja); c < f; c++)
                        E[c] = 0;
                    c = 3 * Y;
                    for (f = Math.max(B.length, 3 * ka); c < f; c++)
                        B[c] = 0;
                    c = 3 * ca;
                    for (f = Math.max(R.length, 3 * X); c < f; c++)
                        R[c] = 0;
                    c = 3 * ca;
                    for (f = Math.max(S.length, 3 * X); c < f; c++)
                        S[c] = 0;
                    w.directional.length = U;
                    w.point.length = Z;
                    w.spot.length = Y;
                    w.hemi.length = ca;
                    w.ambient[0] = m;
                    w.ambient[1] = n;
                    w.ambient[2] = p;
                    Va = !1
                }
                c = nb;
                h.ambientLightColor.value = c.ambient;
                h.directionalLightColor.value = c.directional.colors;
                h.directionalLightDirection.value = c.directional.positions;
                h.pointLightColor.value = c.point.colors;
                h.pointLightPosition.value = 
                c.point.positions;
                h.pointLightDistance.value = c.point.distances;
                h.spotLightColor.value = c.spot.colors;
                h.spotLightPosition.value = c.spot.positions;
                h.spotLightDistance.value = c.spot.distances;
                h.spotLightDirection.value = c.spot.directions;
                h.spotLightAngleCos.value = c.spot.anglesCos;
                h.spotLightExponent.value = c.spot.exponents;
                h.hemisphereLightSkyColor.value = c.hemi.skyColors;
                h.hemisphereLightGroundColor.value = c.hemi.groundColors;
                h.hemisphereLightDirection.value = c.hemi.positions
            }
            if (d instanceof THREE.MeshBasicMaterial || 
            d instanceof THREE.MeshLambertMaterial || d instanceof THREE.MeshPhongMaterial) {
                h.opacity.value = d.opacity;
                J.gammaInput ? h.diffuse.value.copyGammaToLinear(d.color) : h.diffuse.value.copy(d.color);
                h.map.value = d.map;
                h.lightMap.value = d.lightMap;
                h.specularMap.value = d.specularMap;
                d.bumpMap && (h.bumpMap.value = d.bumpMap,
                h.bumpScale.value = d.bumpScale);
                d.normalMap && (h.normalMap.value = d.normalMap,
                h.normalScale.value.copy(d.normalScale));
                var V;
                d.map ? V = d.map : d.specularMap ? V = d.specularMap : d.normalMap ? V = d.normalMap : d.bumpMap && 
                (V = d.bumpMap);
                void 0 !== V && (c = V.offset,
                V = V.repeat,
                h.offsetRepeat.value.set(c.x, c.y, V.x, V.y));
                h.envMap.value = d.envMap;
                h.reflectivity.value = J.gammaInput ? d.reflectivity * d.reflectivity : d.reflectivity;
                h.refractionRatio.value = d.refractionRatio;
                h.combine.value = d.combine;
                h.useRefract.value = d.envMap && d.envMap.mapping instanceof THREE.CubeRefractionMapping
            }
            d instanceof THREE.LineBasicMaterial ? (h.diffuse.value = d.color,
            h.opacity.value = d.opacity) : d instanceof THREE.LineDashedMaterial ? (h.diffuse.value = d.color,
            h.opacity.value = 
            d.opacity,
            h.dashSize.value = d.dashSize,
            h.totalSize.value = d.dashSize + d.gapSize,
            h.scale.value = d.scale) : d instanceof THREE.MeshPhongMaterial ? (h.shininess.value = d.shininess,
            J.gammaInput ? (h.ambient.value.copyGammaToLinear(d.ambient),
            h.emissive.value.copyGammaToLinear(d.emissive),
            h.specular.value.copyGammaToLinear(d.specular)) : (h.ambient.value.copy(d.ambient),
            h.emissive.value.copy(d.emissive),
            h.specular.value.copy(d.specular)),
            d.wrapAround && h.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshLambertMaterial ? 
            (J.gammaInput ? (h.ambient.value.copyGammaToLinear(d.ambient),
            h.emissive.value.copyGammaToLinear(d.emissive)) : (h.ambient.value.copy(d.ambient),
            h.emissive.value.copy(d.emissive)),
            d.wrapAround && h.wrapRGB.value.copy(d.wrapRGB)) : d instanceof THREE.MeshDepthMaterial ? (h.mNear.value = a.near,
            h.mFar.value = a.far,
            h.opacity.value = d.opacity) : d instanceof THREE.MeshNormalMaterial && (h.opacity.value = d.opacity);
            if (e.receiveShadow && !d._shadowPass && h.shadowMatrix)
                for (c = V = 0,
                f = b.length; c < f; c++)
                    m = b[c],
                    m.castShadow && (m instanceof 
                    THREE.SpotLight || m instanceof THREE.DirectionalLight && !m.shadowCascade) && (h.shadowMap.value[V] = m.shadowMap,
                    h.shadowMapSize.value[V] = m.shadowMapSize,
                    h.shadowMatrix.value[V] = m.shadowMatrix,
                    h.shadowDarkness.value[V] = m.shadowDarkness,
                    h.shadowBias.value[V] = m.shadowBias,
                    V++);
            b = d.uniformsList;
            h = 0;
            for (V = b.length; h < V; h++)
                if (f = g.uniforms[b[h][1]])
                    if (c = b[h][0],
                    m = c.type,
                    p = c.value,
                    "i" === m)
                        q.uniform1i(f, p);
                    else if ("f" === m)
                        q.uniform1f(f, p);
                    else if ("v2" === m)
                        q.uniform2f(f, p.x, p.y);
                    else if ("v3" === m)
                        q.uniform3f(f, p.x, 
                        p.y, p.z);
                    else if ("v4" === m)
                        q.uniform4f(f, p.x, p.y, p.z, p.w);
                    else if ("c" === m)
                        q.uniform3f(f, p.r, p.g, p.b);
                    else if ("iv1" === m)
                        q.uniform1iv(f, p);
                    else if ("iv" === m)
                        q.uniform3iv(f, p);
                    else if ("fv1" === m)
                        q.uniform1fv(f, p);
                    else if ("fv" === m)
                        q.uniform3fv(f, p);
                    else if ("v2v" === m) {
                        void 0 === c._array && (c._array = new Float32Array(2 * p.length));
                        m = 0;
                        for (n = p.length; m < n; m++)
                            w = 2 * m,
                            c._array[w] = p[m].x,
                            c._array[w + 1] = p[m].y;
                        q.uniform2fv(f, c._array)
                    } else if ("v3v" === m) {
                        void 0 === c._array && (c._array = new Float32Array(3 * p.length));
                        m = 0;
                        for (n = 
                        p.length; m < n; m++)
                            w = 3 * m,
                            c._array[w] = p[m].x,
                            c._array[w + 1] = p[m].y,
                            c._array[w + 2] = p[m].z;
                        q.uniform3fv(f, c._array)
                    } else if ("v4v" === m) {
                        void 0 === c._array && (c._array = new Float32Array(4 * p.length));
                        m = 0;
                        for (n = p.length; m < n; m++)
                            w = 4 * m,
                            c._array[w] = p[m].x,
                            c._array[w + 1] = p[m].y,
                            c._array[w + 2] = p[m].z,
                            c._array[w + 3] = p[m].w;
                        q.uniform4fv(f, c._array)
                    } else if ("m4" === m)
                        void 0 === c._array && (c._array = new Float32Array(16)),
                        p.flattenToArray(c._array),
                        q.uniformMatrix4fv(f, !1, c._array);
                    else if ("m4v" === m) {
                        void 0 === c._array && (c._array = 
                        new Float32Array(16 * p.length));
                        m = 0;
                        for (n = p.length; m < n; m++)
                            p[m].flattenToArrayOffset(c._array, 16 * m);
                        q.uniformMatrix4fv(f, !1, c._array)
                    } else if ("t" === m) {
                        if (w = p,
                        p = x(),
                        q.uniform1i(f, p),
                        w)
                            if (w.image instanceof Array && 6 === w.image.length) {
                                if (c = w,
                                f = p,
                                6 === c.image.length)
                                    if (c.needsUpdate) {
                                        c.image.__webglTextureCube || (c.addEventListener("dispose", bb),
                                        c.image.__webglTextureCube = q.createTexture(),
                                        J.info.memory.textures++);
                                        q.activeTexture(q.TEXTURE0 + f);
                                        q.bindTexture(q.TEXTURE_CUBE_MAP, c.image.__webglTextureCube);
                                        q.pixelStorei(q.UNPACK_FLIP_Y_WEBGL, c.flipY);
                                        f = c instanceof THREE.CompressedTexture;
                                        m = [];
                                        for (n = 0; 6 > n; n++)
                                            J.autoScaleCubemaps && !f ? (p = n,
                                            w = c.image[n],
                                            z = yb,
                                            w.width <= z && w.height <= z || (E = Math.max(w.width, w.height),
                                            v = Math.floor(w.width * z / E),
                                            z = Math.floor(w.height * z / E),
                                            E = document.createElement("canvas"),
                                            E.width = v,
                                            E.height = z,
                                            E.getContext("2d").drawImage(w, 0, 0, w.width, w.height, 0, 0, v, z),
                                            w = E),
                                            m[p] = w) : m[n] = c.image[n];
                                        n = m[0];
                                        p = K(n.width) && K(n.height);
                                        w = M(c.format);
                                        v = M(c.type);
                                        F(q.TEXTURE_CUBE_MAP, c, p);
                                        for (n = 0; 6 > 
                                        n; n++)
                                            if (f)
                                                for (E = m[n].mipmaps,
                                                C = 0,
                                                G = E.length; C < G; C++)
                                                    z = E[C],
                                                    c.format !== THREE.RGBAFormat ? q.compressedTexImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + n, C, w, z.width, z.height, 0, z.data) : q.texImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + n, C, w, z.width, z.height, 0, w, v, z.data);
                                            else
                                                m[n].data ? q.texImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, w, m[n].width, m[n].height, 0, w, v, m[n].data) : q.texImage2D(q.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, w, w, v, m[n]);
                                        c.generateMipmaps && p && q.generateMipmap(q.TEXTURE_CUBE_MAP);
                                        c.needsUpdate = !1;
                                        if (c.onUpdate)
                                            c.onUpdate()
                                    } else
                                        q.activeTexture(q.TEXTURE0 + 
                                        f),
                                        q.bindTexture(q.TEXTURE_CUBE_MAP, c.image.__webglTextureCube)
                            } else
                                J.setTexture(w, p)
                    } else if ("tv" === m) {
                        void 0 === c._array && (c._array = []);
                        m = 0;
                        for (n = c.value.length; m < n; m++)
                            c._array[m] = x();
                        q.uniform1iv(f, c._array);
                        m = 0;
                        for (n = c.value.length; m < n; m++)
                            w = c.value[m],
                            p = c._array[m],
                            w && J.setTexture(w, p)
                    } else
                        console.warn("THREE.WebGLRenderer: Unknown uniform type: " + m);
            (d instanceof THREE.ShaderMaterial || d instanceof THREE.MeshPhongMaterial || d.envMap) && null  !== k.cameraPosition && (ba.setFromMatrixPosition(a.matrixWorld),
            q.uniform3f(k.cameraPosition, ba.x, ba.y, ba.z));
            (d instanceof THREE.MeshPhongMaterial || d instanceof THREE.MeshLambertMaterial || d instanceof THREE.ShaderMaterial || d.skinning) && null  !== k.viewMatrix && q.uniformMatrix4fv(k.viewMatrix, !1, a.matrixWorldInverse.elements)
        }
        q.uniformMatrix4fv(k.modelViewMatrix, !1, e._modelViewMatrix.elements);
        k.normalMatrix && q.uniformMatrix3fv(k.normalMatrix, !1, e._normalMatrix.elements);
        null  !== k.modelMatrix && q.uniformMatrix4fv(k.modelMatrix, !1, e.matrixWorld.elements);
        return g
    }
    function x() {
        var a = 
        Ra;
        a >= fb && console.warn("WebGLRenderer: trying to use " + a + " texture units while this GPU supports only " + fb);
        Ra += 1;
        return a
    }
    function A(a, b, c, d) {
        a[b] = c.r * c.r * d;
        a[b + 1] = c.g * c.g * d;
        a[b + 2] = c.b * c.b * d
    }
    function y(a, b, c, d) {
        a[b] = c.r * d;
        a[b + 1] = c.g * d;
        a[b + 2] = c.b * d
    }
    function z(a) {
        a !== ka && (q.lineWidth(a),
        ka = a)
    }
    function E(a, b, c) {
        lb !== a && (a ? q.enable(q.POLYGON_OFFSET_FILL) : q.disable(q.POLYGON_OFFSET_FILL),
        lb = a);
        !a || ja === b && Ga === c || (q.polygonOffset(b, c),
        ja = b,
        Ga = c)
    }
    function C(a) {
        a = a.split("\n");
        for (var b = 0, c = a.length; b < 
        c; b++)
            a[b] = b + 1 + ": " + a[b];
        return a.join("\n")
    }
    function B(a, b) {
        var c;
        "fragment" === a ? c = q.createShader(q.FRAGMENT_SHADER) : "vertex" === a && (c = q.createShader(q.VERTEX_SHADER));
        q.shaderSource(c, b);
        q.compileShader(c);
        return q.getShaderParameter(c, q.COMPILE_STATUS) ? c : (console.error(q.getShaderInfoLog(c)),
        console.error(C(b)),
        null )
    }
    function K(a) {
        return 0 === (a & a - 1)
    }
    function F(a, b, c) {
        c ? (q.texParameteri(a, q.TEXTURE_WRAP_S, M(b.wrapS)),
        q.texParameteri(a, q.TEXTURE_WRAP_T, M(b.wrapT)),
        q.texParameteri(a, q.TEXTURE_MAG_FILTER, 
        M(b.magFilter)),
        q.texParameteri(a, q.TEXTURE_MIN_FILTER, M(b.minFilter))) : (q.texParameteri(a, q.TEXTURE_WRAP_S, q.CLAMP_TO_EDGE),
        q.texParameteri(a, q.TEXTURE_WRAP_T, q.CLAMP_TO_EDGE),
        q.texParameteri(a, q.TEXTURE_MAG_FILTER, O(b.magFilter)),
        q.texParameteri(a, q.TEXTURE_MIN_FILTER, O(b.minFilter)));
        Wa && b.type !== THREE.FloatType && (1 < b.anisotropy || b.__oldAnisotropy) && (q.texParameterf(a, Wa.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(b.anisotropy, ub)),
        b.__oldAnisotropy = b.anisotropy)
    }
    function O(a) {
        return a === THREE.NearestFilter || 
        a === THREE.NearestMipMapNearestFilter || a === THREE.NearestMipMapLinearFilter ? q.NEAREST : q.LINEAR
    }
    function M(a) {
        if (a === THREE.RepeatWrapping)
            return q.REPEAT;
        if (a === THREE.ClampToEdgeWrapping)
            return q.CLAMP_TO_EDGE;
        if (a === THREE.MirroredRepeatWrapping)
            return q.MIRRORED_REPEAT;
        if (a === THREE.NearestFilter)
            return q.NEAREST;
        if (a === THREE.NearestMipMapNearestFilter)
            return q.NEAREST_MIPMAP_NEAREST;
        if (a === THREE.NearestMipMapLinearFilter)
            return q.NEAREST_MIPMAP_LINEAR;
        if (a === THREE.LinearFilter)
            return q.LINEAR;
        if (a === 
        THREE.LinearMipMapNearestFilter)
            return q.LINEAR_MIPMAP_NEAREST;
        if (a === THREE.LinearMipMapLinearFilter)
            return q.LINEAR_MIPMAP_LINEAR;
        if (a === THREE.UnsignedByteType)
            return q.UNSIGNED_BYTE;
        if (a === THREE.UnsignedShort4444Type)
            return q.UNSIGNED_SHORT_4_4_4_4;
        if (a === THREE.UnsignedShort5551Type)
            return q.UNSIGNED_SHORT_5_5_5_1;
        if (a === THREE.UnsignedShort565Type)
            return q.UNSIGNED_SHORT_5_6_5;
        if (a === THREE.ByteType)
            return q.BYTE;
        if (a === THREE.ShortType)
            return q.SHORT;
        if (a === THREE.UnsignedShortType)
            return q.UNSIGNED_SHORT;
        if (a === THREE.IntType)
            return q.INT;
        if (a === THREE.UnsignedIntType)
            return q.UNSIGNED_INT;
        if (a === THREE.FloatType)
            return q.FLOAT;
        if (a === THREE.HalfFloatType)
            return 36193;
        if (a === THREE.AlphaFormat)
            return q.ALPHA;
        if (a === THREE.RGBFormat)
            return q.RGB;
        if (a === THREE.RGBAFormat)
            return q.RGBA;
        if (a === THREE.LuminanceFormat)
            return q.LUMINANCE;
        if (a === THREE.LuminanceAlphaFormat)
            return q.LUMINANCE_ALPHA;
        if (a === THREE.AddEquation)
            return q.FUNC_ADD;
        if (a === THREE.SubtractEquation)
            return q.FUNC_SUBTRACT;
        if (a === THREE.ReverseSubtractEquation)
            return q.FUNC_REVERSE_SUBTRACT;
        if (a === THREE.ZeroFactor)
            return q.ZERO;
        if (a === THREE.OneFactor)
            return q.ONE;
        if (a === THREE.SrcColorFactor)
            return q.SRC_COLOR;
        if (a === THREE.OneMinusSrcColorFactor)
            return q.ONE_MINUS_SRC_COLOR;
        if (a === THREE.SrcAlphaFactor)
            return q.SRC_ALPHA;
        if (a === THREE.OneMinusSrcAlphaFactor)
            return q.ONE_MINUS_SRC_ALPHA;
        if (a === THREE.DstAlphaFactor)
            return q.DST_ALPHA;
        if (a === THREE.OneMinusDstAlphaFactor)
            return q.ONE_MINUS_DST_ALPHA;
        if (a === THREE.DstColorFactor)
            return q.DST_COLOR;
        if (a === THREE.OneMinusDstColorFactor)
            return q.ONE_MINUS_DST_COLOR;
        if (a === THREE.SrcAlphaSaturateFactor)
            return q.SRC_ALPHA_SATURATE;
        if (void 0 !== Ha) {
            if (a === THREE.RGB_S3TC_DXT1_Format)
                return Ha.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT1_Format)
                return Ha.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (a === THREE.RGBA_S3TC_DXT3_Format)
                return Ha.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (a === THREE.RGBA_S3TC_DXT5_Format)
                return Ha.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
        return 0
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION);
    a = a || {};
    var G = void 0 !== a.canvas ? a.canvas : document.createElement("canvas")
      , 
    Q = void 0 !== a.precision ? a.precision : "highp"
      , R = void 0 !== a.alpha ? a.alpha : !1
      , S = void 0 !== a.premultipliedAlpha ? a.premultipliedAlpha : !0
      , U = void 0 !== a.antialias ? a.antialias : !1
      , H = void 0 !== a.stencil ? a.stencil : !0
      , Z = void 0 !== a.preserveDrawingBuffer ? a.preserveDrawingBuffer : !1
      , N = new THREE.Color(0)
      , ca = 0;
    this.domElement = G;
    this.context = null ;
    this.devicePixelRatio = void 0 !== a.devicePixelRatio ? a.devicePixelRatio : void 0 !== self.devicePixelRatio ? self.devicePixelRatio : 1;
    this.autoUpdateObjects = this.sortObjects = this.autoClearStencil = 
    this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    this.shadowMapEnabled = this.gammaOutput = this.gammaInput = !1;
    this.shadowMapAutoUpdate = !0;
    this.shadowMapType = THREE.PCFShadowMap;
    this.shadowMapCullFace = THREE.CullFaceFront;
    this.shadowMapCascade = this.shadowMapDebug = !1;
    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;
    this.autoScaleCubemaps = !0;
    this.renderPluginsPre = [];
    this.renderPluginsPost = [];
    this.info = {
        memory: {
            programs: 0,
            geometries: 0,
            textures: 0
        },
        render: {
            calls: 0,
            vertices: 0,
            faces: 0,
            points: 0
        }
    };
    var J = this
      , 
    Y = []
      , P = 0
      , fa = null 
      , ia = null 
      , aa = -1
      , oa = null 
      , ya = null 
      , Da = 0
      , Ra = 0
      , ma = -1
      , Ka = -1
      , za = -1
      , La = -1
      , Sa = -1
      , ab = -1
      , Za = -1
      , Ta = -1
      , lb = null 
      , ja = null 
      , Ga = null 
      , ka = null 
      , ta = 0
      , ua = 0
      , na = G.width
      , va = G.height
      , pa = 0
      , Aa = 0
      , wa = []
      , xa = {}
      , $a = new THREE.Frustum
      , ra = new THREE.Matrix4;
    new THREE.Matrix4;
    var ba = new THREE.Vector3, ga = new THREE.Vector3, Va = !0, nb = {
        ambient: [0, 0, 0],
        directional: {
            length: 0,
            colors: [],
            positions: []
        },
        point: {
            length: 0,
            colors: [],
            positions: [],
            distances: []
        },
        spot: {
            length: 0,
            colors: [],
            positions: [],
            distances: [],
            directions: [],
            anglesCos: [],
            exponents: []
        },
        hemi: {
            length: 0,
            skyColors: [],
            groundColors: [],
            positions: []
        }
    }, q, Ua, vb, Xa, Wa, Ha, Ba;
    (function() {
        try {
            var a = {
                alpha: R,
                premultipliedAlpha: S,
                antialias: U,
                stencil: H,
                preserveDrawingBuffer: Z
            };
            q = G.getContext("webgl", a) || G.getContext("experimental-webgl", a);
            if (null  === q)
                throw "Error creating WebGL context.";
        } catch (b) {
            console.error(b)
        }
        Ua = q.getExtension("OES_texture_float");
        vb = q.getExtension("OES_texture_half_float");
        q.getExtension("OES_texture_float_linear");
        Xa = q.getExtension("OES_standard_derivatives");
        Ba = q.getExtension("WEBGL_draw_buffers");
        Wa = q.getExtension("EXT_texture_filter_anisotropic") || q.getExtension("MOZ_EXT_texture_filter_anisotropic") || q.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        Ha = q.getExtension("WEBGL_compressed_texture_s3tc") || q.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || q.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        Ua || console.log("THREE.WebGLRenderer: Float textures not supported.");
        vb || console.log("THREE.WebGLRenderer: Half float textures not supported.");
        Xa || console.log("THREE.WebGLRenderer: Standard derivatives not supported.");
        Wa || console.log("THREE.WebGLRenderer: Anisotropic texture filtering not supported.");
        Ha || console.log("THREE.WebGLRenderer: S3TC compressed textures not supported.");
        Ba || console.log("THREE.WebGLRenderer: Multiple render targets not supported.");
        void 0 === q.getShaderPrecisionFormat && (q.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }
        )
    }
    )();
    q.clearColor(0, 0, 0, 1);
    q.clearDepth(1);
    q.clearStencil(0);
    q.enable(q.DEPTH_TEST);
    q.depthFunc(q.LEQUAL);
    q.frontFace(q.CCW);
    q.cullFace(q.BACK);
    q.enable(q.CULL_FACE);
    q.enable(q.BLEND);
    q.blendEquation(q.FUNC_ADD);
    q.blendFunc(q.SRC_ALPHA, q.ONE_MINUS_SRC_ALPHA);
    q.viewport(ta, ua, na, va);
    q.clearColor(N.r, N.g, N.b, ca);
    this.context = q;
    var fb = q.getParameter(q.MAX_TEXTURE_IMAGE_UNITS);
    a = q.getParameter(q.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    q.getParameter(q.MAX_TEXTURE_SIZE);
    var yb = q.getParameter(q.MAX_CUBE_MAP_TEXTURE_SIZE)
      , ub = Wa ? q.getParameter(Wa.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
      , cb = 0 < a
      , zb = cb && 
    Ua;
    Ha && q.getParameter(q.COMPRESSED_TEXTURE_FORMATS);
    var gb = q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.HIGH_FLOAT);
    a = q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.MEDIUM_FLOAT);
    q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.LOW_FLOAT);
    var Ab = q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.HIGH_FLOAT)
      , Bb = q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.MEDIUM_FLOAT);
    q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.LOW_FLOAT);
    q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.HIGH_INT);
    q.getShaderPrecisionFormat(q.VERTEX_SHADER, 
    q.MEDIUM_INT);
    q.getShaderPrecisionFormat(q.VERTEX_SHADER, q.LOW_INT);
    q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.HIGH_INT);
    q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.MEDIUM_INT);
    q.getShaderPrecisionFormat(q.FRAGMENT_SHADER, q.LOW_INT);
    gb = 0 < gb.precision && 0 < Ab.precision;
    a = 0 < a.precision && 0 < Bb.precision;
    "highp" !== Q || gb || (a ? (Q = "mediump",
    console.warn("WebGLRenderer: highp not supported, using mediump")) : (Q = "lowp",
    console.warn("WebGLRenderer: highp and mediump not supported, using lowp")));
    "mediump" !== 
    Q || a || (Q = "lowp",
    console.warn("WebGLRenderer: mediump not supported, using lowp"));
    this.getContext = function() {
        return q
    }
    ;
    this.supportsVertexTextures = function() {
        return cb
    }
    ;
    this.supportsFloatTextures = function() {
        return Ua
    }
    ;
    this.supportsStandardDerivatives = function() {
        return Xa
    }
    ;
    this.supportsCompressedTextureS3TC = function() {
        return Ha
    }
    ;
    this.supportsMRT = function() {
        return Ba
    }
    ;
    this.getMaxAnisotropy = function() {
        return ub
    }
    ;
    this.getPrecision = function() {
        return Q
    }
    ;
    this.setSize = function(a, b, c) {
        G.width = a * this.devicePixelRatio;
        G.height = b * this.devicePixelRatio;
        1 !== this.devicePixelRatio && !1 !== c && (G.style.width = a + "px",
        G.style.height = b + "px");
        this.setViewport(0, 0, a, b)
    }
    ;
    this.setViewport = function(a, b, c, d) {
        ta = a * this.devicePixelRatio;
        ua = b * this.devicePixelRatio;
        na = c * this.devicePixelRatio;
        va = d * this.devicePixelRatio;
        q.viewport(ta, ua, na, va)
    }
    ;
    this.setScissor = function(a, b, c, d) {
        q.scissor(a, b, c, d)
    }
    ;
    this.enableScissorTest = function(a) {
        a ? q.enable(q.SCISSOR_TEST) : q.disable(q.SCISSOR_TEST)
    }
    ;
    this.setClearColor = function(a, b) {
        N.set(a);
        ca = void 0 !== 
        b ? b : 1;
        q.clearColor(N.r, N.g, N.b, ca)
    }
    ;
    this.setClearColorHex = function(a, b) {
        console.warn("DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.");
        this.setClearColor(a, b)
    }
    ;
    this.getClearColor = function() {
        return N
    }
    ;
    this.getClearAlpha = function() {
        return ca
    }
    ;
    this.clear = function(a, b, c) {
        var d = 0;
        if (void 0 === a || a)
            d |= q.COLOR_BUFFER_BIT;
        if (void 0 === b || b)
            d |= q.DEPTH_BUFFER_BIT;
        if (void 0 === c || c)
            d |= q.STENCIL_BUFFER_BIT;
        q.clear(d)
    }
    ;
    this.clearColor = function() {
        q.clear(q.COLOR_BUFFER_BIT)
    }
    ;
    this.clearDepth = 
    function() {
        q.clear(q.DEPTH_BUFFER_BIT)
    }
    ;
    this.clearStencil = function() {
        q.clear(q.STENCIL_BUFFER_BIT)
    }
    ;
    this.clearTarget = function(a, b, c, d) {
        this.setRenderTarget(a);
        this.clear(b, c, d)
    }
    ;
    this.addPostPlugin = function(a) {
        a.init(this);
        this.renderPluginsPost.push(a)
    }
    ;
    this.addPrePlugin = function(a) {
        a.init(this);
        this.renderPluginsPre.push(a)
    }
    ;
    this.updateShadowMap = function(a, b) {
        fa = null ;
        aa = oa = Ta = Za = za = -1;
        Va = !0;
        Ka = ma = -1;
        this.shadowMapPlugin.update(a, b)
    }
    ;
    var eb = function(a) {
        a = a.target;
        a.removeEventListener("dispose", eb);
        a.__webglInit = void 0;
        if (a instanceof THREE.BufferGeometry) {
            void 0 !== a.vbbuffer && q.deleteBuffer(a.vbbuffer);
            var b = a.attributes, c;
            for (c in b)
                void 0 !== b[c].buffer && q.deleteBuffer(b[c].buffer);
            J.info.memory.geometries--
        } else if (void 0 !== a.geometryGroups)
            for (b in a.geometryGroups)
                wb(a.geometryGroups[b]);
        else
            wb(a)
    }
      , bb = function(a) {
        a = a.target;
        a.removeEventListener("dispose", bb);
        a.image && a.image.__webglTextureCube ? q.deleteTexture(a.image.__webglTextureCube) : a.__webglInit && (a.__webglInit = !1,
        q.deleteTexture(a.__webglTexture));
        J.info.memory.textures--
    }
      , hb = function(a) {
        a = a.target;
        a.removeEventListener("dispose", hb);
        a && a.__webglTexture && (q.deleteTexture(a.__webglTexture),
        q.deleteFramebuffer(a.__webglFramebuffer),
        q.deleteRenderbuffer(a.__webglRenderbuffer));
        J.info.memory.textures--
    }
      , xb = function(a) {
        a = a.target;
        a.removeEventListener("dispose", xb);
        mb(a)
    }
      , wb = function(a) {
        void 0 !== a.__webglVertexBuffer && q.deleteBuffer(a.__webglVertexBuffer);
        void 0 !== a.__webglNormalBuffer && q.deleteBuffer(a.__webglNormalBuffer);
        void 0 !== a.__webglTangentBuffer && 
        q.deleteBuffer(a.__webglTangentBuffer);
        void 0 !== a.__webglColorBuffer && q.deleteBuffer(a.__webglColorBuffer);
        void 0 !== a.__webglUVBuffer && q.deleteBuffer(a.__webglUVBuffer);
        void 0 !== a.__webglUV2Buffer && q.deleteBuffer(a.__webglUV2Buffer);
        void 0 !== a.__webglSkinIndicesBuffer && q.deleteBuffer(a.__webglSkinIndicesBuffer);
        void 0 !== a.__webglSkinWeightsBuffer && q.deleteBuffer(a.__webglSkinWeightsBuffer);
        void 0 !== a.__webglFaceBuffer && q.deleteBuffer(a.__webglFaceBuffer);
        void 0 !== a.__webglLineBuffer && q.deleteBuffer(a.__webglLineBuffer);
        void 0 !== a.__webglLineDistanceBuffer && q.deleteBuffer(a.__webglLineDistanceBuffer);
        if (void 0 !== a.__webglCustomAttributesList)
            for (var b in a.__webglCustomAttributesList)
                q.deleteBuffer(a.__webglCustomAttributesList[b].buffer);
        J.info.memory.geometries--
    }
      , mb = function(a) {
        var b = a.program;
        if (void 0 !== b) {
            a.program = void 0;
            var c, d, e = !1;
            a = 0;
            for (c = Y.length; a < c; a++)
                if (d = Y[a],
                d.program === b) {
                    d.usedTimes--;
                    0 === d.usedTimes && (e = !0);
                    break
                }
            if (!0 === e) {
                e = [];
                a = 0;
                for (c = Y.length; a < c; a++)
                    d = Y[a],
                    d.program !== b && e.push(d);
                Y = e;
                q.deleteProgram(b);
                J.info.memory.programs--
            }
        }
    }
    ;
    this.renderBufferDirect = function(a, b, c, d, e, k) {
        if (!1 !== d.visible) {
            var l = w(a, b, c, d, k);
            a = l.attributes;
            c = e.attributes;
            b = !1;
            l = 16777215 * e.id + 2 * l.id + (d.wireframe ? 1 : 0);
            l !== oa && (oa = l,
            b = !0);
            b && h();
            if (k instanceof THREE.Mesh)
                if (k = c.index) {
                    l = e.offsets;
                    1 < l.length && (b = !0);
                    for (var m = 0, n = l.length; m < n; m++) {
                        var p = l[m].index;
                        b && (g(d, a, e, p),
                        !k.buffer && e.streamingDraw ? (p = xa.index,
                        p || (p = q.createBuffer(),
                        xa.index = p),
                        q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, p),
                        q.bufferData(q.ELEMENT_ARRAY_BUFFER, 
                        k.array, q.STATIC_DRAW)) : q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, k.buffer));
                        q.drawElements(q.TRIANGLES, l[m].count, q.UNSIGNED_SHORT, 2 * l[m].start)
                    }
                } else
                    b && g(d, a, e, p),
                    d = e.attributes.position,
                    q.drawArrays(q.TRIANGLES, 0, d.array.length / 3);
            else if (k instanceof THREE.Line)
                if (p = k.type === THREE.LineStrip ? q.LINE_STRIP : q.LINES,
                z(d.linewidth),
                k = c.index)
                    for (l = e.offsets,
                    1 < l.length && (b = !0),
                    m = 0,
                    n = l.length; m < n; m++)
                        p = l[m].index,
                        b && (f(d, a, c, p),
                        q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, k.buffer)),
                        q.drawElements(q.LINES, l[m].count, 
                        q.UNSIGNED_SHORT, 2 * l[m].start);
                else
                    b && f(d, a, c, 0),
                    d = c.position,
                    q.drawArrays(p, 0, d.array.length / 3)
        }
    }
    ;
    this.renderBuffer = function(a, b, c, d, e, f) {
        if (!1 !== d.visible) {
            var g, l;
            c = w(a, b, c, d, f);
            a = c.attributes;
            b = !1;
            c = 16777215 * e.id + 2 * c.id + (d.wireframe ? 1 : 0);
            c !== oa && (oa = c,
            b = !0);
            b && h();
            !d.morphTargets && 0 <= a.position && b && (q.bindBuffer(q.ARRAY_BUFFER, e.__webglVertexBuffer),
            k(a.position),
            q.vertexAttribPointer(a.position, 3, q.FLOAT, !1, 0, 0));
            if (b) {
                if (e.__webglCustomAttributesList)
                    for (g = 0,
                    l = e.__webglCustomAttributesList.length; g < 
                    l; g++)
                        c = e.__webglCustomAttributesList[g],
                        0 <= a[c.buffer.belongsToAttribute] && (q.bindBuffer(q.ARRAY_BUFFER, c.buffer),
                        k(a[c.buffer.belongsToAttribute]),
                        q.vertexAttribPointer(a[c.buffer.belongsToAttribute], c.size, q.FLOAT, !1, 0, 0));
                0 <= a.color && (0 < f.geometry.colors.length || 0 < f.geometry.faces.length ? (q.bindBuffer(q.ARRAY_BUFFER, e.__webglColorBuffer),
                k(a.color),
                q.vertexAttribPointer(a.color, 3, q.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && q.vertexAttrib3fv(a.color, d.defaultAttributeValues.color));
                0 <= a.normal && 
                (q.bindBuffer(q.ARRAY_BUFFER, e.__webglNormalBuffer),
                k(a.normal),
                q.vertexAttribPointer(a.normal, 3, q.FLOAT, !1, 0, 0));
                0 <= a.tangent && (q.bindBuffer(q.ARRAY_BUFFER, e.__webglTangentBuffer),
                k(a.tangent),
                q.vertexAttribPointer(a.tangent, 4, q.FLOAT, !1, 0, 0));
                0 <= a.uv && (f.geometry.faceVertexUvs[0] ? (q.bindBuffer(q.ARRAY_BUFFER, e.__webglUVBuffer),
                k(a.uv),
                q.vertexAttribPointer(a.uv, 2, q.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && q.vertexAttrib2fv(a.uv, d.defaultAttributeValues.uv));
                0 <= a.uv2 && (f.geometry.faceVertexUvs[1] ? 
                (q.bindBuffer(q.ARRAY_BUFFER, e.__webglUV2Buffer),
                k(a.uv2),
                q.vertexAttribPointer(a.uv2, 2, q.FLOAT, !1, 0, 0)) : d.defaultAttributeValues && q.vertexAttrib2fv(a.uv2, d.defaultAttributeValues.uv2));
                0 <= a.lineDistance && (q.bindBuffer(q.ARRAY_BUFFER, e.__webglLineDistanceBuffer),
                k(a.lineDistance),
                q.vertexAttribPointer(a.lineDistance, 1, q.FLOAT, !1, 0, 0))
            }
            f instanceof THREE.Mesh ? d.wireframe ? (z(d.wireframeLinewidth),
            b && q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, e.__webglLineBuffer),
            q.drawElements(q.LINES, e.__webglLineCount, q.UNSIGNED_SHORT, 
            0)) : (b && q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, e.__webglFaceBuffer),
            q.drawElements(q.TRIANGLES, e.__webglFaceCount, q.UNSIGNED_SHORT, 0)) : f instanceof THREE.Line && (f = f.type === THREE.LineStrip ? q.LINE_STRIP : q.LINES,
            z(d.linewidth),
            q.drawArrays(f, 0, e.__webglLineCount))
        }
    }
    ;
    this.render = function(a, b, c, d) {
        if (!1 === b instanceof THREE.Camera)
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        else {
            var e, f, g, h, k = a.__lights, p = a.fog;
            aa = -1;
            Va = !0;
            !0 === a.autoUpdate && a.updateMatrixWorld();
            void 0 === b.parent && b.updateMatrixWorld();
            b.matrixWorldInverse.getInverse(b.matrixWorld);
            ra.multiplyMatrices(b.projectionMatrix, b.matrixWorldInverse);
            $a.setFromMatrix(ra);
            this.autoUpdateObjects && this.initWebGLObjects(a);
            m(this.renderPluginsPre, a, b);
            this.setRenderTarget(c);
            (this.autoClear || d) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
            h = a.__webglObjects;
            d = 0;
            for (e = h.length; d < e; d++)
                if (f = h[d],
                g = f.object,
                f.id = d,
                f.render = !1,
                g.visible && (!(g instanceof THREE.Mesh && g.frustumCulled) || 
                $a.intersectsObject(g))) {
                    var r = g;
                    r._modelViewMatrix.multiplyMatrices(b.matrixWorldInverse, r.matrixWorld);
                    r._normalMatrix.getNormalMatrix(r._modelViewMatrix);
                    var r = f
                      , t = r.object
                      , w = r.buffer
                      , u = t.geometry
                      , t = t.material;
                    t instanceof THREE.MeshFaceMaterial ? (t = t.materials[u instanceof THREE.BufferGeometry ? 0 : w.materialIndex],
                    t.transparent ? (r.transparent = t,
                    r.opaque = null ) : (r.opaque = t,
                    r.transparent = null )) : t && (t.transparent ? (r.transparent = t,
                    r.opaque = null ) : (r.opaque = t,
                    r.transparent = null ));
                    f.render = !0;
                    !0 === this.sortObjects && 
                    (null  !== g.renderDepth ? f.z = g.renderDepth : (ba.setFromMatrixPosition(g.matrixWorld),
                    ba.applyProjection(ra),
                    f.z = ba.z))
                }
            this.sortObjects && h.sort(l);
            a.overrideMaterial ? (d = a.overrideMaterial,
            this.setBlending(d.blending, d.blendEquation, d.blendSrc, d.blendDst),
            this.setDepthTest(d.depthTest),
            this.setDepthWrite(d.depthWrite),
            E(d.polygonOffset, d.polygonOffsetFactor, d.polygonOffsetUnits),
            n(a.__webglObjects, !1, "", b, k, p, !0, d)) : (d = null ,
            this.setBlending(THREE.NoBlending),
            n(a.__webglObjects, !0, "opaque", b, k, p, !1, d),
            n(a.__webglObjects, !1, "transparent", b, k, p, !0, d));
            m(this.renderPluginsPost, a, b);
            c && c.generateMipmaps && c.minFilter !== THREE.NearestFilter && c.minFilter !== THREE.LinearFilter && (q.bindTexture(q.TEXTURE_2D, c.__webglTexture),
            q.generateMipmap(q.TEXTURE_2D),
            q.bindTexture(q.TEXTURE_2D, null ));
            this.setDepthTest(!0);
            this.setDepthWrite(!0)
        }
    }
    ;
    this.endFrame = function() {}
    ;
    this.initWebGLObjects = function(a) {
        a.__webglObjects || (a.__webglObjects = []);
        for (; a.__objectsAdded.length; )
            p(a.__objectsAdded[0], a),
            a.__objectsAdded.splice(0, 
            1);
        for (; a.__objectsRemoved.length; )
            u(a.__objectsRemoved[0], a),
            a.__objectsRemoved.splice(0, 1);
        for (var f = 0, g = a.__webglObjects.length; f < g; f++) {
            var h = a.__webglObjects[f].object;
            void 0 === h.__webglInit && (void 0 !== h.__webglActive && u(h, a),
            p(h, a));
            var k = h
              , l = k.geometry
              , m = void 0
              , n = void 0
              , t = void 0;
            if (l instanceof THREE.BufferGeometry) {
                var w = l
                  , x = q.DYNAMIC_DRAW
                  , y = l.freeCPUBuffers;
                if (!w.streamingDraw) {
                    var A = w.attributes
                      , z = !1
                      , E = void 0
                      , C = void 0;
                    for (E in A)
                        C = A[E],
                        C.needsUpdate && ("index" === E ? (q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, 
                        C.buffer),
                        q.bufferData(q.ELEMENT_ARRAY_BUFFER, C.array, x)) : C.array ? (q.bindBuffer(q.ARRAY_BUFFER, C.buffer),
                        q.bufferData(q.ARRAY_BUFFER, C.array, x)) : z = !0,
                        C.needsUpdate = !1),
                        y && C.freeCPUBuffers && (C.array = null );
                    z && (q.bindBuffer(q.ARRAY_BUFFER, w.vbbuffer),
                    q.bufferData(q.ARRAY_BUFFER, w.vb, x),
                    y && w.freeCPUBuffers && (w.vb = null ))
                }
            } else if (k instanceof THREE.Mesh) {
                for (var F = 0, G = l.geometryGroupsList.length; F < G; F++)
                    if (m = l.geometryGroupsList[F],
                    t = c(k, m),
                    l.buffersNeedUpdate && b(m, k),
                    n = t.attributes && v(t),
                    l.verticesNeedUpdate || 
                    l.morphTargetsNeedUpdate || l.elementsNeedUpdate || l.uvsNeedUpdate || l.normalsNeedUpdate || l.colorsNeedUpdate || l.tangentsNeedUpdate || n) {
                        var B = m
                          , K = k
                          , H = q.DYNAMIC_DRAW
                          , M = l.freeCPUBuffers
                          , O = t;
                        if (B.__inittedArrays) {
                            var P = e(O)
                              , Q = O.vertexColors ? O.vertexColors : !1
                              , R = d(O)
                              , S = P === THREE.SmoothShading
                              , T = void 0
                              , J = void 0
                              , U = void 0
                              , N = void 0
                              , Y = void 0
                              , Z = void 0
                              , aa = void 0
                              , ca = void 0
                              , ba = void 0
                              , fa = void 0
                              , ia = void 0
                              , X = void 0
                              , W = void 0
                              , V = void 0
                              , ga = void 0
                              , ja = void 0
                              , ka = void 0
                              , oa = void 0
                              , pa = void 0
                              , ra = void 0
                              , sa = void 0
                              , ya = void 0
                              , ua = void 0
                              , 
                            va = void 0
                              , wa = void 0
                              , ma = 0
                              , na = 0
                              , xa = 0
                              , Aa = 0
                              , Ba = 0
                              , Oa = 0
                              , Fa = 0
                              , ta = 0
                              , Ma = 0
                              , I = 0
                              , Ea = void 0
                              , Pa = B.__vertexArray
                              , Ha = B.__uvArray
                              , Ka = B.__uv2Array
                              , za = B.__normalArray
                              , Ia = B.__tangentArray
                              , Qa = B.__colorArray
                              , La = B.__webglCustomAttributesList
                              , D = void 0
                              , Ga = B.__faceArray
                              , Da = B.__lineArray
                              , Na = K.geometry
                              , Ra = Na.elementsNeedUpdate
                              , Sa = Na.uvsNeedUpdate
                              , Va = Na.normalsNeedUpdate
                              , Wa = Na.tangentsNeedUpdate
                              , Za = Na.colorsNeedUpdate
                              , Ta = Na.vertices
                              , da = B.faces3
                              , Ya = Na.faces
                              , Xa = Na.faceVertexUvs[0]
                              , $a = Na.faceVertexUvs[1];
                            if (Na.verticesNeedUpdate) {
                                T = 
                                0;
                                for (J = da.length; T < J; T++)
                                    N = Ya[da[T]],
                                    X = Ta[N.a],
                                    W = Ta[N.b],
                                    V = Ta[N.c],
                                    Pa[na] = X.x,
                                    Pa[na + 1] = X.y,
                                    Pa[na + 2] = X.z,
                                    Pa[na + 3] = W.x,
                                    Pa[na + 4] = W.y,
                                    Pa[na + 5] = W.z,
                                    Pa[na + 6] = V.x,
                                    Pa[na + 7] = V.y,
                                    Pa[na + 8] = V.z,
                                    na += 9;
                                q.bindBuffer(q.ARRAY_BUFFER, B.__webglVertexBuffer);
                                q.bufferData(q.ARRAY_BUFFER, Pa, H)
                            }
                            if (Za && Q) {
                                T = 0;
                                for (J = da.length; T < J; T++)
                                    N = Ya[da[T]],
                                    aa = N.vertexColors,
                                    ca = N.color,
                                    3 === aa.length && Q === THREE.VertexColors ? (oa = aa[0],
                                    pa = aa[1],
                                    ra = aa[2]) : ra = pa = oa = ca,
                                    Qa[Ma] = oa.r,
                                    Qa[Ma + 1] = oa.g,
                                    Qa[Ma + 2] = oa.b,
                                    Qa[Ma + 3] = pa.r,
                                    Qa[Ma + 4] = pa.g,
                                    Qa[Ma + 
                                    5] = pa.b,
                                    Qa[Ma + 6] = ra.r,
                                    Qa[Ma + 7] = ra.g,
                                    Qa[Ma + 8] = ra.b,
                                    Ma += 9;
                                0 < Ma && (q.bindBuffer(q.ARRAY_BUFFER, B.__webglColorBuffer),
                                q.bufferData(q.ARRAY_BUFFER, Qa, H))
                            }
                            if (Wa && Na.hasTangents) {
                                T = 0;
                                for (J = da.length; T < J; T++)
                                    N = Ya[da[T]],
                                    ba = N.vertexTangents,
                                    ga = ba[0],
                                    ja = ba[1],
                                    ka = ba[2],
                                    Ia[Fa] = ga.x,
                                    Ia[Fa + 1] = ga.y,
                                    Ia[Fa + 2] = ga.z,
                                    Ia[Fa + 3] = ga.w,
                                    Ia[Fa + 4] = ja.x,
                                    Ia[Fa + 5] = ja.y,
                                    Ia[Fa + 6] = ja.z,
                                    Ia[Fa + 7] = ja.w,
                                    Ia[Fa + 8] = ka.x,
                                    Ia[Fa + 9] = ka.y,
                                    Ia[Fa + 10] = ka.z,
                                    Ia[Fa + 11] = ka.w,
                                    Fa += 12;
                                q.bindBuffer(q.ARRAY_BUFFER, B.__webglTangentBuffer);
                                q.bufferData(q.ARRAY_BUFFER, 
                                Ia, H)
                            }
                            if (Va && P) {
                                T = 0;
                                for (J = da.length; T < J; T++)
                                    if (N = Ya[da[T]],
                                    Y = N.vertexNormals,
                                    Z = N.normal,
                                    3 === Y.length && S)
                                        for (sa = 0; 3 > sa; sa++)
                                            ua = Y[sa],
                                            za[Oa] = ua.x,
                                            za[Oa + 1] = ua.y,
                                            za[Oa + 2] = ua.z,
                                            Oa += 3;
                                    else
                                        for (sa = 0; 3 > sa; sa++)
                                            za[Oa] = Z.x,
                                            za[Oa + 1] = Z.y,
                                            za[Oa + 2] = Z.z,
                                            Oa += 3;
                                q.bindBuffer(q.ARRAY_BUFFER, B.__webglNormalBuffer);
                                q.bufferData(q.ARRAY_BUFFER, za, H)
                            }
                            if (Sa && Xa && R) {
                                T = 0;
                                for (J = da.length; T < J; T++)
                                    if (U = da[T],
                                    fa = Xa[U],
                                    void 0 !== fa)
                                        for (sa = 0; 3 > sa; sa++)
                                            va = fa[sa],
                                            Ha[xa] = va.x,
                                            Ha[xa + 1] = va.y,
                                            xa += 2;
                                0 < xa && (q.bindBuffer(q.ARRAY_BUFFER, B.__webglUVBuffer),
                                q.bufferData(q.ARRAY_BUFFER, Ha, H))
                            }
                            if (Sa && $a && R) {
                                T = 0;
                                for (J = da.length; T < J; T++)
                                    if (U = da[T],
                                    ia = $a[U],
                                    void 0 !== ia)
                                        for (sa = 0; 3 > sa; sa++)
                                            wa = ia[sa],
                                            Ka[Aa] = wa.x,
                                            Ka[Aa + 1] = wa.y,
                                            Aa += 2;
                                0 < Aa && (q.bindBuffer(q.ARRAY_BUFFER, B.__webglUV2Buffer),
                                q.bufferData(q.ARRAY_BUFFER, Ka, H))
                            }
                            if (Ra) {
                                T = 0;
                                for (J = da.length; T < J; T++)
                                    Ga[Ba] = ma,
                                    Ga[Ba + 1] = ma + 1,
                                    Ga[Ba + 2] = ma + 2,
                                    Ba += 3,
                                    Da[ta] = ma,
                                    Da[ta + 1] = ma + 1,
                                    Da[ta + 2] = ma,
                                    Da[ta + 3] = ma + 2,
                                    Da[ta + 4] = ma + 1,
                                    Da[ta + 5] = ma + 2,
                                    ta += 6,
                                    ma += 3;
                                q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, B.__webglFaceBuffer);
                                q.bufferData(q.ELEMENT_ARRAY_BUFFER, 
                                Ga, H);
                                q.bindBuffer(q.ELEMENT_ARRAY_BUFFER, B.__webglLineBuffer);
                                q.bufferData(q.ELEMENT_ARRAY_BUFFER, Da, H)
                            }
                            if (La)
                                for (sa = 0,
                                ya = La.length; sa < ya; sa++)
                                    if (D = La[sa],
                                    D.__original.needsUpdate) {
                                        I = 0;
                                        if (1 === D.size)
                                            if (void 0 === D.boundTo || "vertices" === D.boundTo)
                                                for (T = 0,
                                                J = da.length; T < J; T++)
                                                    N = Ya[da[T]],
                                                    D.array[I] = D.value[N.a],
                                                    D.array[I + 1] = D.value[N.b],
                                                    D.array[I + 2] = D.value[N.c],
                                                    I += 3;
                                            else {
                                                if ("faces" === D.boundTo)
                                                    for (T = 0,
                                                    J = da.length; T < J; T++)
                                                        Ea = D.value[da[T]],
                                                        D.array[I] = Ea,
                                                        D.array[I + 1] = Ea,
                                                        D.array[I + 2] = Ea,
                                                        I += 3
                                            }
                                        else if (2 === 
                                        D.size)
                                            if (void 0 === D.boundTo || "vertices" === D.boundTo)
                                                for (T = 0,
                                                J = da.length; T < J; T++)
                                                    N = Ya[da[T]],
                                                    X = D.value[N.a],
                                                    W = D.value[N.b],
                                                    V = D.value[N.c],
                                                    D.array[I] = X.x,
                                                    D.array[I + 1] = X.y,
                                                    D.array[I + 2] = W.x,
                                                    D.array[I + 3] = W.y,
                                                    D.array[I + 4] = V.x,
                                                    D.array[I + 5] = V.y,
                                                    I += 6;
                                            else {
                                                if ("faces" === D.boundTo)
                                                    for (T = 0,
                                                    J = da.length; T < J; T++)
                                                        V = W = X = Ea = D.value[da[T]],
                                                        D.array[I] = X.x,
                                                        D.array[I + 1] = X.y,
                                                        D.array[I + 2] = W.x,
                                                        D.array[I + 3] = W.y,
                                                        D.array[I + 4] = V.x,
                                                        D.array[I + 5] = V.y,
                                                        I += 6
                                            }
                                        else if (3 === D.size) {
                                            var la;
                                            la = "c" === D.type ? ["r", "g", "b"] : ["x", "y", "z"];
                                            if (void 0 === 
                                            D.boundTo || "vertices" === D.boundTo)
                                                for (T = 0,
                                                J = da.length; T < J; T++)
                                                    N = Ya[da[T]],
                                                    X = D.value[N.a],
                                                    W = D.value[N.b],
                                                    V = D.value[N.c],
                                                    D.array[I] = X[la[0]],
                                                    D.array[I + 1] = X[la[1]],
                                                    D.array[I + 2] = X[la[2]],
                                                    D.array[I + 3] = W[la[0]],
                                                    D.array[I + 4] = W[la[1]],
                                                    D.array[I + 5] = W[la[2]],
                                                    D.array[I + 6] = V[la[0]],
                                                    D.array[I + 7] = V[la[1]],
                                                    D.array[I + 8] = V[la[2]],
                                                    I += 9;
                                            else if ("faces" === D.boundTo)
                                                for (T = 0,
                                                J = da.length; T < J; T++)
                                                    V = W = X = Ea = D.value[da[T]],
                                                    D.array[I] = X[la[0]],
                                                    D.array[I + 1] = X[la[1]],
                                                    D.array[I + 2] = X[la[2]],
                                                    D.array[I + 3] = W[la[0]],
                                                    D.array[I + 4] = W[la[1]],
                                                    D.array[I + 5] = W[la[2]],
                                                    D.array[I + 6] = V[la[0]],
                                                    D.array[I + 7] = V[la[1]],
                                                    D.array[I + 8] = V[la[2]],
                                                    I += 9;
                                            else if ("faceVertices" === D.boundTo)
                                                for (T = 0,
                                                J = da.length; T < J; T++)
                                                    Ea = D.value[da[T]],
                                                    X = Ea[0],
                                                    W = Ea[1],
                                                    V = Ea[2],
                                                    D.array[I] = X[la[0]],
                                                    D.array[I + 1] = X[la[1]],
                                                    D.array[I + 2] = X[la[2]],
                                                    D.array[I + 3] = W[la[0]],
                                                    D.array[I + 4] = W[la[1]],
                                                    D.array[I + 5] = W[la[2]],
                                                    D.array[I + 6] = V[la[0]],
                                                    D.array[I + 7] = V[la[1]],
                                                    D.array[I + 8] = V[la[2]],
                                                    I += 9
                                        } else if (4 === D.size)
                                            if (void 0 === D.boundTo || "vertices" === D.boundTo)
                                                for (T = 0,
                                                J = da.length; T < J; T++)
                                                    N = Ya[da[T]],
                                                    X = D.value[N.a],
                                                    W = D.value[N.b],
                                                    V = D.value[N.c],
                                                    D.array[I] = X.x,
                                                    D.array[I + 1] = X.y,
                                                    D.array[I + 2] = X.z,
                                                    D.array[I + 3] = X.w,
                                                    D.array[I + 4] = W.x,
                                                    D.array[I + 5] = W.y,
                                                    D.array[I + 6] = W.z,
                                                    D.array[I + 7] = W.w,
                                                    D.array[I + 8] = V.x,
                                                    D.array[I + 9] = V.y,
                                                    D.array[I + 10] = V.z,
                                                    D.array[I + 11] = V.w,
                                                    I += 12;
                                            else if ("faces" === D.boundTo)
                                                for (T = 0,
                                                J = da.length; T < J; T++)
                                                    V = W = X = Ea = D.value[da[T]],
                                                    D.array[I] = X.x,
                                                    D.array[I + 1] = X.y,
                                                    D.array[I + 2] = X.z,
                                                    D.array[I + 3] = X.w,
                                                    D.array[I + 4] = W.x,
                                                    D.array[I + 5] = W.y,
                                                    D.array[I + 6] = W.z,
                                                    D.array[I + 7] = W.w,
                                                    D.array[I + 8] = V.x,
                                                    D.array[I + 9] = V.y,
                                                    D.array[I + 10] = V.z,
                                                    D.array[I + 11] = V.w,
                                                    I += 12;
                                            else if ("faceVertices" === D.boundTo)
                                                for (T = 0,
                                                J = da.length; T < J; T++)
                                                    Ea = D.value[da[T]],
                                                    X = Ea[0],
                                                    W = Ea[1],
                                                    V = Ea[2],
                                                    D.array[I] = X.x,
                                                    D.array[I + 1] = X.y,
                                                    D.array[I + 2] = X.z,
                                                    D.array[I + 3] = X.w,
                                                    D.array[I + 4] = W.x,
                                                    D.array[I + 5] = W.y,
                                                    D.array[I + 6] = W.z,
                                                    D.array[I + 7] = W.w,
                                                    D.array[I + 8] = V.x,
                                                    D.array[I + 9] = V.y,
                                                    D.array[I + 10] = V.z,
                                                    D.array[I + 11] = V.w,
                                                    I += 12;
                                        q.bindBuffer(q.ARRAY_BUFFER, D.buffer);
                                        q.bufferData(q.ARRAY_BUFFER, D.array, H)
                                    }
                            M && (delete B.__inittedArrays,
                            delete B.__colorArray,
                            delete B.__normalArray,
                            delete B.__tangentArray,
                            delete B.__uvArray,
                            delete B.__uv2Array,
                            delete B.__faceArray,
                            delete B.__vertexArray,
                            delete B.__lineArray,
                            delete B.__skinIndexArray,
                            delete B.__skinWeightArray)
                        }
                    }
                l.verticesNeedUpdate = !1;
                l.morphTargetsNeedUpdate = !1;
                l.elementsNeedUpdate = !1;
                l.uvsNeedUpdate = !1;
                l.normalsNeedUpdate = !1;
                l.colorsNeedUpdate = !1;
                l.tangentsNeedUpdate = !1;
                l.buffersNeedUpdate = !1;
                t.attributes && r(t)
            } else if (k instanceof THREE.Line) {
                t = c(k, l);
                n = t.attributes && v(t);
                if (l.verticesNeedUpdate || l.colorsNeedUpdate || l.lineDistancesNeedUpdate || 
                n) {
                    var Ja = l
                      , Ua = q.DYNAMIC_DRAW
                      , ib = void 0
                      , jb = void 0
                      , kb = void 0
                      , ob = void 0
                      , ha = void 0
                      , pb = void 0
                      , ab = Ja.vertices
                      , bb = Ja.colors
                      , cb = Ja.lineDistances
                      , gb = ab.length
                      , hb = bb.length
                      , lb = cb.length
                      , qb = Ja.__vertexArray
                      , rb = Ja.__colorArray
                      , eb = Ja.__lineDistanceArray
                      , mb = Ja.colorsNeedUpdate
                      , nb = Ja.lineDistancesNeedUpdate
                      , tb = Ja.__webglCustomAttributesList
                      , sb = void 0
                      , fb = void 0
                      , qa = void 0
                      , db = void 0
                      , Ca = void 0
                      , ea = void 0;
                    if (Ja.verticesNeedUpdate) {
                        for (ib = 0; ib < gb; ib++)
                            ob = ab[ib],
                            ha = 3 * ib,
                            qb[ha] = ob.x,
                            qb[ha + 1] = ob.y,
                            qb[ha + 2] = ob.z;
                        q.bindBuffer(q.ARRAY_BUFFER, 
                        Ja.__webglVertexBuffer);
                        q.bufferData(q.ARRAY_BUFFER, qb, Ua)
                    }
                    if (mb) {
                        for (jb = 0; jb < hb; jb++)
                            pb = bb[jb],
                            ha = 3 * jb,
                            rb[ha] = pb.r,
                            rb[ha + 1] = pb.g,
                            rb[ha + 2] = pb.b;
                        q.bindBuffer(q.ARRAY_BUFFER, Ja.__webglColorBuffer);
                        q.bufferData(q.ARRAY_BUFFER, rb, Ua)
                    }
                    if (nb) {
                        for (kb = 0; kb < lb; kb++)
                            eb[kb] = cb[kb];
                        q.bindBuffer(q.ARRAY_BUFFER, Ja.__webglLineDistanceBuffer);
                        q.bufferData(q.ARRAY_BUFFER, eb, Ua)
                    }
                    if (tb)
                        for (sb = 0,
                        fb = tb.length; sb < fb; sb++)
                            if (ea = tb[sb],
                            ea.needsUpdate && (void 0 === ea.boundTo || "vertices" === ea.boundTo)) {
                                ha = 0;
                                db = ea.value.length;
                                if (1 === ea.size)
                                    for (qa = 0; qa < db; qa++)
                                        ea.array[qa] = ea.value[qa];
                                else if (2 === ea.size)
                                    for (qa = 0; qa < db; qa++)
                                        Ca = ea.value[qa],
                                        ea.array[ha] = Ca.x,
                                        ea.array[ha + 1] = Ca.y,
                                        ha += 2;
                                else if (3 === ea.size)
                                    if ("c" === ea.type)
                                        for (qa = 0; qa < db; qa++)
                                            Ca = ea.value[qa],
                                            ea.array[ha] = Ca.r,
                                            ea.array[ha + 1] = Ca.g,
                                            ea.array[ha + 2] = Ca.b,
                                            ha += 3;
                                    else
                                        for (qa = 0; qa < db; qa++)
                                            Ca = ea.value[qa],
                                            ea.array[ha] = Ca.x,
                                            ea.array[ha + 1] = Ca.y,
                                            ea.array[ha + 2] = Ca.z,
                                            ha += 3;
                                else if (4 === ea.size)
                                    for (qa = 0; qa < db; qa++)
                                        Ca = ea.value[qa],
                                        ea.array[ha] = Ca.x,
                                        ea.array[ha + 1] = Ca.y,
                                        ea.array[ha + 
                                        2] = Ca.z,
                                        ea.array[ha + 3] = Ca.w,
                                        ha += 4;
                                q.bindBuffer(q.ARRAY_BUFFER, ea.buffer);
                                q.bufferData(q.ARRAY_BUFFER, ea.array, Ua)
                            }
                }
                l.verticesNeedUpdate = !1;
                l.colorsNeedUpdate = !1;
                l.lineDistancesNeedUpdate = !1;
                t.attributes && r(t)
            }
        }
    }
    ;
    this.initMaterial = function(a, b, c, d) {
        a.addEventListener("dispose", xb);
        var e, f;
        a instanceof THREE.MeshDepthMaterial ? f = "depth" : a instanceof THREE.MeshNormalMaterial ? f = "normal" : a instanceof THREE.MeshBasicMaterial ? f = "basic" : a instanceof THREE.MeshLambertMaterial ? f = "lambert" : a instanceof THREE.MeshPhongMaterial ? 
        f = "phong" : a instanceof THREE.LineBasicMaterial ? f = "basic" : a instanceof THREE.LineDashedMaterial && (f = "dashed");
        if (f) {
            var g = THREE.ShaderLib[f];
            a.uniforms = THREE.UniformsUtils.clone(g.uniforms);
            a.vertexShader = g.vertexShader;
            a.fragmentShader = g.fragmentShader
        }
        for (var h = 0, k = 0, l = 0, m = 0, g = 0, n = b.length; g < n; g++) {
            var p = b[g];
            p.onlyShadow || (p instanceof THREE.DirectionalLight && h++,
            p instanceof THREE.PointLight && k++,
            p instanceof THREE.SpotLight && l++,
            p instanceof THREE.HemisphereLight && m++)
        }
        for (var r = 0, g = 0, n = b.length; g < 
        n; g++)
            p = b[g],
            p.castShadow && (p instanceof THREE.SpotLight && r++,
            p instanceof THREE.DirectionalLight && !p.shadowCascade && r++);
        var t;
        a: {
            n = a.fragmentShader;
            p = a.vertexShader;
            g = a.uniforms;
            b = a.attributes;
            var w = a.defines;
            d = {
                map: !!a.map,
                envMap: !!a.envMap,
                envIsSpherical: a.envMap && a.envMap.mapping instanceof THREE.SphericalReflectionMapping,
                lightMap: !!a.lightMap,
                bumpMap: Xa && !!a.bumpMap,
                normalMap: Xa && !!a.normalMap,
                specularMap: !!a.specularMap,
                vertexColors: a.vertexColors,
                fog: c,
                useFog: a.fog,
                fogExp: c instanceof THREE.FogExp2,
                sizeAttenuation: a.sizeAttenuation,
                skinning: a.skinning,
                maxBones: 0,
                useVertexTexture: zb && d && d.useVertexTexture,
                morphTargets: a.morphTargets,
                morphNormals: a.morphNormals,
                maxMorphTargets: this.maxMorphTargets,
                maxMorphNormals: this.maxMorphNormals,
                maxDirLights: h,
                maxPointLights: k,
                maxSpotLights: l,
                maxHemiLights: m,
                maxShadows: r,
                shadowMapEnabled: this.shadowMapEnabled && d.receiveShadow,
                shadowMapType: this.shadowMapType,
                shadowMapDebug: this.shadowMapDebug,
                shadowMapCascade: this.shadowMapCascade,
                alphaTest: a.alphaTest,
                metal: a.metal,
                wrapAround: a.wrapAround,
                doubleSided: a.side === THREE.DoubleSide,
                flipSided: a.side === THREE.BackSide,
                mrtNormals: Ba && a.mrtNormals
            };
            c = a.index0AttributeName;
            var u, v, x, h = [];
            f ? h.push(f) : (h.push(n),
            h.push(p));
            for (v in w)
                h.push(v),
                h.push(w[v]);
            for (u in d)
                h.push(u),
                h.push(d[u]);
            f = h.join();
            u = 0;
            for (v = Y.length; u < v; u++)
                if (h = Y[u],
                h.code === f) {
                    h.usedTimes++;
                    t = h.program;
                    break a
                }
            u = "SHADOWMAP_TYPE_BASIC";
            d.shadowMapType === THREE.PCFShadowMap ? u = "SHADOWMAP_TYPE_PCF" : d.shadowMapType === THREE.PCFSoftShadowMap && (u = "SHADOWMAP_TYPE_PCF_SOFT");
            v = [];
            for (x in w)
                h = w[x],
                !1 !== h && (h = "#define " + x + " " + h,
                v.push(h));
            w = v.join("\n");
            x = q.createProgram();
            v = ["precision " + Q + " float;", "precision " + Q + " int;", w, cb ? "#define VERTEX_TEXTURES" : "", J.gammaInput ? "#define GAMMA_INPUT" : "", J.gammaOutput ? "#define GAMMA_OUTPUT" : "", d.mrtNormals ? "#define MRT_NORMALS" : "", "#define MAX_DIR_LIGHTS " + d.maxDirLights, "#define MAX_POINT_LIGHTS " + d.maxPointLights, "#define MAX_SPOT_LIGHTS " + d.maxSpotLights, "#define MAX_HEMI_LIGHTS " + d.maxHemiLights, "#define MAX_SHADOWS " + d.maxShadows, 
            "#define MAX_BONES " + d.maxBones, d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envIsSpherical ? "#define SPHERICAL_ENV" : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.skinning ? "#define USE_SKINNING" : "", d.useVertexTexture ? "#define BONE_TEXTURE" : "", d.morphTargets ? "#define USE_MORPHTARGETS" : "", d.morphNormals ? "#define USE_MORPHNORMALS" : "", d.wrapAround ? 
            "#define WRAP_AROUND" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : "", d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + u : "", d.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", d.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", d.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", "uniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\nattribute vec2 uv2;\n#ifdef USE_COLOR\nattribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\nattribute vec3 morphTarget0;\nattribute vec3 morphTarget1;\nattribute vec3 morphTarget2;\nattribute vec3 morphTarget3;\n#ifdef USE_MORPHNORMALS\nattribute vec3 morphNormal0;\nattribute vec3 morphNormal1;\nattribute vec3 morphNormal2;\nattribute vec3 morphNormal3;\n#else\nattribute vec3 morphTarget4;\nattribute vec3 morphTarget5;\nattribute vec3 morphTarget6;\nattribute vec3 morphTarget7;\n#endif\n#endif\n#ifdef USE_SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\n#endif\n"].join("\n");
            u = ["precision " + Q + " float;", "precision " + Q + " int;", d.bumpMap || d.normalMap ? "#extension GL_OES_standard_derivatives : enable" : "", w, "#define MAX_DIR_LIGHTS " + d.maxDirLights, "#define MAX_POINT_LIGHTS " + d.maxPointLights, "#define MAX_SPOT_LIGHTS " + d.maxSpotLights, "#define MAX_HEMI_LIGHTS " + d.maxHemiLights, "#define MAX_SHADOWS " + d.maxShadows, d.alphaTest ? "#define ALPHATEST " + d.alphaTest : "", d.mrtNormals ? "#define MRT_NORMALS" : "", J.gammaInput ? "#define GAMMA_INPUT" : "", J.gammaOutput ? "#define GAMMA_OUTPUT" : "", 
            d.useFog && d.fog ? "#define USE_FOG" : "", d.useFog && d.fogExp ? "#define FOG_EXP2" : "", d.map ? "#define USE_MAP" : "", d.envMap ? "#define USE_ENVMAP" : "", d.envIsSpherical ? "#define SPHERICAL_ENV" : "", d.lightMap ? "#define USE_LIGHTMAP" : "", d.bumpMap ? "#define USE_BUMPMAP" : "", d.normalMap ? "#define USE_NORMALMAP" : "", d.specularMap ? "#define USE_SPECULARMAP" : "", d.vertexColors ? "#define USE_COLOR" : "", d.metal ? "#define METAL" : "", d.wrapAround ? "#define WRAP_AROUND" : "", d.doubleSided ? "#define DOUBLE_SIDED" : "", d.flipSided ? "#define FLIP_SIDED" : 
            "", d.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", d.shadowMapEnabled ? "#define " + u : "", d.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "", d.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "", "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;\n"].join("\n");
            p = B("vertex", v + p);
            n = B("fragment", u + n);
            q.attachShader(x, p);
            q.attachShader(x, n);
            c && q.bindAttribLocation(x, 0, c);
            q.linkProgram(x);
            q.getProgramParameter(x, q.LINK_STATUS) || (console.error("Could not initialise shader\nVALIDATE_STATUS: " + q.getProgramParameter(x, 
            q.VALIDATE_STATUS) + ", gl error [" + q.getError() + "]"),
            console.error("Program Info Log: " + q.getProgramInfoLog(x)));
            q.deleteShader(n);
            q.deleteShader(p);
            x.uniforms = {};
            x.attributes = {};
            var y, n = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition".split(" ");
            for (y in g)
                n.push(y);
            y = n;
            g = 0;
            for (n = y.length; g < n; g++)
                p = y[g],
                x.uniforms[p] = q.getUniformLocation(x, p);
            n = "position normal uv uv2 color lineDistance".split(" ");
            for (t in b)
                n.push(t);
            t = n;
            y = 0;
            for (b = t.length; y < b; y++)
                g = t[y],
                x.attributes[g] = 
                q.getAttribLocation(x, g);
            x.id = P++;
            Y.push({
                program: x,
                code: f,
                usedTimes: 1
            });
            J.info.memory.programs = Y.length;
            t = x
        }
        a.program = t;
        a.uniformsList = [];
        for (e in a.uniforms)
            a.uniformsList.push([a.uniforms[e], e])
    }
    ;
    this.setFaceCulling = function(a, b) {
        a === THREE.CullFaceNone ? q.disable(q.CULL_FACE) : (b === THREE.FrontFaceDirectionCW ? q.frontFace(q.CW) : q.frontFace(q.CCW),
        a === THREE.CullFaceBack ? q.cullFace(q.BACK) : a === THREE.CullFaceFront ? q.cullFace(q.FRONT) : q.cullFace(q.FRONT_AND_BACK),
        q.enable(q.CULL_FACE))
    }
    ;
    this.setMaterialFaces = 
    function(a) {
        var b = a.side === THREE.DoubleSide;
        a = a.side === THREE.BackSide;
        ma !== b && (b ? q.disable(q.CULL_FACE) : q.enable(q.CULL_FACE),
        ma = b);
        Ka !== a && (a ? q.frontFace(q.CW) : q.frontFace(q.CCW),
        Ka = a)
    }
    ;
    this.setDepthTest = function(a) {
        Za !== a && (a ? q.enable(q.DEPTH_TEST) : q.disable(q.DEPTH_TEST),
        Za = a)
    }
    ;
    this.setDepthWrite = function(a) {
        Ta !== a && (q.depthMask(a),
        Ta = a)
    }
    ;
    this.setBlending = function(a, b, c, d) {
        a !== za && (a === THREE.NoBlending ? q.disable(q.BLEND) : a === THREE.AdditiveBlending ? (q.enable(q.BLEND),
        q.blendEquation(q.FUNC_ADD),
        q.blendFunc(q.SRC_ALPHA, q.ONE)) : a === THREE.SubtractiveBlending ? (q.enable(q.BLEND),
        q.blendEquation(q.FUNC_ADD),
        q.blendFunc(q.ZERO, q.ONE_MINUS_SRC_COLOR)) : a === THREE.MultiplyBlending ? (q.enable(q.BLEND),
        q.blendEquation(q.FUNC_ADD),
        q.blendFunc(q.ZERO, q.SRC_COLOR)) : a === THREE.CustomBlending ? q.enable(q.BLEND) : (q.enable(q.BLEND),
        q.blendEquationSeparate(q.FUNC_ADD, q.FUNC_ADD),
        q.blendFuncSeparate(q.SRC_ALPHA, q.ONE_MINUS_SRC_ALPHA, q.ONE, q.ONE_MINUS_SRC_ALPHA)),
        za = a);
        if (a === THREE.CustomBlending) {
            if (b !== La && (q.blendEquation(M(b)),
            La = b),
            c !== Sa || d !== ab)
                q.blendFunc(M(c), M(d)),
                Sa = c,
                ab = d
        } else
            ab = Sa = La = null 
    }
    ;
    this.setTexture = function(a, b) {
        if (a.needsUpdate) {
            a.__webglInit || (a.__webglInit = !0,
            a.addEventListener("dispose", bb),
            a.__webglTexture = q.createTexture(),
            J.info.memory.textures++);
            q.activeTexture(q.TEXTURE0 + b);
            q.bindTexture(q.TEXTURE_2D, a.__webglTexture);
            q.pixelStorei(q.UNPACK_FLIP_Y_WEBGL, a.flipY);
            q.pixelStorei(q.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);
            q.pixelStorei(q.UNPACK_ALIGNMENT, a.unpackAlignment);
            var c = a.image
              , 
            d = K(c.width) && K(c.height)
              , e = M(a.format)
              , f = M(a.type);
            F(q.TEXTURE_2D, a, d);
            var g = a.mipmaps;
            if (a instanceof THREE.DataTexture)
                if (0 < g.length && d) {
                    for (var h = 0, k = g.length; h < k; h++)
                        c = g[h],
                        q.texImage2D(q.TEXTURE_2D, h, e, c.width, c.height, 0, e, f, c.data);
                    a.generateMipmaps = !1
                } else
                    q.texImage2D(q.TEXTURE_2D, 0, e, c.width, c.height, 0, e, f, c.data);
            else if (a instanceof THREE.CompressedTexture)
                for (h = 0,
                k = g.length; h < k; h++)
                    c = g[h],
                    a.format !== THREE.RGBAFormat ? q.compressedTexImage2D(q.TEXTURE_2D, h, e, c.width, c.height, 0, c.data) : q.texImage2D(q.TEXTURE_2D, 
                    h, e, c.width, c.height, 0, e, f, c.data);
            else if (0 < g.length && d) {
                h = 0;
                for (k = g.length; h < k; h++)
                    c = g[h],
                    q.texImage2D(q.TEXTURE_2D, h, e, e, f, c);
                a.generateMipmaps = !1
            } else
                q.texImage2D(q.TEXTURE_2D, 0, e, e, f, a.image);
            a.generateMipmaps && d && q.generateMipmap(q.TEXTURE_2D);
            a.needsUpdate = !1;
            if (a.onUpdate)
                a.onUpdate()
        } else
            q.activeTexture(q.TEXTURE0 + b),
            q.bindTexture(q.TEXTURE_2D, a.__webglTexture)
    }
    ;
    this.initFrameBuffer = function(a) {
        if (a && !a.__webglFramebuffer) {
            void 0 === a.depthBuffer && (a.depthBuffer = !0);
            void 0 === a.stencilBuffer && 
            (a.stencilBuffer = !0);
            a.addEventListener("dispose", hb);
            a.__webglTexture = q.createTexture();
            J.info.memory.textures++;
            var b = K(a.width) && K(a.height)
              , c = M(a.format)
              , d = M(a.type);
            a.__webglFramebuffer = q.createFramebuffer();
            a.__webglRenderbuffer = a.shareDepthFrom ? a.shareDepthFrom.__webglRenderbuffer : q.createRenderbuffer();
            q.bindTexture(q.TEXTURE_2D, a.__webglTexture);
            F(q.TEXTURE_2D, a, b);
            q.texImage2D(q.TEXTURE_2D, 0, c, a.width, a.height, 0, c, d, null );
            c = q.TEXTURE_2D;
            q.bindFramebuffer(q.FRAMEBUFFER, a.__webglFramebuffer);
            q.framebufferTexture2D(q.FRAMEBUFFER, q.COLOR_ATTACHMENT0, c, a.__webglTexture, 0);
            a.shareDepthFrom ? a.depthBuffer && !a.stencilBuffer ? q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_ATTACHMENT, q.RENDERBUFFER, a.__webglRenderbuffer) : a.depthBuffer && a.stencilBuffer && q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_STENCIL_ATTACHMENT, q.RENDERBUFFER, a.__webglRenderbuffer) : (c = a.__webglRenderbuffer,
            q.bindRenderbuffer(q.RENDERBUFFER, c),
            a.depthBuffer && !a.stencilBuffer ? (q.renderbufferStorage(q.RENDERBUFFER, q.DEPTH_COMPONENT16, 
            a.width, a.height),
            q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_ATTACHMENT, q.RENDERBUFFER, c)) : a.depthBuffer && a.stencilBuffer ? (q.renderbufferStorage(q.RENDERBUFFER, q.DEPTH_STENCIL, a.width, a.height),
            q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_STENCIL_ATTACHMENT, q.RENDERBUFFER, c)) : q.renderbufferStorage(q.RENDERBUFFER, q.RGBA4, a.width, a.height));
            b && q.generateMipmap(q.TEXTURE_2D);
            q.bindTexture(q.TEXTURE_2D, null );
            q.bindRenderbuffer(q.RENDERBUFFER, null );
            q.bindFramebuffer(q.FRAMEBUFFER, null )
        }
    }
    ;
    this.initFrameBufferMRT = 
    function(a, b) {
        var c = a[0]
          , d = !1;
        if (c && !c.__webglFramebuffer) {
            void 0 === c.depthBuffer && (c.depthBuffer = !0);
            void 0 === c.stencilBuffer && (c.stencilBuffer = !0);
            c.__webglFramebuffer = q.createFramebuffer();
            q.bindFramebuffer(q.FRAMEBUFFER, c.__webglFramebuffer);
            var e;
            c.shareDepthFrom ? e = c.__webglRenderbuffer = c.shareDepthFrom.__webglRenderbuffer : c.depthBuffer && !c.stencilBuffer ? (e = c.__webglRenderbuffer = q.createRenderbuffer(),
            q.bindRenderbuffer(q.RENDERBUFFER, e),
            q.renderbufferStorage(q.RENDERBUFFER, q.DEPTH_COMPONENT16, 
            c.width, c.height)) : c.depthBuffer && c.stencilBuffer && (e = c.__webglRenderbuffer = q.createRenderbuffer(),
            q.bindRenderbuffer(q.RENDERBUFFER, e),
            q.renderbufferStorage(q.RENDERBUFFER, q.DEPTH_STENCIL, c.width, c.height));
            c.depthBuffer && !c.stencilBuffer ? q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_ATTACHMENT, q.RENDERBUFFER, e) : c.depthBuffer && c.stencilBuffer && q.framebufferRenderbuffer(q.FRAMEBUFFER, q.DEPTH_STENCIL_ATTACHMENT, q.RENDERBUFFER, e);
            d = !0
        }
        e = ia;
        q.bindFramebuffer(q.FRAMEBUFFER, c.__webglFramebuffer);
        for (var f = 
        0; f < a.length; f++) {
            var g = a[f];
            if (!g.__webglTexture) {
                var h = K(g.width) && K(g.height)
                  , k = M(g.format)
                  , l = M(g.type);
                g.addEventListener("dispose", hb);
                g.__webglTexture = q.createTexture();
                J.info.memory.textures++;
                q.bindTexture(q.TEXTURE_2D, g.__webglTexture);
                F(q.TEXTURE_2D, g, h);
                q.texImage2D(q.TEXTURE_2D, 0, k, g.width, g.height, 0, k, l, null );
                h && q.generateMipmap(q.TEXTURE_2D)
            }
            q.framebufferTexture2D(q.FRAMEBUFFER, q.COLOR_ATTACHMENT0 + f, q.TEXTURE_2D, g.__webglTexture, 0)
        }
        Ba && 1 < a.length && Ba.drawBuffersWEBGL([Ba.COLOR_ATTACHMENT0_WEBGL, 
        Ba.COLOR_ATTACHMENT1_WEBGL]);
        b && (f = q.checkFramebufferStatus(q.FRAMEBUFFER),
        f !== q.FRAMEBUFFER_COMPLETE && (console.log("Can't use multiple render targets. Falling back to two passes. " + f),
        delete c.__webglFramebuffer,
        b = !1));
        q.bindFramebuffer(q.FRAMEBUFFER, e);
        d && (q.bindTexture(q.TEXTURE_2D, null ),
        q.bindRenderbuffer(q.RENDERBUFFER, null ),
        q.bindFramebuffer(q.FRAMEBUFFER, null ));
        return b
    }
    ;
    this.setRenderTarget = function(a) {
        var b;
        Array.isArray(a) ? (this.initFrameBufferMRT(a),
        b = a[0]) : a && (b = a,
        this.initFrameBuffer(b));
        var c, d, e;
        b ? (a = b.__webglFramebuffer,
        c = b.width,
        b = b.height,
        e = d = 0) : (a = null ,
        c = na,
        b = va,
        d = ta,
        e = ua);
        a !== ia && (q.bindFramebuffer(q.FRAMEBUFFER, a),
        q.viewport(d, e, c, b),
        ia = a);
        pa = c;
        Aa = b
    }
    ;
    this.verifyMRTWorks = function(a) {
        Ba && !this.initFrameBufferMRT(a, !0) && (Ba = null )
    }
    ;
    this.shadowMapPlugin = new THREE.ShadowMapPlugin;
    this.addPrePlugin(this.shadowMapPlugin)
}
;
void 0 === ENABLE_DEBUG && (ENABLE_DEBUG = !0);
void 0 === ENABLE_TRACE && (ENABLE_TRACE = !0);
var ENABLE_AUTOCAM = !0
  , MAX_FRAME_TIME = 50
  , MIN_FRAME_TIME = 1E3 / 30;
function Viewer3DImpl(a, b) {
    this.canvas = a;
    this.api = b;
    this.svfloader = new SvfLoader(this);
    var c = a.clientWidth
      , e = a.clientHeight;
    this.postProcess = !1;
    this.renderer = new RenderContext;
    this.renderer.init(a, c, e);
    this.RENDER_NORMAL = 0;
    this.RENDER_HIGHLIGHTED = 1;
    this.RENDER_HIDDEN = 2;
    this.RENDER_FINISHED = 3;
    this.phase = this.RENDER_NORMAL;
    this.camera = new THREE.PerspectiveCamera(45,c / e,.1,1E4);
    this.cameraChangedEvent = {
        type: "cameraChanged",
        camera: this.camera
    };
    this.scene = new THREE.Scene;
    this.scene.add(this.camera);
    this.overlayScenes = 
    {};
    this.selectionMaterialBase = new THREE.MeshPhongMaterial({
        color: 6724095,
        specular: 526344,
        emissive: 3361911,
        ambient: 0,
        opacity: 1,
        transparent: !1
    });
    this.selectionMaterialTop = new THREE.MeshPhongMaterial({
        color: 6724095,
        specular: 526344,
        emissive: 3361911,
        ambient: 0,
        opacity: .15,
        transparent: !0
    });
    this.createOverlayScene("selection", this.selectionMaterialBase, this.selectionMaterialTop);
    this.materials = {};
    this.texturesToUpdate = [];
    this.modelQueue = null ;
    this.fadeMaterial = new THREE.MeshLambertMaterial({
        color: 16777215,
        opacity: .1,
        transparent: !0
    });
    this.highlightMaterial = new THREE.MeshPhongMaterial({
        color: 6724095,
        specular: 526344,
        emissive: 3361911,
        ambient: 0,
        opacity: 1,
        transparent: !1
    });
    this.needsClear = this.needsRender = !1;
    this.progressiveRender = !0;
    this.maxFrameTime = MAX_FRAME_TIME;
    this.minFrameTime = MIN_FRAME_TIME;
    this.targetFrameRate = 2E3 / (MIN_FRAME_TIME + MAX_FRAME_TIME);
    ENABLE_AUTOCAM ? this.controls = new ViewController(this) : (this.controls = new THREE.TrackballControls(this.camera,this.canvas),
    this.controls.rotateSpeed = 1,
    this.controls.zoomSpeed = 
    1,
    this.controls.panSpeed = .5,
    this.controls.dynamicDampingFactor = .5,
    this.controls.owner = this);
    this.selector = new Selector(this);
    this.controls.setSelector(this.selector);
    this.visibilityManager = new VisibilityManager(this);
    var d = this;
    this.initContextMenu();
    this.useEnvMap = !1;
    this.explodeScale = 0;
    this.showOverlaysWhileMoving = this.showGhosting = !0;
    this.lastTickMoved = !1;
    this.setClearColors(41, 76, 120, 1, 2, 3);
    this.renderer.beginScene(this.scene, this.camera, !0);
    this.renderer.composeFinalFrame();
    (function f(a) {
        window.requestAnimationFrame(f);
        d.tick(a)
    }
    )()
}
function isMultiSelect(a) {
    var b = -1 != navigator.userAgent.search("Mac OS");
    return b && a.metaKey || !b && a.ctrlKey
}
function isRightClick(a) {
    return -1 != navigator.userAgent.search("Mac OS") && a.ctrlKey || 2 == a.button
}
Viewer3DImpl.prototype.initContextMenu = function() {
    var a = this;
    this.objectContextMenu = new ObjectContextMenu(this);
    this.canvas.addEventListener("mousedown", function(b) {
        isRightClick(b) && (a.startX = b.clientX,
        a.startY = b.clientY)
    }
    );
    this.canvas.addEventListener("mouseup", function(b) {
        if (isRightClick(b) && b.clientX == a.startX && b.clientY == a.startY) {
            var c = (new CameraRaycaster(a,a.camera)).castRay(b.clientX, b.clientY);
            c.node && (a.selector.isSelectedOrParentIsSelected(c.node) || isMultiSelect(b) || a.selector.setSelection([c.node]));
            return a.objectContextMenu.show(b)
        }
        return !0
    }
    , !1)
}
;
Viewer3DImpl.prototype.toggleProgressive = function(a) {
    this.progressiveRender = a;
    this.needsClear = !0
}
;
Viewer3DImpl.prototype.toggleGhosting = function(a) {
    this.showGhosting = a;
    this.needsClear = !0
}
;
Viewer3DImpl.prototype.toggleOverlaysWhileMoving = function(a) {
    this.showOverlaysWhileMoving = a
}
;
Viewer3DImpl.prototype.togglePostProcess = function(a, b) {
    for (var c in this.materials) {
        var e = this.materials[c];
        e.mrtNormals != a && (e.mrtNormals = a,
        e.needsUpdate = !0)
    }
    this.renderer.initPostPipeline(a, b);
    this.needsClear = !0
}
;
Viewer3DImpl.prototype.tick = function(a) {
    function b(a) {
        k.renderer.renderScenePart(a, k.phase != k.RENDER_NORMAL)
    }
    this.stats && this.stats.begin();
    var c = (a = this.controls.update()) || this.needsClear;
    for (this.overlayDirty = this.overlayDirty || a; this.texturesToUpdate.length; )
        for (var e = this.texturesToUpdate.pop(), d = 0; d < e.mats.length; d++)
            e.mats[d][e.slot] = e.tex,
            this.needsRender = e.mats[d].needsUpdate = !0;
    var e = c || this.needsRender
      , d = this.modelQueue
      , g = this.progressiveRender ? .5 * (this.maxFrameTime + this.minFrameTime) : 
    1E10
      , f = g;
    e && (this.fixNearFar(),
    this.renderer.beginScene(this.scene, this.camera, c),
    (a || this.cameraUpdated) && this.api.fireEvent(this.cameraChangedEvent),
    this.needGhostedPass && d.setOverrideMaterial(null ),
    d && (this.selector.getSelectionLength() > MAX_FRAGS_PER_GROUP ? (this.phase = this.RENDER_HIGHLIGHTED,
    d.reset(this.camera),
    d.drawHighlightedObjectsOnly(),
    d.setOverrideMaterial(this.highlightMaterial)) : (this.phase = this.RENDER_NORMAL,
    d.reset(this.camera),
    d.drawNormalObjectsOnly(),
    d.setOverrideMaterial(null ))));
    var k = this;
    d && !d.isDone() && (f = d.renderSome(b, f),
    d.isDone() && this.phase == this.RENDER_HIGHLIGHTED && (this.phase = this.RENDER_NORMAL,
    d.reset(this.camera),
    d.drawNormalObjectsOnly(),
    d.setOverrideMaterial(null ),
    f = d.renderSome(b, f)),
    a || this.overlayDirty || this.renderer.composeFinalFrame(),
    d.isDone() && (this.phase == this.RENDER_NORMAL && !d.areAllVisible() && this.showGhosting ? (this.phase = this.RENDER_HIDDEN,
    d.reset(this.camera),
    d.drawHiddenObjectsOnly(),
    d.setOverrideMaterial(this.fadeMaterial)) : (this.phase = this.RENDER_FINISHED,
    this.renderer.composeFinalFrame())));
    this.overlayDirty && (d && d.isDone() || this.showOverlaysWhileMoving ? (this.renderer.renderOverlays(this.overlayScenes),
    this.overlayDirty = !1) : this.renderer.clearAllOverlays(),
    this.renderer.composeFinalFrame(!a && !e));
    this.svf && this.svf.loadDone && (a || this.signalProgress(100 * d.currentScene / d.geomScenes.length, null ),
    a && !this.lastTickMoved && this.signalProgress(0, null ));
    f != g && this.stats && this.stats.end();
    this.lastTickMoved = a;
    this.needsClear = this.needsRender = !1
}
;
Viewer3DImpl.prototype.fixNearFar = function() {
    var a = this.camera;
    if (this.svf) {
        var b = this.svf.boundingSphere
          , c = (1.5 * this.explodeScale + 1) * b.radius
          , e = 1E-4 * c
          , d = a.position.distanceTo(b.center)
          , b = d - c
          , c = d + c;
        a.isPerspective ? b < e ? a.near = e : (d = THREE.Math.degToRad(a.fov / 2),
        d = 1 > a.aspect ? d : Math.atan(a.aspect * Math.tan(d)),
        a.near = Math.max(e, Math.cos(d) * b)) : a.near = b;
        a.far = c;
        a.updateProjectionMatrix()
    }
}
;
Viewer3DImpl.prototype.initLights = function(a) {
    this.lightNode = new THREE.Object3D;
    this.dir_light1 = new THREE.DirectionalLight((new THREE.Color).setRGB(1, .84, .67),1);
    this.dir_light1.position.set(-1, 0, 1);
    this.dir_light1.position.multiplyScalar(1E3 * a);
    this.lightNode.add(this.dir_light1);
    this.dir_light2 = new THREE.DirectionalLight(11262207,.75);
    this.dir_light2.position.set(2, 0, 1);
    this.dir_light2.position.multiplyScalar(1E3 * a);
    this.reflectionCube || this.lightNode.add(this.dir_light2);
    this.amb_light = new THREE.AmbientLight((new THREE.Color).setRGB(.8, 
    .9, 1));
    this.reflectionCube && this.scene.add(this.amb_light);
    this.camera.add(this.lightNode)
}
;
Viewer3DImpl.prototype.initCamera = function(a) {
    var b, c = a.cameras.length;
    if (0 < c) {
        var e = a.metadata && a.metadata["default camera"] ? a.metadata["default camera"].index : null ;
        if (null  !== e && a.cameras[e])
            b = a.cameras[e];
        else {
            for (e = 0; e < c; e++) {
                var d = a.cameras[e];
                if (d.isPerspective) {
                    b = d;
                    break
                }
            }
            b || (b = a.cameras[0])
        }
    }
    a = a.metadata ? (new THREE.Vector3).fromArray(a.metadata["world up vector"].XYZ) : null ;
    this.applyCamera(b, a, !0)
}
;
Viewer3DImpl.prototype.applyCamera = function(a, b, c) {
    var e = !1;
    if (a) {
        var d = a.fov;
        a.isPerspective || (d = 10,
        e = !0);
        this.camera.isPerspective = !0;
        this.camera.fov = d;
        this.camera.position.copy(a.position);
        this.camera.up.copy(a.up);
        this.camera.target = (new THREE.Vector3).copy(a.target);
        a.inst && a.inst.transform && (a = (new THREE.Matrix4).copy(a.inst.transform),
        this.camera.position.applyMatrix4(a),
        this.camera.target.applyMatrix4(a),
        this.camera.up.transformDirection(a));
        b ? this.camera.up.copy(b) : (b = this.camera.up.clone(),
        0 > b.x && (b.x = -b.x),
        0 > b.y && (b.y = -b.y),
        0 > b.z && (b.z = -b.z),
        b.x > b.y && b.x > b.z ? this.camera.up.set(0 < this.camera.up.x ? 1 : -1, 0, 0) : b.y > b.x && b.y > b.z ? this.camera.up.set(0, 0 < this.camera.up.y ? 1 : -1, 0) : this.camera.up.set(0, 0, 0 < this.camera.up.z ? 1 : -1))
    } else
        this.camera.target = this.svf.bbox.center(),
        a = this.svf.bbox.size(),
        this.camera.position.copy(this.camera.target),
        this.camera.position.z += Math.max(a.x, Math.max(a.y, a.z)),
        this.camera.isPerspective = !0,
        b && this.camera.up.copy(b);
    this.camera.lookAt(this.camera.target);
    this.syncCamera();
    e && this.controls.fitToView(!0, this.svf.bbox);
    c && this.controls.recordHomeView();
    this.cameraChangedEvent = {
        type: "cameraChanged",
        camera: this.camera
    }
}
;
Viewer3DImpl.prototype.syncCamera = function() {
    this.camera.updateProjectionMatrix();
    this.controls.setWorldUp(this.camera.up);
    this.controls.setSceneBounds(this.svf.bbox);
    this.controls.setViewpoint(this.camera.position, this.camera.target);
    this.cameraUpdated = !0
}
;
Viewer3DImpl.prototype.setCameraFromArray = function(a) {
    a = {
        position: new THREE.Vector3(a[0],a[1],a[2]),
        target: new THREE.Vector3(a[3],a[4],a[5]),
        up: new THREE.Vector3(a[6],a[7],a[8]),
        aspect: a[9],
        fov: THREE.Math.radToDeg(a[10]),
        orthoHeight: a[11],
        isPerspective: !a[12]
    };
    this.applyCamera(a, null , !1)
}
;
Viewer3DImpl.prototype.initScene = function(a) {
    this.svf = a;
    a.bbox = new THREE.Box3(a.bbox.min,a.bbox.max);
    var b = a.bbox.size()
      , c = a.bbox.center()
      , b = .5 * Math.sqrt(b.x * b.x + b.y * b.y + b.z * b.z);
    a.boundingSphere = new THREE.Sphere(c,b);
    stderr("scene bounds: " + JSON.stringify(a.bbox));
    this.initCamera(a);
    this.initLights(b);
    this.modelQueue = new RenderQueue(a.fragments,this.scene);
    this.needsRender = this.needsClear = !0
}
;
Viewer3DImpl.prototype.getNodesByIds = function(a) {
    function b(a, e, d) {
        if (0 === a.length)
            return d;
        var g = a.indexOf(e.dbId);
        -1 != g && (d.push(e),
        a.splice(g, 1));
        if (e.children)
            for (g = 0; g < e.children.length; g++)
                b(a, e.children[g], d);
        return d
    }
    a = a.slice(0);
    return b(a, this.svf.instanceTree, [])
}
;
Viewer3DImpl.prototype.addMaterial = function(a, b) {
    function c(a) {
        return .299 * a.r + .587 * a.g + .114 * a.b
    }
    b.metal ? (b.reflectivity || (b.reflectivity = c(b.specular)),
    this.svfloader.svf.proteinMaterials && (b.color.r *= .1,
    b.color.g *= .1,
    b.color.b *= .1)) : !this.svfloader.svf.proteinMaterials && b.reflectivity ? (b.metal = !0,
    b.specular.r = b.color.r * b.reflectivity,
    b.specular.g = b.color.g * b.reflectivity,
    b.specular.b = b.color.b * b.reflectivity,
    b.color.r *= .1,
    b.color.g *= .1,
    b.color.b *= .1) : 1 != b.color.r || 1 != b.color.g || 1 != b.color.b || 1 != 
    b.specular.r || 1 != b.specular.g || 1 != b.specular.b || b.uri_map || b.uri_specularMap ? (b.reflectivity || (b.reflectivity = .01 + .06 * c(b.specular)),
    b.specular.r *= b.reflectivity,
    b.specular.g *= b.reflectivity,
    b.specular.b *= b.reflectivity) : (b.metal = !0,
    b.reflectivity = .7,
    b.specular.r = b.specular.g = b.specular.b = b.reflectivity,
    b.color.r *= .1,
    b.color.g *= .1,
    b.color.b *= .1);
    b.ambient.copy(b.color);
    b.ambient.r *= .3;
    b.ambient.g *= .3;
    b.ambient.b *= .3;
    b.combine = THREE.AddOperation;
    b.bumpScale = void 0 === b.bumpScale && (b.uri_map || b.uri_bumpMap) ? 
    .03 : 1 <= b.bumpScale ? .03 : .1 * b.bumpScale;
    this.reflectionCube && (b.envMap = this.reflectionCube);
    b.mrtNormals = this.renderer.hasMRT() && this.renderer.settings.sao;
    b.side == THREE.DoubleSide && this.renderer.toggleTwoSided(!0);
    this.materials[a] = b
}
;
Viewer3DImpl.prototype.addTexture = function(a) {
    this.texturesToUpdate.push(a)
}
;
Viewer3DImpl.prototype.addMeshInstance = function(a, b, c, e) {
    if (0 !== b || -1 == this.svfloader.svf.basePath.indexOf("SaRang")) {
        if (a.isLines) {
            var d = !!a.attributes.color
              , g = new THREE.LineBasicMaterial({
                vertexColors: d
            });
            d || (g.color = this.materials[c].color);
            a = new THREE.Line(a,g)
        } else {
            g = this.materials[c];
            if (!g)
                for (d in stderr("Unknown material " + c),
                this.materials) {
                    g = this.materials[d];
                    break
                }
            a.attributes.color && (g.vertexColors = THREE.VertexColors,
            g.needsUpdate = !0);
            a.attributes.uv && a.attributes.uv.isPattern && (g.map && 
            !g.bumpMap && (g.bumpMap = g.map,
            g.needsUpdate = !0),
            g.uri_map && !g.uri_bumpMap && (g.uri_bumpMap = g.uri_map,
            g.needsUpdate = !0));
            a = new THREE.Mesh(a,g,!0)
        }
        e && (a.matrix ? a.matrix.copy(e) : a.matrixWorld.copy(e));
        a.matrixAutoUpdate = !1;
        this.modelQueue.addMesh(b, a)
    }
}
;
Viewer3DImpl.prototype.signalProgress = function(a, b) {
    this.api.fireEvent({
        type: PROGRESS_UPDATE_EVENT,
        percent: a,
        message: b
    })
}
;
Viewer3DImpl.prototype.resize = function(a, b) {
    this.camera.aspect = a / b;
    this.renderer.setSize(a, b);
    this.overlayDirty = this.needsClear = this.needsRender = !0
}
;
Viewer3DImpl.prototype.loadSvf = function(a, b, c) {
    return this.svfloader.loadSvf(a, b, c)
}
;
Viewer3DImpl.prototype.createOverlayScene = function(a, b, c) {
    b.depthWrite = !1;
    b.depthTest = !0;
    c.depthWrite = !1;
    c.depthTest = !1;
    var e = new THREE.Scene(!0);
    e.__lights = this.scene.__lights;
    this.overlayScenes[a] = {
        scene: e,
        materialPre: b,
        materialPost: c
    }
}
;
Viewer3DImpl.prototype.addOverlay = function(a, b) {
    this.overlayScenes[a].scene.add(b);
    this.overlayDirty = !0
}
;
Viewer3DImpl.prototype.removeOverlay = function(a, b) {
    this.overlayScenes[a].scene.remove(b);
    this.overlayDirty = !0
}
;
Viewer3DImpl.prototype.clearOverlay = function(a) {
    this.overlayScenes[a].scene.clear();
    this.overlayDirty = !0
}
;
Viewer3DImpl.prototype.setClearColors = function(a, b, c, e, d, g) {
    var f = new THREE.Vector4(a / 255,b / 255,c / 255,1)
      , k = new THREE.Vector4(e / 255,d / 255,g / 255,1);
    this.setCubeMapFromColors(a, b, c, e, d, g);
    this.renderer.setClearColors(f, k);
    this.needsClear = !0
}
;
Viewer3DImpl.prototype.explode = function(a) {
    var b = this.svf
      , c = b.fragments
      , e = c.transforms
      , d = this.modelQueue.vizmeshes
      , g = b.bbox.center()
      , f = a * (b.maxTreeDepth - 1) + 1
      , k = 0 | f
      , h = f - k;
    this.explodeScale = a *= 2;
    if (b.instanceTree && b.instanceBoxes && 0 != a) {
        var l = b.instanceBoxes;
        (function u(b, c, f, g, m, n, p, t) {
            var v = 2 * a;
            c == k && (v *= h);
            var F = 6 * b.dbId
              , O = .5 * (l[F] + l[F + 3])
              , M = .5 * (l[F + 1] + l[F + 4])
              , F = .5 * (l[F + 2] + l[F + 5]);
            0 < c && c <= k && (n += (O - f) * v,
            p += (M - g) * v,
            t += (F - m) * v);
            if (f = b.children)
                for (g = 0,
                m = f.length; g < m; g++)
                    u(f[g], c + 1, O, M, F, n, p, t);
            b = b.fragIds;
            if (void 0 !== b)
                if (Array.isArray(b))
                    for (c = 0; c < b.length; c++)
                        O = 0 | b[c],
                        F = 16 * O,
                        M = d[O].matrixWorld.elements,
                        M[12] = e[F + 12] + n,
                        M[13] = e[F + 13] + p,
                        M[14] = e[F + 14] + t;
                else
                    O = b | 0,
                    M = d[O].matrixWorld.elements,
                    F = 16 * O,
                    M[12] = e[F + 12] + n,
                    M[13] = e[F + 13] + p,
                    M[14] = e[F + 14] + t
        }
        )(b.instanceTree, 0, g.x, g.y, g.x, 0, 0, 0)
    } else
        for (b = c.boxes,
        c = 0,
        f = d.length; c < f; c++) {
            var m = 6 * c
              , n = 16 * c
              , p = .5 * (b[m] + b[m + 3])
              , t = .5 * (b[m + 1] + b[m + 4])
              , m = .5 * (b[m + 2] + b[m + 5])
              , p = a * (p - g.x)
              , t = a * (t - g.y)
              , m = a * (m - g.z)
              , v = d[c].matrixWorld.elements;
            v[12] = e[n + 12] + p;
            v[13] = e[n + 13] + t;
            v[14] = 
            e[n + 14] + m
        }
    this.overlayDirty = this.needsClear = !0
}
;
Viewer3DImpl.prototype.setCubeMapFromColors = function(a, b, c, e, d, g) {
    for (var f = new Uint8Array(16), k = new Uint8Array(16), h = new Uint8Array(16), l = 0; 4 > l; l++)
        f[4 * l] = a,
        f[4 * l + 1] = b,
        f[4 * l + 2] = c,
        f[4 * l + 3] = 255,
        k[4 * l] = e,
        k[4 * l + 1] = d,
        k[4 * l + 2] = g,
        k[4 * l + 3] = 255,
        0 | l / 2 ? (h[4 * l] = a,
        h[4 * l + 1] = b,
        h[4 * l + 2] = c) : (h[4 * l] = e,
        h[4 * l + 1] = d,
        h[4 * l + 2] = g),
        h[4 * l + 3] = 255;
    a = new THREE.DataTexture(h,2,2,THREE.RGBAFormat);
    b = new THREE.DataTexture(h,2,2,THREE.RGBAFormat);
    k = new THREE.DataTexture(k,2,2,THREE.RGBAFormat);
    f = new THREE.DataTexture(f,2,2,THREE.RGBAFormat);
    c = new THREE.DataTexture(h,2,2,THREE.RGBAFormat);
    e = new THREE.DataTexture(h,2,2,THREE.RGBAFormat);
    h = new THREE.Texture(null ,new THREE.CubeReflectionMapping,THREE.RepeatWrapping,THREE.RepeatWrapping,THREE.LinearFilter,THREE.LinearFilter,THREE.RGBAFormat);
    h.image = [b.image, a.image, f.image, k.image, e.image, c.image];
    h.needsUpdate = !0;
    this.reflectionCube = h;
    for (var m in this.materials)
        f = this.materials[m],
        f.envMap = h,
        f.needsUpdate = !0;
    this.needsClear = !0
}
;
Viewer3DImpl.prototype.setCubeMap = function(a) {
    var b = this
      , c = function(a) {
        for (var c in b.materials)
            a = b.materials[c],
            a.envMap = b.reflectionCube,
            a.needsUpdate = !0;
        b.dir_light2.parent && b.lightNode.remove(b.dir_light2);
        b.amb_light.parent || b.scene.add(b.amb_light);
        b.needsClear = !0
    }
    ;
    if (Array.isArray(a))
        this.reflectionCube = THREE.ImageUtils.loadTextureCube(a, new THREE.CubeReflectionMapping, c),
        this.reflectionCube.format = THREE.RGBFormat;
    else if (a && a.length)
        this.reflectionCube = THREE.ImageUtils.loadTexture(a, new THREE.SphericalReflectionMapping, 
        c),
        this.reflectionCube.format = THREE.RGBFormat;
    else if (this.reflectionCube) {
        for (var e in this.materials)
            a = this.materials[e],
            delete a.envMap,
            a.needsUpdate = !0;
        this.reflectionCube = null ;
        this.needsClear = !0;
        this.lightNode.add(this.dir_light2);
        this.scene.remove(this.amb_light)
    }
}
;
Viewer3DImpl.prototype.raiseError = function(a, b, c) {
    a = {
        type: "error",
        code: a,
        message: b
    };
    if (c)
        for (var e in c)
            c.hasOwnProperty(e) && (a[e] = c[e]);
    this.api.fireEvent(a);
    console.error(b)
}
;
function PropertyPanel(a) {
    var b = this;
    this.viewer = a;
    this.dockPanel = new DockingPanel(a,"PropertyPanel","Object Properties Loading...",!0);
    this.table = document.createElement("table");
    this.table.id = "propertygrid";
    this.table.className = "tftable";
    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);
    this.scrollpanel = document.createElement("div");
    this.scrollpanel.className = "scrollcontainer-right";
    this.scrollpanel.style.height = "auto";
    this.scrollpanel.style.width = "auto";
    this.scrollpanel.style.position = 
    "absolute";
    this.scrollpanel.style.top = "38px";
    this.scrollpanel.style.bottom = "0px";
    this.scrollpanel.style.left = "0px";
    this.scrollpanel.style.right = "0px";
    this.scrollpanel.style.padding = "0px 5px 0px 5px";
    this.dockPanel.container.appendChild(this.scrollpanel);
    this.scrollpanel.appendChild(this.table);
    this.dockPanel.container.style.width = "300px";
    this.dockPanel.container.style.height = "200px";
    this.dockPanel.container.style.top = "180px";
    this.dockPanel.container.style.left = "220px";
    this.dockPanel.container.dock = 
    !0;
    a.addEventListener(SELECTION_CHANGED_EVENT, function(a) {
        0 < a.dbIdArray.length ? b.setNodeId(a.dbIdArray[a.dbIdArray.length - 1]) : b.setNodeId(null )
    }
    );
    a.addEventListener(ISOLATE_EVENT, function(a) {
        0 < a.nodeIdArray.length ? b.setNodeId(a.nodeIdArray[a.nodeIdArray.length - 1].dbId) : b.setNodeId(null )
    }
    );
    this.setNodeId = function(c) {
        b.tbody.innerHTML = "";
        c ? a.getProperties(c, function(a) {
            b.tbody.innerHTML = "";
            if (a.properties)
                for (var c in a.properties) {
                    var g = a.properties[c]
                      , f = b.tbody.insertRow(-1)
                      , k = f.insertCell(0);
                    k.textContent = 
                    c;
                    k.style.fontStyle = "italic";
                    k = f.insertCell(1);
                    k.textContent = g
                }
            b.dockPanel.title.textContent = a.name ? a.name : "Object Properties";
            b.dockPanel.setVisible(!0);
            b.scrollpanel.scrollTop = 0;
            a = document.documentElement;
            c = document.getElementsByTagName("body")[0];
            a = window.innerHeight || a.clientHeight || c.clientHeight;
            c = b.table.offsetHeight + b.dockPanel.title.offsetHeight;
            b.dockPanel.container.style.height = (c > a - 180 ? a - 180 : c) + "px"
        }
        ) : b.dockPanel.setVisible(!1)
    }
}
;function ProgressBar(a) {
    this.bg = document.createElement("div");
    this.bg.className = "progressbg";
    this.fg = document.createElement("div");
    this.fg.className = "progressfg";
    this.bg.appendChild(this.fg);
    a.appendChild(this.bg);
    this.widthScale = this.fg.clientWidth
}
ProgressBar.prototype.setPercent = function(a) {
    99 <= a ? this.bg.style.visibility = "hidden" : (this.bg.style.visibility = "visible",
    this.fg.style.width = this.widthScale * a * .01 + "px")
}
;
function DockingPanel(a, b, c, e) {
    e = "undefined" == typeof e ? !1 : e;
    this.viewer = a;
    this.container = document.createElement("div");
    this.container.id = b;
    this.container.lastWidth = "";
    this.container.dock = !1;
    this.container.className = e ? "dockpanel" : "dockpanel-clear";
    this.title = document.createElement("div");
    this.title.className = "paneltitle";
    this.title.textContent = c ? c : b;
    this.closer = document.createElement("div");
    this.closer.className = "panelclose";
    this.closer.innerHTML = "&times;";
    this.container.appendChild(this.title);
    this.container.appendChild(this.closer);
    this.initializeMoveHandlers(this.title);
    this.initializeCloseHandler(this.closer);
    a.container.appendChild(this.container)
}
DockingPanel.initialize = function(a) {
    a.dockingPanels = [];
    window.addEventListener("resize", function(b) {
        DockingPanel.resizePanels(a)
    }
    , !1)
}
;
DockingPanel.resizePanels = function(a) {
    var b = a.dockingPanels;
    a = a.getDimensions();
    for (var c = 0; c < b.length; c++) {
        var e = b[c].container
          , d = parseInt(e.style.top)
          , g = parseInt(e.style.left)
          , f = "" == e.style.minWidth ? 100 : parseInt(e.style.minWidth)
          , k = "" == e.style.minWidth ? 100 : parseInt(e.style.minHeight)
          , h = parseInt(e.style.width)
          , l = parseInt(e.style.height)
          , h = f > h ? f : h
          , l = k > l ? k : l;
        if (h && l) {
            g += h;
            d + l > a.height && (k > a.height - d ? e.style.top = a.height - l + "px" : e.style.height = a.height - d + "px");
            if (g > a.width - 5 || e.dock)
                d = a.width - h,
                e.style.left = 
                (0 > d ? 0 : d) + "px";
            e.style.maxWidth = a.width - parseInt(e.style.left) + "px";
            e.style.maxHeight = a.height - parseInt(e.style.top) + "px"
        }
    }
}
;
DockingPanel.prototype.isVisible = function() {
    return "none" !== this.container.style.display && "" !== this.container.style.display
}
;
DockingPanel.prototype.setVisible = function(a) {
    this.setDisplay(a ? "block" : "none")
}
;
DockingPanel.prototype.setDisplay = function(a) {
    this.container.style.display = a;
    "none" == a && (this.container.lastWidth = this.viewer.container.style.width);
    var b = this.viewer.getDimensions().width;
    "block" == a && (this.viewer.dockingPanels.splice(this.viewer.dockingPanels.indexOf(this), 1),
    this.viewer.dockingPanels.splice(0, 0, this),
    this.container.dock && (a = "" == this.container.style.width ? this.container.lastWidth : this.container.style.width,
    a = "" == a ? 300 : parseInt(a),
    this.container.style.left = b - a + "px"))
}
;
DockingPanel.prototype.initializeMoveHandlers = function(a) {
    function b(a) {
        dimensions = m.viewer.getDimensions();
        l.style.maxWidth && parseInt(l.style.width) > parseInt(l.style.maxWidth) && (l.style.width = l.style.maxWidth);
        l.style.maxHeight && parseInt(l.style.height) > parseInt(l.style.maxHeight) && (l.style.height = l.style.maxHeight);
        100 > parseInt(l.style.width) && (l.style.width = "100px");
        100 > parseInt(l.style.height) && (l.style.height = "100px");
        k += a.screenX - e;
        h += a.screenY - d;
        var b = g + k
          , c = f + h;
        parseInt(l.style.top);
        parseInt(l.style.left);
        var v = parseInt(l.style.width)
          , r = parseInt(l.style.height);
        5 > b && (b = 0);
        5 > c && (c = 0);
        l.dock = !1;
        dimensions.width - 5 < b + v && (b = dimensions.width - v,
        l.dock = !0);
        dimensions.height - 5 < c + r && (c = dimensions.height - r,
        l.dock = !0);
        l.style.left = b + "px";
        l.style.top = c + "px";
        l.style.maxWidth = dimensions.width - b + "px";
        l.style.maxHeight = dimensions.height - c + "px";
        e = a.screenX;
        d = a.screenY
    }
    function c(a) {
        window.removeEventListener("mousemove", b);
        window.removeEventListener("mouseup", c)
    }
    var e, d, g, f, k, h, l = this.container, m = this;
    this.viewer.dockingPanels.push(this);
    a.addEventListener("mousedown", function(a) {
        e = a.screenX;
        d = a.screenY;
        h = k = 0;
        a = l.style;
        g = parseInt(a.left.substr(0, a.left.length - 2));
        f = parseInt(a.top.substr(0, a.top.length - 2));
        window.addEventListener("mousemove", b, !1);
        window.addEventListener("mouseup", c, !1)
    }
    , !1)
}
;
DockingPanel.prototype.initializeCloseHandler = function(a) {
    var b = this;
    a.addEventListener("click", function(a) {
        b.container.style.display = "none"
    }
    , !1)
}
;
function DocumentStructurePanel(a) {
    var b = this;
    this.viewer = a;
    this.container = document.createElement("div");
    this.container.id = "documentstructure";
    this.container.className = "dockpanel-clear";
    this.title = document.createElement("div");
    this.title.className = "paneltitle";
    this.title.textContent = "Document Structure Loading ...";
    this.container.appendChild(this.title);
    this.baselist = document.createElement("ul");
    this.closer = document.createElement("div");
    this.closer.className = "panelclose";
    this.closer.innerHTML = "&times;";
    this.container.appendChild(this.closer);
    this.initializeMoveHandlers(this.title);
    this.initializeCloseHandler(this.closer);
    this.scrollpanel = document.createElement("div");
    this.scrollpanel.className = "scrollcontainer-left";
    this.scrollpanel.style.height = "auto";
    this.scrollpanel.style.width = "auto";
    this.scrollpanel.style.position = "absolute";
    this.scrollpanel.style.top = "38px";
    this.scrollpanel.style.bottom = "0px";
    this.scrollpanel.style.left = "0px";
    this.scrollpanel.style.right = "6px";
    this.innercontainer = document.createElement("div");
    this.innercontainer.className = "documentStructure";
    this.container.appendChild(this.scrollpanel);
    this.scrollpanel.appendChild(this.innercontainer);
    this.innercontainer.appendChild(this.baselist);
    this.container.style.left = "0px";
    this.container.style.top = "0px";
    this.container.style.top = "0px";
    var c = this.viewer.getDimensions().height;
    this.container.style.height = (800 < c - 100 ? 800 : c - 100) + "px";
    this.container.style.minHeight = "100px";
    this.container.backgroundColor = "rgba(0,0,0,0)";
    this.items = {};
    a.getObjectTree(function(a) {
        b.rootNode = 
        a;
        b.treeLoaded(b.baselist, a, "item")
    }
    );
    this.container.style.display = "none";
    a.container.appendChild(this.container);
    this.lastKnownSelectionList = [];
    a.addEventListener(SELECTION_CHANGED_EVENT, function(a) {
        b.setSelectedNodes(a.nodeArray)
    }
    );
    a.addEventListener(HIGHLIGHT_EVENT, function(a) {
        b.setHighlightNode(a.dbNode)
    }
    );
    a.addEventListener("isolate", function(a) {
        b.setIsolatedNodes(a.nodeIdArray)
    }
    );
    a.addEventListener("hide", function(a) {
        b.hideNodes(a.nodeIdArray)
    }
    );
    a.addEventListener("show", function(a) {
        b.showNodes(a.nodeIdArray)
    }
    )
}
DocumentStructurePanel.prototype = Object.create(DockingPanel.prototype);
DocumentStructurePanel.prototype.setClickBehavior = function(a) {
    this.clickConfig = a
}
;
function ctrlDown(a) {
    var b = -1 != navigator.userAgent.search("Mac OS");
    return b && a.metaKey || !b && a.ctrlKey
}
DocumentStructurePanel.prototype.clickItem = function(a, b) {
    var c = "click";
    ctrlDown(a) && (c += "Ctrl");
    a.shiftKey && (c += "Shift");
    a.altKey && (c += "Alt");
    onObjectKey = "onObject";
    this.clickConfig && this.clickConfig[c] && this.handleAction(this.clickConfig[c][onObjectKey], b.data)
}
;
DocumentStructurePanel.prototype.handleAction = function(a, b) {
    for (action in a)
        switch (a[action]) {
        case "selectOnly":
            this.viewer.select([b.dbId]);
            break;
        case "deselectAll":
            this.viewer.select([]);
            break;
        case "selectToggle":
            this.viewer.toggleSelect(b.dbId);
            break;
        case "isolate":
            this.viewer.isolate(b);
            break;
        case "showAll":
            this.viewer.isolate(null );
            break;
        case "focus":
            this.viewer.select([b.dbId]);
            this.viewer.impl.controls.fitToView();
            break;
        case "hide":
            this.viewer.hide(b);
            break;
        case "show":
            this.viewer.show(b);
            break;
        case "toggleVisibility":
            this.viewer.toggleVisibility(b)
        }
}
;
DocumentStructurePanel.prototype.showContextMenu = function(a, b, c) {
    a = a.viewer.impl;
    this.viewer.show(c.data);
    -1 == a.selector.findSelection(c.data) && (ctrlDown(b) || this.viewer.select(c.data.dbId));
    return a.objectContextMenu.show(b)
}
;
DocumentStructurePanel.prototype.setHighlightNode = function(a) {
    if (this.lastHighlightNode) {
        var b = this.lastKnownSelectionList.indexOf(this.lastHighlightNode)
          , c = this.items[this.lastHighlightNode.dbId];
        setHighlighted(c, !1);
        setSelected(c, 0 <= b)
    }
    if (this.lastHighlightNode = a)
        b = this.lastKnownSelectionList.indexOf(a),
        c = this.items[a.dbId],
        setHighlighted(c, !0),
        setSelected(c, 0 <= b)
}
;
DocumentStructurePanel.prototype.setSelectedNodes = function(a) {
    this.clearExtraState();
    this.lastKnownSelectionList = a;
    this.appendExtraState(a)
}
;
DocumentStructurePanel.prototype.setIsolatedNodes = function(a) {
    0 < a.length ? (this.setVisibleStateOnAll(!1),
    this.setVisibleStateOnNodes(a, !0)) : this.setVisibleStateOnAll(!0)
}
;
DocumentStructurePanel.prototype.hideNodes = function(a) {
    this.setVisibleStateOnNodes(a, !1)
}
;
DocumentStructurePanel.prototype.showNodes = function(a) {
    this.setVisibleStateOnNodes(a, !0)
}
;
function addClass(a, b) {
    a && (a.className = a.className.replace(" " + b, ""),
    a.className += " " + b)
}
function removeClass(a, b) {
    a && (a.className = a.className.replace(" " + b, ""))
}
function setHighlighted(a, b) {
    b ? addClass(a.header, "highlighted") : removeClass(a.header, "highlighted")
}
function setSelected(a, b) {
    b ? (addClass(a.header, "selected"),
    addClass(a.childContainer, "selected")) : (removeClass(a.header, "selected"),
    removeClass(a.childContainer, "selected"))
}
function setVisible(a, b) {
    b ? removeClass(a.header, "hidden") : addClass(a.header, "hidden")
}
DocumentStructurePanel.prototype.clearExtraState = function() {
    for (var a = 0; a < this.lastKnownSelectionList.length; a++) {
        var b = this.lastKnownSelectionList[a]
          , c = this.items[b.dbId];
        c && (setSelected(c, !1),
        setHighlighted(c, b == this.lastHighlightNode));
        for (b = b.parent; b; )
            this.items[b.dbId] && removeClass(this.items[b.dbId].marker, "mselected"),
            b = b.parent
    }
}
;
DocumentStructurePanel.prototype.setVisibleStateOnAll = function(a) {
    for (var b in this.items) {
        var c = this.items[b];
        c && setVisible(c, a)
    }
}
;
DocumentStructurePanel.prototype.setVisibleStateOnNodes = function(a, b) {
    for (var c = 0; c < a.length; c++) {
        var e = a[c]
          , d = this.items[e.dbId];
        d && (setVisible(d, b),
        e.children && this.setVisibleStateOnNodes(e.children, b))
    }
}
;
DocumentStructurePanel.prototype.appendExtraState = function(a) {
    for (var b = 0; b < a.length; b++) {
        var c = a[b]
          , e = this.items[c.dbId];
        e && (setSelected(e, !0),
        setHighlighted(e, c == this.lastHighlightNode));
        for (c = c.parent; c; )
            this.items[c.dbId] && addClass(this.items[c.dbId].marker, "mselected"),
            c = c.parent
    }
}
;
DocumentStructurePanel.prototype.createItem = function(a, b) {
    var c = this
      , e = b.children && 0 < b.children.length
      , d = document.createElement("li");
    d.className = "item";
    d.data = b;
    a.appendChild(d);
    var g = document.createElement("div");
    g.className = "header";
    g.data = b;
    d.appendChild(g);
    d.header = g;
    d.marker = document.createElement("div");
    d.marker.className = "marker";
    g.appendChild(d.marker);
    if (e) {
        var f = document.createElement("input");
        f.type = "button";
        f.className = "toggleButtonMax";
        g.appendChild(f);
        d.toggleButton = f;
        f.addEventListener("click", 
        function(a) {
            c.toggleExpand(d);
            a.stopPropagation();
            return !1
        }
        , !0)
    }
    f = document.createElement("label");
    f.textContent = b.name;
    e || (f.style.paddingLeft = "0px");
    g.appendChild(f);
    e && (e = document.createElement("ul"),
    d.childContainer = e,
    d.childContainer.className = "childContainer",
    d.appendChild(e));
    g.addEventListener("click", function(a) {
        c.clickItem(a, d);
        return !1
    }
    , !1);
    g.addEventListener("contextmenu", function(a) {
        c.showContextMenu(c, a, d);
        return !1
    }
    , !1);
    g.addEventListener("mouseover", function(a) {
        c.viewer.fireEvent({
            type: HIGHLIGHT_EVENT,
            dbNode: d.data
        })
    }
    );
    g.addEventListener("mouseout", function(a) {
        d.data == c.lastHighlightNode && c.viewer.fireEvent({
            type: HIGHLIGHT_EVENT,
            dbNode: void 0
        })
    }
    );
    setVisible(d, this.viewer.impl.visibilityManager.isVisible(b));
    this.items[b.dbId] = d
}
;
DocumentStructurePanel.prototype.createChildren = function(a, b) {
    for (var c = 0; c < a.children.length; c++)
        this.createItem(b, a.children[c])
}
;
DocumentStructurePanel.prototype.toggleExpand = function(a) {
    a.expanded ? this.minimize(a) : this.expand(a)
}
;
DocumentStructurePanel.prototype.expand = function(a) {
    a.expanded || (this.createChildren(a.data, a.childContainer),
    a.toggleButton.className = "toggleButtonMin",
    a.expanded = !0,
    this.setSelectedNodes(this.lastKnownSelectionList))
}
;
DocumentStructurePanel.prototype.minimize = function(a) {
    a.childContainer.textContent = "";
    a.toggleButton.className = "toggleButtonMax";
    a.expanded = !1
}
;
DocumentStructurePanel.prototype.setTitleNode = function(a) {
    this.title.textContent = a.name;
    this.title.data = a;
    var b = this;
    this.title.addEventListener("click", function(a) {
        b.clickItem(a, b.title);
        return !1
    }
    , !1);
    this.items[a.dbId] = this.title
}
;
DocumentStructurePanel.prototype.treeLoaded = function(a, b) {
    this.setTitleNode(b);
    this.createChildren(b, a)
}
;
"undefined" !== typeof window && function(a, b, c) {
    function e(b) {
        if (a.event && a.event.contentOverflow !== c)
            return {
                x: a.event.offsetX,
                y: a.event.offsetY
            };
        if (b.offsetX !== c && b.offsetY !== c)
            return {
                x: b.offsetX,
                y: b.offsetY
            };
        var d = b.target.parentNode.parentNode;
        return {
            x: b.layerX - d.offsetLeft,
            y: b.layerY - d.offsetTop
        }
    }
    function d(a, c, d) {
        a = b.createElementNS("http://www.w3.org/2000/svg", a);
        for (var e in c)
            a.setAttribute(e, c[e]);
        "[object Array]" != Object.prototype.toString.call(d) && (d = [d]);
        c = 0;
        for (e = d[0] && d.length || 0; c < e; c++)
            a.appendChild(d[c]);
        return a
    }
    function g(a) {
        var b, c, d, e, f = a.h % 360 / 60;
        e = a.v * a.s;
        d = e * (1 - Math.abs(f % 2 - 1));
        b = c = a = a.v - e;
        f = ~~f;
        b += [e, d, 0, 0, d, e][f];
        c += [d, e, e, d, 0, 0][f];
        a += [0, 0, d, e, e, d][f];
        d = Math.floor(255 * b);
        c = Math.floor(255 * c);
        a = Math.floor(255 * a);
        return {
            r: d,
            g: c,
            b: a,
            hex: "#" + (16777216 | a | c << 8 | d << 16).toString(16).slice(1)
        }
    }
    function f(a) {
        var b = a.r
          , c = a.g
          , d = a.b;
        if (1 < a.r || 1 < a.g || 1 < a.b)
            b /= 255,
            c /= 255,
            d /= 255;
        var e;
        a = Math.max(b, c, d);
        e = a - Math.min(b, c, d);
        b = (0 == e ? 0 : a == b ? (c - d) / e + (c < d ? 6 : 0) : a == c ? (d - b) / e + 2 : (b - c) / e + 4) % 6 * 60;
        return {
            h: b,
            s: 0 == e ? 0 : 
            e / a,
            v: a
        }
    }
    function k(b, d, f) {
        return function(h) {
            h = h || a.event;
            h = e(h);
            b.h = h.y / d.offsetHeight * 360 + 15;
            b.s = b.v = 1;
            var k = g({
                h: b.h,
                s: 1,
                v: 1
            });
            f.style.backgroundColor = k.hex;
            b.callback && b.callback(k.hex, {
                h: b.h - 15,
                s: b.s,
                v: b.v
            }, {
                r: k.r,
                g: k.g,
                b: k.b
            }, c, h)
        }
    }
    function h(b, c) {
        return function(d) {
            d = d || a.event;
            d = e(d);
            var f = c.offsetHeight;
            b.s = d.x / c.offsetWidth;
            b.v = (f - d.y) / f;
            f = g(b);
            b.callback && b.callback(f.hex, {
                h: b.h - 15,
                s: b.s,
                v: b.v
            }, {
                r: f.r,
                g: f.g,
                b: f.b
            }, d)
        }
    }
    function l(a, b, c) {
        if (!(this instanceof l))
            return new l(a,b,c);
        this.h = 
        0;
        this.v = this.s = 1;
        if (c)
            this.callback = c,
            this.pickerElement = b,
            this.slideElement = a;
        else {
            a.innerHTML = '<div class="picker-wrapper"><div class="picker"></div><div class="picker-indicator"></div></div><div class="slide-wrapper"><div class="slide"></div><div class="slide-indicator"></div></div>';
            this.slideElement = a.getElementsByClassName("slide")[0];
            this.pickerElement = a.getElementsByClassName("picker")[0];
            var d = a.getElementsByClassName("slide-indicator")[0]
              , e = a.getElementsByClassName("picker-indicator")[0];
            l.fixIndicators(d, e);
            this.callback = function(a, c, f, g, h) {
                l.positionIndicators(d, e, h, g);
                b(a, c, f)
            }
        }
        if ("SVG" == t) {
            a = r.cloneNode(!0);
            c = v.cloneNode(!0);
            var f = a.getElementById("gradient-hsv")
              , g = a.getElementsByTagName("rect")[0];
            f.id = "gradient-hsv-" + u;
            g.setAttribute("fill", "url(#" + f.id + ")");
            f = [c.getElementById("gradient-black"), c.getElementById("gradient-white")];
            g = c.getElementsByTagName("rect");
            f[0].id = "gradient-black-" + u;
            f[1].id = "gradient-white-" + u;
            g[0].setAttribute("fill", "url(#" + f[1].id + ")");
            g[1].setAttribute("fill", 
            "url(#" + f[0].id + ")");
            this.slideElement.appendChild(a);
            this.pickerElement.appendChild(c);
            u++
        } else
            this.slideElement.innerHTML = r,
            this.pickerElement.innerHTML = v;
        m(this.slideElement, "click", k(this, this.slideElement, this.pickerElement));
        m(this.pickerElement, "click", h(this, this.pickerElement));
        n(this, this.slideElement, k(this, this.slideElement, this.pickerElement));
        n(this, this.pickerElement, h(this, this.pickerElement))
    }
    function m(a, b, c) {
        a.attachEvent ? a.attachEvent("on" + b, c) : a.addEventListener && a.addEventListener(b, 
        c, !1)
    }
    function n(a, b, c) {
        var d = !1;
        m(b, "mousedown", function(a) {
            d = !0
        }
        );
        m(b, "mouseup", function(a) {
            d = !1
        }
        );
        m(b, "mouseout", function(a) {
            d = !1
        }
        );
        m(b, "mousemove", function(a) {
            d && c(a)
        }
        )
    }
    function p(a, b, c, d) {
        a.h = b.h % 360;
        a.s = b.s;
        a.v = b.v;
        b = g(a);
        var e = {
            y: a.h * a.slideElement.offsetHeight / 360,
            x: 0
        }
          , f = a.pickerElement.offsetHeight
          , f = {
            x: a.s * a.pickerElement.offsetWidth,
            y: f - a.v * f
        };
        a.pickerElement.style.backgroundColor = g({
            h: a.h,
            s: 1,
            v: 1
        }).hex;
        a.callback && a.callback(d || b.hex, {
            h: a.h,
            s: a.s,
            v: a.v
        }, c || {
            r: b.r,
            g: b.g,
            b: b.b
        }, f, e);
        return a
    }
    var t = a.SVGAngle || b.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1") ? "SVG" : "VML", v, r;
    "SVG" == t ? (r = d("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        version: "1.1",
        width: "100%",
        height: "100%"
    }, [d("defs", {}, d("linearGradient", {
        id: "gradient-hsv",
        x1: "0%",
        y1: "100%",
        x2: "0%",
        y2: "0%"
    }, [d("stop", {
        offset: "0%",
        "stop-color": "#FF0000",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "13%",
        "stop-color": "#FF00FF",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "25%",
        "stop-color": "#8000FF",
        "stop-opacity": "1"
    }), 
    d("stop", {
        offset: "38%",
        "stop-color": "#0040FF",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "50%",
        "stop-color": "#00FFFF",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "63%",
        "stop-color": "#00FF40",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "75%",
        "stop-color": "#0BED00",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "88%",
        "stop-color": "#FFFF00",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "100%",
        "stop-color": "#FF0000",
        "stop-opacity": "1"
    })])), d("rect", {
        x: "0",
        y: "0",
        width: "100%",
        height: "100%",
        fill: "url(#gradient-hsv)"
    })]),
    v = d("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        version: "1.1",
        width: "100%",
        height: "100%"
    }, [d("defs", {}, [d("linearGradient", {
        id: "gradient-black",
        x1: "0%",
        y1: "100%",
        x2: "0%",
        y2: "0%"
    }, [d("stop", {
        offset: "0%",
        "stop-color": "#000000",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "100%",
        "stop-color": "#CC9A81",
        "stop-opacity": "0"
    })]), d("linearGradient", {
        id: "gradient-white",
        x1: "0%",
        y1: "100%",
        x2: "100%",
        y2: "100%"
    }, [d("stop", {
        offset: "0%",
        "stop-color": "#FFFFFF",
        "stop-opacity": "1"
    }), d("stop", {
        offset: "100%",
        "stop-color": "#CC9A81",
        "stop-opacity": "0"
    })])]), d("rect", {
        x: "0",
        y: "0",
        width: "100%",
        height: "100%",
        fill: "url(#gradient-white)"
    }), d("rect", {
        x: "0",
        y: "0",
        width: "100%",
        height: "100%",
        fill: "url(#gradient-black)"
    })])) : "VML" == t && (r = '<DIV style="position: relative; width: 100%; height: 100%"><v:rect style="position: absolute; top: 0; left: 0; width: 100%; height: 100%" stroked="f" filled="t"><v:fill type="gradient" method="none" angle="0" color="red" color2="red" colors="8519f fuchsia;.25 #8000ff;24903f #0040ff;.5 aqua;41287f #00ff40;.75 #0bed00;57671f yellow"></v:fill></v:rect></DIV>',
    v = '<DIV style="position: relative; width: 100%; height: 100%"><v:rect style="position: absolute; left: -1px; top: -1px; width: 101%; height: 101%" stroked="f" filled="t"><v:fill type="gradient" method="none" angle="270" color="#FFFFFF" opacity="100%" color2="#CC9A81" o:opacity2="0%"></v:fill></v:rect><v:rect style="position: absolute; left: 0px; top: 0px; width: 100%; height: 101%" stroked="f" filled="t"><v:fill type="gradient" method="none" angle="0" color="#000000" opacity="100%" color2="#CC9A81" o:opacity2="0%"></v:fill></v:rect></DIV>',
    b.namespaces.v || b.namespaces.add("v", "urn:schemas-microsoft-com:vml", "#default#VML"));
    var u = 0;
    l.hsv2rgb = function(a) {
        a = g(a);
        delete a.hex;
        return a
    }
    ;
    l.hsv2hex = function(a) {
        return g(a).hex
    }
    ;
    l.rgb2hsv = f;
    l.rgb2hex = function(a) {
        return g(f(a)).hex
    }
    ;
    l.hex2hsv = function(a) {
        return f(l.hex2rgb(a))
    }
    ;
    l.hex2rgb = function(a) {
        return {
            r: parseInt(a.substr(1, 2), 16),
            g: parseInt(a.substr(3, 2), 16),
            b: parseInt(a.substr(5, 2), 16)
        }
    }
    ;
    l.prototype.setHsv = function(a) {
        return p(this, a)
    }
    ;
    l.prototype.setRgb = function(a) {
        return p(this, f(a), 
        a)
    }
    ;
    l.prototype.setHex = function(a) {
        return p(this, l.hex2hsv(a), c, a)
    }
    ;
    l.positionIndicators = function(a, b, c, d) {
        c && (b.style.left = "auto",
        b.style.right = "0px",
        b.style.top = "0px",
        a.style.top = c.y - a.offsetHeight / 2 + "px");
        d && (b.style.top = d.y - b.offsetHeight / 2 + "px",
        b.style.left = d.x - b.offsetWidth / 2 + "px")
    }
    ;
    l.fixIndicators = function(a, b) {
        b.style.pointerEvents = "none";
        a.style.pointerEvents = "none"
    }
    ;
    a.ColorPicker = l
}
(window, window.document);
var ContextMenu = function(a) {
    this.viewer = a;
    this.menus = [];
    this.open = !1;
    this.itemWidth = 100;
    this.itemHeight = 25
}
;
ContextMenu.prototype.show = function(a, b) {
    var c = this.viewer.api.container.getBoundingClientRect()
      , e = a.clientX - c.left
      , c = a.clientY - c.top;
    if (0 == this.open) {
        var d = this;
        this.showMenu(b, 0, e, c);
        this.open = !0;
        this.hideEventListener = function(a) {
            "menuItem" != a.target.className && d.hide(a)
        }
        ;
        document.body.addEventListener("mousedown", this.hideEventListener, !0)
    }
}
;
ContextMenu.prototype.showMenu = function(a, b, c, e) {
    0 > c && (c = 0);
    0 > e && (e = 0);
    c + this.itemWidth + 10 > this.viewer.canvas.width && (c = this.viewer.canvas.width - this.itemWidth - 10);
    e + Object.keys(a).length * this.itemHeight > this.viewer.canvas.height && (e = this.viewer.canvas.height - Object.keys(a).length * this.itemHeight);
    var d = document.createElement("div");
    d.width = this.itemWidth;
    d.className = "menu";
    d.style.top = e + "px";
    d.style.left = c + "px";
    d.style.zIndex = 10;
    this.viewer.api.container.appendChild(d);
    var g = 0, f;
    for (f in a) {
        var k = 
        this.createMenuItem(d, f, g)
          , g = g + this.itemHeight;
        "object" == typeof a[f] ? this.addSubMenuClickToMenuItem(k, a[f], c + this.itemWidth + 10, e + g) : "function" == typeof a[f] ? this.addCallbackToMenuItem(k, a[f]) : console.warn("Invalid option", a, f)
    }
    d.style.height = g + "px";
    null  != this.menus[b] && this.menus[b].parentNode.removeChild(this.menus[b]);
    this.menus[b] = d
}
;
ContextMenu.prototype.createMenuItem = function(a, b, c) {
    var e = document.createElement("div");
    e.className = "menuItem";
    e.innerHTML = b;
    e.style.top = c + "px";
    a.appendChild(e);
    return e
}
;
ContextMenu.prototype.addSubMenuClickToMenuItem = function(a, b, c, e) {
    var d = this;
    a.addEventListener("click", function() {
        d.showMenu(b, level + 1, c, e)
    }
    )
}
;
ContextMenu.prototype.addCallbackToMenuItem = function(a, b) {
    var c = this;
    a.addEventListener("click", function(a) {
        c.hide();
        b();
        a.preventDefault();
        return !1
    }
    )
}
;
ContextMenu.prototype.hide = function() {
    if (this.open) {
        for (var a in this.menus)
            this.menus[a].parentNode.removeChild(this.menus[a]);
        this.menus = [];
        this.open = !1;
        document.body.removeEventListener("mousedown", this.hideEventListener);
        return !0
    }
    return !1
}
;
ObjectContextMenu = function(a) {
    this.viewerImpl = a;
    this.contextMenu = new ContextMenu(a)
}
;
ObjectContextMenu.prototype.show = function(a) {
    for (var b = this, c = {}, e = b.viewerImpl.selector.selectedObjects.length, d = !1, g = !1, f = 0; f < e && (b.viewerImpl.visibilityManager.isVisible(b.viewerImpl.selector.selectedObjects[f]) ? d = !0 : g = !0,
    !d || !g); f++)
        ;
    0 < e && (c[""] = function() {
        b.viewerImpl.visibilityManager.isolateMultiple(b.viewerImpl.selector.selectedObjects);
        b.viewerImpl.selector.clearSelection()
    }
    ,
    d && (c[""] = function() {
        b.viewerImpl.visibilityManager.hideMultiple(b.viewerImpl.selector.selectedObjects);
        b.viewerImpl.selector.clearSelection()
    }
    ),
    g && (c[""] = function() {
        b.viewerImpl.visibilityManager.showMultiple(b.viewerImpl.selector.selectedObjects);
        b.viewerImpl.selector.clearSelection()
    }
    ));
    c[""] = function() {
        b.viewerImpl.visibilityManager.isolate(null )
    }
    ;
    0 < e && (c[""] = function() {
        b.viewerImpl.controls.fitToView()
    }
    );
    this.contextMenu.show(a, c);
    return !1
}
;
ObjectContextMenu.prototype.hide = function() {
    return this.contextMenu.hide()
}
;
function OptionSlider(a, b, c, e) {
    var d = this;
    this.tbody = e;
    this.sliderRow = this.tbody.insertRow(-1);
    e = this.sliderRow.insertCell(0);
    e.style.fontStyle = "italic";
    this.caption = document.createElement("div");
    this.caption.innerHTML = a + ":";
    this.sliderElement = document.createElement("input");
    this.sliderElement.type = "range";
    this.sliderElement.id = a + "_slider";
    this.sliderElement.min = b;
    this.sliderElement.max = c;
    this.sliderElement.style.width = "100%";
    e.appendChild(this.caption);
    e.appendChild(this.sliderElement);
    e = this.sliderRow.insertCell(1);
    this.stepperElement = document.createElement("input");
    this.stepperElement.type = "number";
    this.stepperElement.id = a + "_stepper";
    this.stepperElement.min = b;
    this.stepperElement.max = c;
    this.stepperElement.step = 1;
    this.stepperElement.style.resize = "none";
    e.appendChild(this.stepperElement);
    e.style.width = "32px";
    this.blockEvent = !1;
    this.stepperElement.addEventListener("change", function(a) {
        a.target != d.sliderElement && (d.sliderElement.value = d.stepperElement.value);
        d.fireChangeEvent()
    }
    , !1);
    this.sliderElement.addEventListener("change", 
    function(a) {
        a.target != d.stepperElement && (d.stepperElement.value = d.sliderElement.value);
        d.fireChangeEvent()
    }
    , !1)
}
OptionSlider.prototype = Object.create(THREE.EventDispatcher.prototype);
OptionSlider.prototype.fireChangeEvent = function() {
    if (!this.blockEvent) {
        this.value = this.sliderElement.value;
        var a = new CustomEvent("change",{
            target: this,
            value: this.sliderElement.value
        });
        this.dispatchEvent(a)
    }
}
;
OptionSlider.prototype.setValue = function(a) {
    this.blockEvent = !0;
    this.value = a;
    this.sliderElement.value = a;
    this.stepperElement.value = a;
    this.blockEvent = !1
}
;
function OptionCheckbox(a, b, c) {
    THREE.EventDispatcher.call(this.prototype);
    var e = this;
    this.tbody = b;
    this.sliderRow = this.tbody.insertRow(-1);
    b = this.sliderRow.insertCell(0);
    b.style.fontStyle = "italic";
    this.caption = document.createElement("div");
    this.caption.innerHTML = a + ":";
    b.appendChild(this.caption);
    b = this.sliderRow.insertCell(1);
    this.checkElement = document.createElement("input");
    this.checkElement.type = "checkbox";
    this.checkElement.id = a + "_check";
    this.checkElement.checked = c;
    b.appendChild(this.checkElement);
    this.blockEvent = !1;
    this.checked = c;
    this.checkElement.addEventListener("change", function(a) {
        e.fireChangeEvent()
    }
    , !1)
}
OptionCheckbox.prototype = Object.create(THREE.EventDispatcher.prototype);
OptionCheckbox.prototype.fireChangeEvent = function() {
    if (!this.blockEvent) {
        this.checked = this.checkElement.checked;
        var a = new CustomEvent("change",{
            target: this,
            value: this.checkElement.checked
        });
        this.dispatchEvent(a)
    }
}
;
OptionCheckbox.prototype.setValue = function(a) {
    this.blockEvent = !0;
    this.checked = a;
    this.checkElement.checked = a;
    this.blockEvent = !1
}
;
function OptionDropDown(a, b, c, e) {
    THREE.EventDispatcher.call(this.prototype);
    var d = this;
    this.tbody = b;
    this.sliderRow = this.tbody.insertRow(-1);
    b = this.sliderRow.insertCell(0);
    b.style.fontStyle = "italic";
    this.caption = document.createElement("div");
    this.caption.innerHTML = a + ":";
    b.appendChild(this.caption);
    b = this.sliderRow.insertCell(1);
    this.dropdownElement = document.createElement("select");
    this.dropdownElement.id = a + "_dropdown";
    for (a = 0; a < c.length; a++) {
        var g = document.createElement("option");
        g.value = a;
        g.text = 
        c[a];
        this.dropdownElement.add(g)
    }
    this.selectedIndex = this.dropdownElement.selectedIndex = e;
    b.appendChild(this.dropdownElement);
    this.blockEvent = !1;
    this.dropdownElement.addEventListener("change", function(a) {
        d.fireChangeEvent()
    }
    , !1)
}
OptionDropDown.prototype = Object.create(THREE.EventDispatcher.prototype);
OptionDropDown.prototype.fireChangeEvent = function() {
    if (!this.blockEvent) {
        this.selectedIndex = this.dropdownElement.selectedIndex;
        var a = new CustomEvent("change",{
            target: this,
            value: this.selectedIndex
        });
        this.dispatchEvent(a)
    }
}
;
function RenderOptionsPanel(a) {
    var b = this;
    this.viewer = a;
    this.dockPanel = new DockingPanel(a,"RenderOptionsPanel","Rendering Options",!1);
    this.table = document.createElement("table");
    this.table.id = "optionsgrid";
    this.table.className = "tftable";
    this.tbody = document.createElement("tbody");
    this.table.appendChild(this.tbody);
    this.dockPanel.container.appendChild(this.table);
    this.envMapToggle = new OptionCheckbox("Use Default Environment",this.tbody,!1);
    this.envMapToggle.addEventListener("change", function(c) {
        b.envMapToggle.checked ? 
        a.setEnvironmentMap("environments/sky_px.jpg environments/sky_nx.jpg environments/sky_py.jpg environments/sky_ny.jpg environments/sky_pz.jpg environments/sky_nz.jpg".split(" ")) : a.setEnvironmentMap()
    }
    );
    this.saoToggle = new OptionCheckbox("SSAO Enabled",this.tbody,!0);
    this.saoToggle.addEventListener("change", function(c) {
        a.setQualityLevel(b.saoToggle.checked, a.impl.renderer.settings.antialias)
    }
    );
    this.saoRadius = new OptionSlider("SSAO Radius",0,300,this.tbody);
    this.saoRadius.setValue(100);
    this.saoRadius.addEventListener("change", 
    function(c) {
        a.impl.renderer.setAOOptions(b.saoRadius.value, b.saoIntensity.value);
        a.impl.renderer.composeFinalFrame(!1)
    }
    );
    this.saoIntensity = new OptionSlider("SSAO Intensity",0,300,this.tbody);
    this.saoIntensity.setValue(75);
    this.saoIntensity.addEventListener("change", function(c) {
        a.impl.renderer.setAOOptions(b.saoRadius.value, b.saoIntensity.value);
        a.impl.renderer.composeFinalFrame(!1)
    }
    );
    this.toneMapMethod = new OptionDropDown("Tonemap method",this.tbody,"None;Linear;Reinhard RGB;Filmic RGB;Exp RGB;Canon".split(";"),
    0);
    this.toneMapMethod.addEventListener("change", function(c) {
        a.impl.renderer.setTonemapMethod(b.toneMapMethod.selectedIndex);
        var e, d;
        e = b.toneMapMethod.selectedIndex;
        0 == e ? (e = 1,
        c = 0,
        d = 1) : (d = 2,
        c = 0,
        e = 5 == e ? 4.4 : 1.7);
        b.gamma.setValue(e);
        a.impl.renderer.setGamma(e);
        b.exposureBias.setValue(c);
        a.impl.renderer.setExposureBias(c);
        b.whiteScale.setValue(d);
        a.impl.renderer.setWhiteScale(d);
        a.impl.dir_light1.intensity = b.whiteScale.value;
        0 == b.toneMapMethod.selectedIndex ? a.impl.setClearColors(41, 76, 120, 1, 2, 3) : a.impl.setClearColors(200, 
        233, 255, 100, 116, 127)
    }
    );
    this.gamma = new OptionSlider("Gamma",0,5,this.tbody);
    this.gamma.setValue(1);
    this.gamma.sliderElement.step = this.gamma.stepperElement.step = .05;
    this.gamma.addEventListener("change", function(c) {
        a.impl.renderer.setGamma(b.gamma.value);
        a.impl.renderer.composeFinalFrame(!1)
    }
    );
    this.exposureBias = new OptionSlider("Exposure bias",-5,5,this.tbody);
    this.exposureBias.setValue(0);
    this.exposureBias.sliderElement.step = this.exposureBias.stepperElement.step = .1;
    this.exposureBias.addEventListener("change", 
    function(c) {
        a.impl.renderer.setExposureBias(b.exposureBias.value);
        a.impl.renderer.composeFinalFrame(!1)
    }
    );
    this.whiteScale = new OptionSlider("Direct Light Intensity",0,10,this.tbody);
    this.whiteScale.setValue(1);
    this.whiteScale.sliderElement.step = this.whiteScale.stepperElement.step = .1;
    this.whiteScale.addEventListener("change", function(c) {
        a.impl.dir_light1.intensity = b.whiteScale.value;
        a.impl.renderer.setWhiteScale(b.whiteScale.value);
        a.impl.needsClear = !0
    }
    );
    this.fovAngle = new OptionSlider("Field of View (degrees)",
    6.88,100,this.tbody);
    this.fovAngle.setValue(45);
    this.fovAngle.addEventListener("change", function(c) {
        a.setFOV(parseFloat(b.fovAngle.value))
    }
    );
    this.viewer.addEventListener("cameraChanged", function(c) {
        c = parseFloat(b.fovAngle.value);
        var e = a.getFOV();
        c != e && b.fovAngle.setValue(e)
    }
    );
    this.dockPanel.container.style.width = "300px";
    this.dockPanel.container.style.top = "180px";
    this.dockPanel.container.style.left = "220px";
    this.dockPanel.container.style.height = "420px";
    this.dockPanel.container.dock = !0;
    this.dockPanel.container.style.display = 
    "none"
}
;function AlertBox() {}
AlertBox.instances = [];
AlertBox.displayNotice = function(a, b, c) {
    var e = document.createElement("div");
    e.className = "alertBox notice";
    var d = document.createElement("div");
    d.className = "alertBoxText notice";
    d.scrollTop = 0;
    window.getSelection().removeAllRanges();
    d.textContent = b;
    e.appendChild(d);
    c && (b = document.createElement("div"),
    b.innerHTML = c,
    e.appendChild(b));
    c = document.createElement("div");
    c.className = "alertBoxOK";
    c.textContent = "OK";
    var g = {
        alertBox: e,
        container: a
    };
    c.addEventListener("click", function(b) {
        e.style.visibility = "hidden";
        a.removeChild(e);
        AlertBox.instances.splice(AlertBox.insatnces.indexOf(g), 1)
    }
    );
    e.appendChild(c);
    e.style.visibility = "visible";
    a.appendChild(e);
    AlertBox.instances.push(g)
}
;
AlertBox.displayError = function(a, b) {
    var c = document.createElement("div");
    c.className = "alertBox error";
    var e = document.createElement("div");
    e.className = "alertBoxText error";
    e.scrollTop = 0;
    window.getSelection().removeAllRanges();
    e.textContent = b;
    c.appendChild(e);
    e = document.createElement("div");
    e.className = "alertBoxOK";
    e.textContent = "OK";
    var d = {
        alertBox: c,
        container: a
    };
    e.addEventListener("click", function(b) {
        c.style.visibility = "hidden";
        a.removeChild(c);
        AlertBox.instances.splice(AlertBox.instances.indexOf(d), 
        1)
    }
    );
    c.appendChild(e);
    c.style.visibility = "visible";
    a.appendChild(c);
    AlertBox.instances.push(d)
}
;
AlertBox.dismiss = function() {
    if (0 < AlertBox.instances.length) {
        var a = AlertBox.instances.pop();
        a.alertBox.style.visibility = "hidden";
        a.container.removeChild(a.alertBox);
        return !0
    }
    return !1
}
;
function TreeDelegate() {}
TreeDelegate.prototype.isTreeNodeGroup = function(a, b) {
    throw "isGroup is not implemented.";
}
;
TreeDelegate.prototype.getTreeNodeId = function(a) {
    throw "getId is not implemented.";
}
;
TreeDelegate.prototype.getTreeNodeLabel = function(a) {
    return a.name
}
;
TreeDelegate.prototype.shouldCreateTreeNode = function(a) {
    return !0
}
;
TreeDelegate.prototype.onTreeNodeClick = function(a, b, c) {}
;
TreeDelegate.prototype.onTreeNodeHover = function(a, b, c) {}
;
TreeDelegate.prototype.getTreeNodeClass = function(a) {
    return ""
}
;
function Tree(a, b, c, e) {
    this.myDelegate = a;
    this.mySelectedIds = [];
    this.myParentContainerId = c;
    this.myRootContainerId = c + "-treeview";
    this.myInternalIds = [];
    this.myInternalIdCounter = 0;
    this.jQuery = (this.myOptions = e) && e.jQuery ? e.jQuery : $;
    this.jQuery('<div id="' + this.myRootContainerId + '" class="treeview"></div>').appendTo("#" + c);
    this.createElement(b, this.myRootContainerId)
}
Tree.prototype.show = function(a) {
    a ? this.jQuery("#" + this.myRootContainerId).fadeIn() : this.jQuery("#" + this.myRootContainerId).hide()
}
;
Tree.prototype.getRootContainerId = function() {
    return this.myRootContainerId
}
;
Tree.prototype.delegate = function() {
    return this.myDelegate
}
;
Tree.prototype.isCollapsed = function(a) {
    a = "#" + this.getInternalId(a, !1);
    return this.jQuery(a).hasClass("collapsed")
}
;
Tree.prototype.setCollapsed = function(a, b) {
    var c = "#" + this.getInternalId(a, !1);
    if (b) {
        if (!this.jQuery(c).hasClass("collapsed"))
            return this.jQuery(c).addClass("collapsed"),
            this.jQuery(c).removeClass("expanded"),
            !0
    } else if (this.jQuery(c).hasClass("collapsed"))
        return this.jQuery(c).removeClass("collapsed"),
        this.jQuery(c).addClass("expanded"),
        !0;
    return !1
}
;
Tree.prototype.addToSelection = function(a) {
    for (var b in a) {
        var c = a[b], e;
        e = c;
        -1 == this.mySelectedIds.indexOf(e) ? (this.mySelectedIds.push(e),
        e = !0) : e = !1;
        e && (c = this.getInternalId(c, !1),
        this.jQuery("#" + c).addClass("selected"))
    }
}
;
Tree.prototype.removeFromSelection = function(a) {
    for (var b in a) {
        var c = a[b], e;
        e = this.mySelectedIds.indexOf(c);
        -1 != e ? (this.mySelectedIds.splice(e, 1),
        e = !0) : e = !1;
        e && (c = this.getInternalId(c, !1),
        this.jQuery("#" + c).removeClass("selected"))
    }
}
;
Tree.prototype.setSelection = function(a) {
    this.removeFromSelection(this.mySelectedIds);
    this.addToSelection(a);
    return this.mySelectedIds
}
;
Tree.prototype.clearSelection = function() {
    this.removeFromSelection(this.mySelectedIds)
}
;
Tree.prototype.isSelected = function(a) {
    a = this.getInternalId(a, !1);
    return this.jQuery("#" + a).hasClass("selected")
}
;
Tree.prototype.getInternalId = function(a, b) {
    void 0 === this.myInternalIds[a] && b && (this.myInternalIds[a] = this.myRootContainerId + "-node-" + this.myInternalIdCounter,
    this.myInternalIdCounter++);
    return this.myInternalIds[a]
}
;
Tree.prototype.createElement = function(a, b) {
    if (a) {
        var c = this;
        if (this.myDelegate.shouldCreateTreeNode(a)) {
            var e = c.myDelegate.getTreeNodeId(a)
              , e = this.getInternalId(e, !0)
              , d = "#" + e;
            if (c.myDelegate.isTreeNodeGroup(a)) {
                this.jQuery('<group id="' + e + '" class="expanded"></group>').appendTo(this.jQuery("#" + b)).hover(function() {
                    c.myDelegate.onTreeNodeHover(c, a)
                }
                );
                var g = "#header" + e;
                this.jQuery('<header id="header' + e + '"></header>').appendTo(this.jQuery(d)).click(function(b) {
                    c.myDelegate.onTreeNodeClick(c, a, b)
                }
                );
                this.jQuery("<icon></icon>").appendTo(this.jQuery(g)).click(function(a) {
                    a.stopPropagation();
                    c.jQuery(d).toggleClass("collapsed");
                    c.jQuery(d).toggleClass("expanded")
                }
                );
                this.jQuery("<label>" + c.myDelegate.getTreeNodeLabel(a) + "</label>").appendTo(this.jQuery(g));
                for (var f in a.children)
                    c.createElement(a.children[f], e)
            } else
                this.jQuery('<leaf id="' + e + '"></leaf>').appendTo(this.jQuery("#" + b)).hover(function() {
                    c.myDelegate.onTreeNodeHover(c, a)
                }
                ),
                g = "#header" + e,
                this.jQuery('<header id="header' + e + '"></header>').appendTo(this.jQuery(d)).click(function(b) {
                    c.myDelegate.onTreeNodeClick(c, 
                    a, b)
                }
                ),
                this.jQuery("<icon></icon>").appendTo(this.jQuery(g)),
                this.jQuery("<label>" + c.myDelegate.getTreeNodeLabel(a) + "</label>").appendTo(this.jQuery(g));
            this.jQuery(d).addClass(c.myDelegate.getTreeNodeClass(a))
        }
    }
}
;
function BrowserDelegate() {}
BrowserDelegate.prototype.getNodeId = function(a) {
    throw "getId is not implemented.";
}
;
BrowserDelegate.prototype.getNodeLabel = function(a) {
    return a.name
}
;
BrowserDelegate.prototype.getNodeClass = function(a) {
    return ""
}
;
BrowserDelegate.prototype.hasThumbnail = function(a) {
    return !1
}
;
BrowserDelegate.prototype.getThumbnail = function(a) {
    return null 
}
;
BrowserDelegate.prototype.onNodeClick = function(a, b, c) {}
;
BrowserDelegate.prototype.onNodeHover = function(a, b, c) {}
;
function Browser(a, b, c, e) {
    this.myDelegate = a;
    this.mySelectedIds = [];
    this.myParentContainderId = c;
    this.myRootContainerId = c + "-browserview";
    this.myInternalIds = [];
    this.myInternalIdCounter = 0;
    this.jQuery = (this.myOptions = e) && e.jQuery ? e.jQuery : $;
    this.jQuery('<div id="' + this.myRootContainerId + '" class="browserview"></div>').appendTo("#" + this.myParentContainderId);
    this.createElements(b, this.myRootContainerId)
}
Browser.prototype.show = function(a) {
    a ? this.jQuery("#" + this.myRootContainerId).fadeIn() : this.jQuery("#" + this.myRootContainerId).hide()
}
;
Browser.prototype.getRootContainerId = function() {
    return this.myRootContainerId
}
;
Browser.prototype.delegate = function() {
    return this.myDelegate
}
;
Browser.prototype.addToSelection = function(a) {
    for (var b in a) {
        var c = a[b], e;
        e = c;
        -1 == this.mySelectedIds.indexOf(e) ? (this.mySelectedIds.push(e),
        e = !0) : e = !1;
        e && (c = this.getInternalId(c, !1),
        this.jQuery("#" + c).addClass("selected"))
    }
}
;
Browser.prototype.removeFromSelection = function(a) {
    for (var b in a) {
        var c = a[b], e;
        e = this.mySelectedIds.indexOf(c);
        -1 != e ? (this.mySelectedIds.splice(e, 1),
        e = !0) : e = !1;
        e && (c = this.getInternalId(c, !1),
        this.jQuery("#" + c).removeClass("selected"))
    }
}
;
Browser.prototype.setSelection = function(a) {
    this.removeFromSelection(this.mySelectedIds);
    this.addToSelection(a);
    return this.mySelectedIds
}
;
Browser.prototype.clearSelection = function() {
    this.removeFromSelection(this.mySelectedIds)
}
;
Browser.prototype.getInternalId = function(a, b) {
    void 0 === this.myInternalIds[a] && b && (this.myInternalIds[a] = this.myRootContainerId + "-node-" + this.myInternalIdCounter,
    this.myInternalIdCounter++);
    return this.myInternalIds[a]
}
;
Browser.prototype.createElements = function(a, b) {
    if (a)
        for (var c = 0; c < a.length; c++)
            this.createElement(a[c], b)
}
;
Browser.prototype.createElement = function(a, b) {
    var c = this
      , e = c.myDelegate.getNodeId(a)
      , d = c.getInternalId(e, !0)
      , e = "#" + d;
    this.jQuery('<item id="' + d + '"></item>').appendTo(this.jQuery("#" + b)).hover(function() {
        c.myDelegate.onNodeHover(c, a)
    }
    );
    this.jQuery("#" + d).click(function(b) {
        c.myDelegate.onNodeClick(c, a, b)
    }
    );
    d = c.myDelegate.getNodeLabel(a);
    this.jQuery("<label>" + d + "</label>").appendTo(this.jQuery(e)).click(function(b) {
        c.myDelegate.onNodeClick(c, a, b)
    }
    );
    (d = c.myDelegate.getThumbnail(a)) && this.jQuery('<img class="thumb" src="' + 
    d + '" ></img>').appendTo(this.jQuery(e)).click(function(b) {
        c.myDelegate.onNodeClick(c, a, b)
    }
    );
    this.jQuery(e).addClass(c.myDelegate.getNodeClass(a))
}
;
var METADATA = METADATA || {}
  , SELECTION_CHANGED_EVENT = "selection"
  , ISOLATE_EVENT = "isolate"
  , HIDE_EVENT = "hide"
  , SHOW_EVENT = "show"
  , PROGRESS_UPDATE_EVENT = "progress"
  , ERROR_EVENT = "error"
  , ESCAPE_EVENT = "escape"
  , NAVIGATION_MODE_CHANGED_EVENT = "navmode"
  , CAMERA_CHANGE_EVENT = "cameraChanged"
  , HIGHLIGHT_EVENT = "highlight"
  , GEOMETRY_LOADED_EVENT = "geometry_loaded"
  , NAVIGATION_MODE = {
    ORBIT: 0,
    PAN: 1,
    DOLLY: 2,
    ROLL: 3,
    FOV: 4,
    OTHER: 5
};
METADATA.BaseViewer3D = function(a, b) {
    METADATA.Viewer.call(this, a, b);
    this.config = b;
    if ("CANVAS" == this.container.nodeName)
        throw "Viewer must be initialized on a div [temporary]";
    this.canvas = document.createElement("canvas");
    this.canvas.tabIndex = 0;
    var c = this.getDimensions();
    this.canvas.width = c.width;
    this.canvas.height = c.height;
    this.container.appendChild(this.canvas);
    this.canvas.viewer = this
}
;
METADATA.BaseViewer3D.prototype = Object.create(METADATA.Viewer.prototype);
METADATA.BaseViewer3D.prototype.constructor = METADATA.BaseViewer3D;
METADATA.BaseViewer3D.kDefaultCanvasConfig = {
    click: {
        onObject: ["setCOI"],
        offObject: ["deselectAll"]
    },
    clickCtrl: {
        onObject: ["selectToggle"]
    },
    clickCtrlShift: {
        onObject: ["deselectAll"],
        offObject: ["deselectAll"]
    }
};
METADATA.BaseViewer3D.prototype.initialize = function() {
    var a = this.detectWebGL();
    if (0 >= a) {
        var b = "Could not detect WebGL support on your browser."
          , c = null ;
        0 === a ? (b = "WebGL is currently disabled on your browser.\nHere's how to enable WebGL on your browser:",
        c = '<a href="webGLHelp.html" style="color:red;" target="_blank">METADATA 360 Viewer Prerequisites</a>') : -1 === a && (b = "WebGL is not supported on your browser.");
        AlertBox.displayNotice(this.container, b, c);
        return !1
    }
    var e = this;
    this.impl = new Viewer3DImpl(this.canvas,
    this);
    this.setCanvasClickBehavior(this.config && this.config.canvasConfig ? this.config.canvasConfig : METADATA.BaseViewer3D.kDefaultCanvasConfig);
    window.addEventListener("resize", function(a) {
        e.resize()
    }
    , !1);
    this.loader = document.createElement("div");
    this.loader.id = "loader";
    this.loader.className = "loaderoverlay";
    this.container.appendChild(this.loader);
    this.loaderimage = document.createElement("img");
    this.loaderimage.id = "loaderimage";
    this.loaderimage.className = "loaderimage";
    this.loaderimage.alt = "";
    this.loaderimage.src = 
    "data:image/gif;base64,R0lGODlhgACAAIQAAAQCBDQyNBwaHExKTAwODDw+PCQmJFRWVAwKDDw6PCQiJFRSVBQWFERGRCwuLFxeXAQGBDQ2NBweHExOTBQSFERCRCwqLFxaXAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH/C05FVFNDQVBFMi4wAwEAAAAh+QQJCQAYACwAAAAAgACAAAAF/iAmjmRpnmiqlpDTXFfjQGtt33iu7yOzXI8gcMHgGY/IZE0ChDVhD4FySq3aIFBh8AE80KzgMNXx5HKbj4B4zd4NzGZgfNCu21NQtP5xuPv/B3GCTX1/hikUCRMPCwVSOm97enSHlSQBW3IXBV83DoODDpajEU6DFTlYknGdo38CmqAKORKgTRJICK48FbZmEzoCi3oLjzwSBxcLFLs5gatNujkADgNAAw4AR1hmB9rNNRC+aAS7THFF4CsA0HHSowRxF+/qKdbjhbuYQAb1NQbtLqgBR0BBOX81Xtia0AqhwxMIGoCacPChxRMALCzoFuDbxY8nCFCoCLKkyZMo/lOqXMmypcuXMGPKNAJBQYEBAwIwm7mLwiJBHXlaIvBsUAShle7t4YILqQ0CFiIo8KiDwrgHqJyuQLARSNYdFq7m04qigJ50Oj4FpEq2xAQ0D2aBvbqgbYoE8tDmIBAwgV0UCN5y8WukF7Sdf01AMCA1V9dQiesgUHqmX2Q7AiJUSGCh4eXPoEOLHk26tOnTqFOrXs26tevXsGPLnm0RgIFIC2bQDqcQzbLdKhKsmsC2NYICCyZEYAvLlyjYCIpeGEAVL7S6sAsMsixCYrviqh/LKUDCu60LscUPJhHB1wNKr9vraSqCQp7tsSejOVpi3yDqstmWQATG9LdHBZ4B/lcCBQE0MEACBSoo4YQUVmjhhRhmqOGGHHbo4YcghihiJQhQQAF4FlIgERcHZKPhOXo0gOJfGTlYAGI7RLdUGqIB0BsM9KUlCQxehBZWLEXu0JsgXOgVmWD3BYlDJLZImVgy+O2g3WGhGSZIhDco4At2oDWHRgNG+GgLmJEB1MQA9OignzxyjbaYBVbuYFsDEwwQAUkjBirooIQWauihiMqWIIYICMfFjf4AIIABbIJEQVFn5FnJpVAQgRIE4hES56ZYnnEAoBcBBMoDz7mypByElSQfKF9Zwo4WTZAJknWgoOkKN3uM9REZtvDnyjCC1PoRAvehgaMlYu5R6UOqVurR6g4ERIDTn0gEoAd3JyFDCLg6KKDHBXXywEAAERgw6kkMKMDAjDXYN8gFz1LIK1yxWoisHsBg+G8cAV+4bxzkYWjvuflS6GYc5F6Y7baoJmqxHSEAACH5BAkJABgALAAAAACAAIAAAAX+ICaOZGmeaKqakBJECrLOdG3feF4a1/X8F4tuSCwaa4Xeo+e7NCDHqHRaC/iWQGCCyu1SIcom9krwms85xXjddKDf8JSDzS7E7/gAXXyx5wAUDBQAeFMUFhEOAjo8e1huNwgRB00HETKFRAgNfAsMOAh8dBQ3DAuiF56ZOggLe4s3EY5Okad7B5irNg2OuDcAA3sLuTQFsw8VujYMqGOQNgBWawlQNqHHF8TKKdLNtDkEBgkJBqQ4at5YCtszCccLuhbYD0LsKrLpA7oG8/X2KOgcbVnFDNunfyggUHJ0cJUtb/AQphDgKMI2iulgSQQYBksEQtu6sXm2EQWBCMH+JlRoyE7BwkrrSsqsAUBChAQRJICcybOnz59AgwodSrSo0aNIkx5hYEBBGaUlFbhS0uApVHtz+Fw4YO6qMgHNHizY6fUGhK5DOO25IKEsDnlb0f5K92CgWxoMxkTMgWDWhWR3aVjgo40mXbuBVeRtsjeH2mYxE69w0ERjDox0xkqmAYEBWR1Z13DdXMilmKqkMwEQ0NRq6tewY8ueTbu27du4c+vezbu379/AgwsfTlxZTQcwChdfQWECH3/LVxBoRrI4hM8jeKG64Fo4ggpLCmijkC7AcrXhSwRE1aB4XzEPqolQkA7w8Pdj5GMgMMt8cfBN+EFCBc34Yh2ABej+JwICL41hQHQiAIDdCAQEU8mDENZAgQIWCKBghiCGKOKIJJZo4okopqjiiiy26OKLMMYomQAFDDBABN2diM8SW7WFW00GWKaDSFdwd5spWDwxBBjbCTgbBFNhgdgN9NHxwAG2rcfjhzQ00syEqVG2xgM50oCZKI3JJgEbF4C5AgANiuEfbQA45wwRWvqwAJewfdeGETyIMUGZswHCJw4QGBBBBELK6OijkEYq6aSUVmqpdQo0dSiJBlDShI8IGeDcBNAFFRCPbCHkjhhO/gQnKge4eQdYY/jQKE9nrgGqMjsWOWVPeapjz6prtNpTQajcWgg/opTq00N6/QPlGntYDoXsGMrWIME4Bmw6AwETYDGAXEAxYOEDE7AEinZLLEAuDgzEkBQBAhBqw7mMeQvhtWJgeCKzbFiEopdrzGniNaJkG6IefNiXImVNBKBviBAI4OGlGOsSAgAh+QQJCQAYACwAAAAAgACAAAAF/iAmjmRpnmiqogSxvnAsz3R9QtFxPVeB2MCgcBhjLHbIy0FCbDqfMoSOR+VdGNCsNpugIr2DrXhsAxy86N2PzG6zHmm0wE2vU754KrPOX0EoazUQeXkUNQQRAxMDES59QgIDSAsWNhVxkzUWF3kOj0AOhA0ANHeYD3syAXCEEZ80EoQ8rjQKZ3kBNAKcp3OvMROynIEyBMFUC74zl8IXFb8wBMJwBkAECgaGNQDTVqTQKrunF7R9CNM7D8TgJgzouY8Q41QQ7CmD08p9E/ML9ioRhE34FWqcp38oIBzDc0HbJ4UC6yFEgYAZlQkOXxFYEGeBo4kpKASIEEEfNAQ5/rxEWAey5T0KCihIdEmzps2bOHPq3Mmzp8+fQO1dMyBgZlB7EiR58REEggOOFxooOArEAqYFGaPww5OAKqxTDxYYhQFgAKaDXl+YafYAngwJpw58S6sCriwqcmcUyEd3RYR5O7DIaDBtat8UXdBdMLmiAt/DKP52eyA4hoFmYyGPUAD4QmYVEOOg1VwCwhRhXUsdQfOMNAoF0xawhAEhwa0J1VynWEXoQGUgs3WbkLAaSYXgwrcIMOBAwcfk0KNLn069uvXr2LNr3869u/fv4MOLj04g63gZABzcelDg+fkXFpEccP8exeU4YeorKFCBMYaFXuxg3nd28fAbBgDE/kGFYeMRRkVqJBCCBIPiObgDhCMAmM4O9H0HGxUHYsCZKPWJWEAB/mGQmBeylQiDAluR85mLFCFH44045qjjjjz26OOPQAYp5JBEFmnkkUjadM2APTKwVVgU9nhHHlFOh4ADEVRJg1l5HDCjcARM8QCGNEiDiZbJrbhDii+IQ0gl1SmFBJyHnIKmcJJRweYLT+Jho2uhkSMEA6dRQWd1EBgQQCpBUADVAwcc+iMAEiigwFxJZqrpppx26umnoIbaHQEMMMkjAg6GFeIvCBgQgQVfugRBcUis+oijeNnqUgBfUJEfOH2GtZOGVPzZBgWseKErSMEi0SEfblbBqE2OVqWRFzTyMGTsPwyIZg+vKvFk1RcVYLoNAwzEGoMFOhwwmk4EOFBBAtPWYMucQsaCxrs8FueFuiVmm8ayLg4Sh6k3WohMkGEGSPCNFenQAMKiVmxxDSEAACH5BAkJABgALAAAAACAAIAAAAX+ICaOZGmeaKqubOu+cCzLRFA1ATPvfO/DgcflIXwkAL+kcgmLDJ/FAnNKpTKg2Iekyu3uIsXspeEtm1cTcfFwbrtFk7D8cnnbyxX1cLAjGP4Idz8SBQMVBhAzCnoPDjIIBXIFgYKPA09DCzoyl3MPC4kwCAdiCwSVMABpRWGnMQgNcxOuMKtZD3yoLhZ6UjMWnQMBSDESjBdbuiyxeqE7xDMJnlAJyiwH00IUlQ3HZNYqC4yUd93ZFxXgKgV6C6gO5w8B6ilXno2oFMe09CYBYul0wVMzr18KBQvWDLMGJksEgywoGGDgzJqAPEIqCIDIsaPHjyBDihxJsqTJkyj+U6pcydKOgm4XFiTY1gOBgQQRkrV8BZPVBUc7DNApMmvnCwCdbgGNsWgOKKMt/k2jQ/MotlsFoaYAQOoekWowjE1jo7WeHjoXJjA9B61sCQHZiDwg+6KpGLpuSzA4lykGhKFZwOYt8feYLxgD5/AbPEIao40yEmA5AJkx4a5iDstgcGOAA3KWS1BImKVC29BVIES4+mCCAdRuKFAADbu27du4c+vezbu379/AgwsfTry48eNMIFgosGBCAQOnkdcTFybtYgw1GlQIUJG43TkXNolYBIWycQisS4UiAFjIhQO0gQc5ZkFEJDEPiVNn9A2znFzCAdCeGu5g4B8mAAb+B0A8fWGAERRC5DdcHN6IABcWdFz3W0Pn1CcCL9XpNJw+jBxQEQUVNFeAhsEZcE5l0qEgVBYHiBgjCghEQN0E3N3o449ABinkkEQWaeSRSCap5JJMNulkbwZQWAGLQnL4RFW5IYDlDnthqJZuAx2wZQySyaFNbhcSUeAOD8phI2wgPhHfC1aGMSZqXQqx5gwUePJlbmWa14NUTywwZ20QUBCdIpdcMMmTkEYq6aSUVmrppZhmqilxAhQwQQMeJgliEQGBg0AAOHQHEgJiKAAOBBS2dihHFnjyjTKECrFUSIlBkSAqZT4hWEjfCQuOi1C4OpIqioEDwIPDikRArII/qsPARCgBIIEBCqgaAwABTDBBAt4OqQomTyHpAIQXREukOVD8aWSbeyQplBy7zuvrokQaUEABFvC76cAE7xACACH5BAkJABgALAAAAACAAIAAAAX+ICaOZGmeaKqubOu+cCzPiCQhc67vfEw0l8fjMiD0jsik7xBsPg4UpXRKHQyvzQmAyu3mGNjwQ+Itm1cOp/oROLvfosDaGYHby4qw2rLb3o8ADAYCEDkIB3pDFzgyAgVCFxUMfzoKC4oHDjlpiW0yDpBYfJQxBmIXCTlyYZ6liUFkpC4IF3MPkzMUAQMDEVEyAIi2C7IuFraopBKvV7jFKgnMA6THzBcKzysRyA2kpshj2Sp5tq13DOAXRuIoABOJB4yUE9zsKhRMWBexpBS1eovsqUCQQFiFdcUYXHKy4JfAhysgGEgwIIECPxAzatzIsaPHjyBDihxJsqTJkyj+U+oAICFCBAsId1C4oTKHhHxBHlQo9OXdkAX8arYwMOfCAp4x0Cm6gk0oC1rIKsx4l7PJAYxOUUSw9sChCwrMBGRVsZDZqBcSkBkYm4LrhTowwNoKypbEP2RnXyyYcwBpXRIVwD0QGyOtnqZ/SwiwNsFm2WuJUUQr6gyYgEFYI5MAMBnLAbqaqTiiNyCAvNCoU6tezbq169ewY8ueTbu27du4c+vezQ6CAAsGGGTmrSJN1QOIS9Qw4BU3hAF3saQqAerfTt0FbA3JG+CKIi24/b0K0lcErUTJaVdPxFTEsjnTbT9KpwkDOT3xawfm6okA+7y0bcMVYvsx5Bdti6X+Iw8EBT7QkG4NWAMXCQI4EMFFuxHwGBYDDEccCQhEqEYBHn5YAgMWFJAAcya26OKLMMYo44w01mjjjTjmqOOOfxBggAISHDijBFY0gcppMa6nBhQ6QGCBS4Spdt8cR82gIR2qBZPOhDBQhcVaqE35ylUxJBjGNKglkM4QzbFAlB4HpNYgMlG6YKYTaIa21ZptruCOHmCG9o01F5SoAgM4PZCfZhBENweXMCDgQAIJ1Inam8MI2aKAazBJoyVqVIDkkAoEoMCoPKaq6qqsturqq7BSIcGPhsKIAD1BPMgOAQrE9BEQoSxQKxygDBGoRwTMYSkl/hmJakZKqZEeJYZS5dRnRo2uURkph0BSHkicDiGVOAowscC2HQEgRxAJaCqLryFBQIG7MkBAr4wMBnEdjhVgUQCOEIhxb4vnOTFwiw3+C/B8BRz8IgDDxirxxFSEAAAh+QQJCQAYACwAAAAAgACAAAAF/iAmjmRpnmiqrmzrvnAsz3Rt33gsNNdVMbmgcPhKXB7IxyVCbDqJFqXyeFQ8r9jZgYqkLrLgcIoi5VIJ4nSaUW5fKOp4FmFuQ+T4E4GCsPHcDwU0AAoRBRECeTUME1QNaDMEPW0LfTIUjV0PFXeKMBJ1B3AzmFwDozEQC3UPAwCeLhBbbg02FAYKqDIJmlQ9FrAtoIAPkHgAB8QXA8EsUXU9iXkEvW7NKwrED7pxdIBHX9cp3mYX4YoL35viKg6A0ooO0Erw7CcBZRdWsAANgEz2VCAwEEBBp2AAjJQBFrAhCwgKDEh45bCixYsYM2rcyLGjx48gQ4ocSbKkCQAU/viYDAYhQLIjDYDYYFChwQADFFe2gDDBjb4a8soMOKhThT9Wb2awqZOg6IqlPgPNKADtAlGnJSLMm5LzxQBW27CiqDDvyANLMP6UMyaWhMKyV1sYADSh7QkDZR/UlQHgaz6ZdknIKmuABoQELyfUCzxCwLwKNyBQYMu4hIB0XCJ0rewEgIQACSyg5Uy6tOnTqFOrXs26tevXsGPLnk27tu3bV1TifkGAKpIDEeLuLoE334MFlDEQIPsgpm3HVRcQpTCJioTaPZUFIHFUynHaUOedgxCVm2sLeY9QJOf9AmDY6NUdQduznHDWAuQ/OEBCQR0HtA2mTlMkSDDLBQzR/hZfVclhQAEDm83GCzTXDZeCAQe2Yp6FJjCAS4MchijiiCSWaOKJKKao4oostujiizAKZsEAShyQwIYhEpCJWb9ENhlqCGDWhhKF0RCAWQOA2JZvZY32gjtcLBBhWxCk9wCAMSDjxj6VSaDfBbXEwB4VWFZWXF57waAlFw9wyZh/+oUZQwSU3IfVmIBsxxeTC+C4pHwXKMkCAQoIMGVgCGTIZpkjMiAkFwSaiIBLUjSw2IkI+Bnjppx26umnWEEggQOhXUqiAoou8N6IR37jZohwlqUpO5MO4ICTeDzqE2QYCXicnWHkl5cSuAYEpRQJ4nFsXqbaM6EUkeKh1ZevXDY0ly/VqhFUeqs21I9ZFRwqBhnpWaWRAAY0G0d38wAkInVlHQBsWwpUUECFM4ACTZ+oxfpAt7wVUIaN87al1gPRzoAAA7kUbNfBCZvoJRUAl1jvvaBmrPHGT4QAACH5BAkJABgALAAAAACAAIAAAAX+ICaOZGmeaKqubOu+cCzPdG3feEwlQxMhuaBw+LI8Lo/jQUBsOomCoxR5AD6vWFljOg1kv2DVgYu8NMLoNGZcnp7VcGyj3fbG780o/VGtQQQKFHg2DAERAYI1BhdtSzUOjEcLDIMyAUllEjYECQ0NAVYzCZFtmpUui3QXTIN6ZAcQpy0TXElveBV7ZQqyKwBkZZW0ug92vSgAe0qVA2RSDscqFc4FlaPOq9EpFKRKiXgE3WUD2ioMB2UL34MKewsE5SuAlMcM0xcHP/H7/P3+/wADChxIsKDBgwgTKlzIsKFDfgwSTFhQwQAOABIcKIj18IUDMg04ziCwAMkRXh3+WSxyVoEGgJJHyqxLaQIAG2esYrSTIiUBzRQSiCGJMOPjHnI/TxjAdqSlDAu6nCYtIYHpA58yENwsY3FqCQRCL3SVsbRNNa8mEmA7AKCGvR5j0ZIA0IzOAXpynwCIcLMCvLxZIFCgEAqw4cOIEytezLix48eQI0ueTLmy5cuYM2t2oqDAgAEOZm42gWBAmyPQTihIkCAuZQATiKEkce9Ig7aVjTrrM2JlGwuW0WG7AHxE7XGVwVo9K2ILnQmVwzG9wBxDgD3GJCcTWowEhNhSFoicrFbo3xEQIkzUZxnCAmzZR5M4R6YCbvmkI7w3Mxu///8ABijggAQWaOCBCCb+qOCCDDZIIAEOFFBBAHgNqFsZDRT23zWqiGeDBBFshFhQzhyB1QwFjDOeXKZNt6ILVbVBFGDJTPdATjBc+IBUciFgo1gz7FTGjHlBwB0S/b0AgHMPDKAhWkwS86QLACgQgQUvoiUkSwIWgM0CU44GAIdSDHCegBRE8FkBCtzn4JtwxinnnHQmBMBgZw6IAF/hufYfA+9NgUQFWW6GwH7UDESAAnneUR5TOPYTgRRJwmHkkdXxI10ZhYbBwI8LABSjFKKl4UpYAIFVBls1EKAfEqB1igIFP0In6hiT1GCBcGXgE6kvvGJDJECNwgDVcBWyoOMexdIUDnceUtmiLqlMyUWmLkC+AMEcZFQrV7DE8AhjBehMkECzPxlZq3+/HPlAqP4hKpS4m0Xgrp+aPcvUAm7K5xswpY6mwFZHTIDuaAhYUMAC5hrQbzwhAAAh+QQJCQAYACwAAAAAgACAAAAF/iAmjmRpnmiqrmzrvnAsz3Rt37iMSAyU/8AgDBK5PC4Hg3DJZFaMxqOySa3OJNDj8eCzer+piDb7EIDPaEwhm1Wk31bLeEyA25mIA/vRuFEodXc2DAYUNwx6WgMINQITUYuCMhQTiow1EAEVBW41WHMLl5IteVAXFxMAkhCJbAOjLg5aD7QXnXcSc1mBsCoNplEBknJ7Rma9Kk+zp8KCCrpahsgpz3vSdxCnuhPTKwlsEbDVc8fdKQ4LqLejCtpI6+bxKRAKBhJd8vn6+/z9/v8AAwocSLCgwYMIEypcyNCLhAARFOCzAeFaQxeUaj04IMEGgAAHjhSYeBFFKV0d/mkUGdOnpIo10LjNyDbnAQOXKAC402XxBYNiU3CWQFBMS8oYBIodFTqCZtGbM36NWaCKaYkG0JBU1TEAyoGeVjH8hGbhhgQFCraGJdEO3ForBCIMGFCg3Nu7ePPq3cu3r9+/gAMLHky4sOHDiBMrXswYFgQBFhTwanxuZwNRJtQidlBsAUkMCAocSfBZMIWQxRKYkGpE9eEEWY9MRKBLs+ABsS9AFUGbje3AlYqWuTqmAGLYRS9gBt31QYXSgRnENn4CAfTBYvYcWE5ZBADOYyJ1R0HAQAQHdserX8++vfv38OPLn0+/vv37+PMbLq9g93sKzRmxQHrq/cSGEWV5/kTBdUIhsEBWF4D1wicXBPWWBck9QJ0M2eyClzJFHUADBTvBYxVuGTKYAgCoHTFZWCBCIyINY12Q4F0G5LbhDAAsqBcryUnYmAAtZmHhegBOtZR7FBjQn35QRinllFRWqQI9EWRJ4HoG7HTBAkvaIUEFjwwQAXfyfLPHETfCAQBypnDET5e5+ZcGTGScYmc3ADyYYUtvUFjTA1Tlk0uGRqDpRYwHDidPAIgeEeYXrWTlQD4rIWriF7kd0Uw8xHS6JwsCBFDAeS+6kE5uR05DQadIqDhUV+D8pkJ2saU6DVYZuubCSTVVYCt5Xha3z2mxeQZDgNBcCkM70Ci7D5HFWEygawoCdHrAsCgI4KcWwvqDgJpbBMDtCcjlNukKADwUgQXX6lMRA0KywGtubTbGWmz5MoZrclsqJgCi26637x79NobAI9D4ut5HcxywqXrlRRCABIp2EwIAIfkECQkAGAAsAAAAAIAAgAAABf4gJo5kaZ5oqq5s675wLM90bd94ru98rwqNy6GA8BmPPMPl8bgIi8ioFAZxNq+FqXaLElyXywN3PJZ8v+T0FHFeNtRwZAJ8FcTvPYDjurDXABIRFRYEeDIAARMPEwY4CAIUNxADXxcKhjAFTFYWmAV0YJGYLBRXVwcAeFVtDxGjLAasonECoFdvryoKtheFd6W8FbkqEAegA5gLtg+Nwym1YAu+eF6gBanOKQgOEQIQrwILVwnY2eYqFBTf5+zt7u/w8fLz9PX29/j5+vv8/f7/MSAoMOAHoJoAdBYwuAEogoV1BlcEqORk2iFNTiZAjHiCAp1ND3DNUGDqggOOKf4cgKKzEQZCU1lQnojAq4lFGCTBmJR5wgKrJS1fAMD4YEFQnghqCvtjwOFRnhhUnjlwE6oPA8aaDKhq1QcAChK4dh1LtqzZs2jTql3Ltq3bt3Djyp1Lt67du3gNqcvbAgHRPnxTUMhq5UIAFAoqFJBQF4CiJWcKjth1ZeFcCTUvLCURZBzdPTUXmOi8JMHnn0VNmAFjWS7mn5tJKChQQHJcAMpY2Q6MYXAbV7xNIKgQbXdwEnuPK1/OvLnz59CjS59Ovbr163YpGAhgoDVzCpToTDBuFQKUGgoO/Dw5Vo84IRGervCNmrFVAA3aTDj/In/m1FYl8BMyMBDwHxjk/f5DAGoX2OcCZQeyJ5MF/wHnghIMNnEYT1LVZNoLEDLYCU85/bShCxBkuMQsKKWYWYIoEFUTgVBNxItILyCgXmYsyjRUGwPI9wNhlTjYVWJaWVCODH6dUUGPyj1igAT8YWfllVhmqSVvCDBgQHLN+QVKfJgIFEECDkB5DgPqVVJUlWkIsOMmBQg5io7LONHAkmS8phMTA/DpTASoMXGJGsVkJmE2ABTWhhtwhGiLaOcAw+AFcBD6H5yvMKDiA3AImFkv5xiYIaUyeKkApy28VNMDduKRW2YfwoDVFwOoOR+DsWWDIY8xiNqGkS7IeIauuRC3Xgw+8VJRQOFV0kw7AExoKm0MABD50QW1CuUAYU/KQ0EEA0wwgAOs/pChGDQQQIGgUFGYYaxxxXIgvXAxcCCqvD1monJ+tmHUcr9+IU1zFCgLH753fSVWNiEAACH5BAkJABgALAAAAACAAIAAAAX+ICaOZGmeaKqubOu+cCzPdG3feK7vfK9CjkpC4isae5DF5fG4JI7Q6CzRrF6I0qwWdVl6H8+tWNy1OsfobMXKVKTfR8Lh2wDA7z5EZNCw2G0QBhZYeDIADAYMhSQGZRcDCIsvAGtLBZICX0sNki4OmoR3lWyKnSsFbAGLC2xLFqYrEWwGiwOtD26wKQisSxN/eJ9sBxC6KggJDQHFiwANZrnG0igAFg0DBRTT29zd3t/g4eLj5OXm5+jp6uvs7e7v8PFRFAmsDaE1ABTM8ioSjk1e2RBwgInAfieStLpAoAaEgl4aIjTxjw0TBzUosIk2cYSBhWDyQWwiseMIAbf+LmCs8W8JR5MYAMxpVZKGPn4wTwK8cDCnDwoNlgzA57Oo0aNIkypdyrSp06dQo0qdSrWq1atYrUKI0GvBsqwpJPSyskAAWBONbjUh6pRChQMHspEgsHNYpKgWNF2IFiCllZVPGaTUhmGCXy8DolbQVCWCiLqMF0QdqykxBshsJEM1zPiRiAmd2XCCSqWzYwwODgeMSpfxgbsIZoZegNNpyyoHzI6o2PlCKakIAjSoEOAuCYKtFvw+SwKCtQULKliozby69evYs2vfzr279+/gw4vHToBCzezVDDc58BU7hGetJpzvSCEAH7k0goaeQL1foyVVqCJDWildcFpHmXT+RksMA4QG4AEwNXjLAcC0AICDTSxhXD8QYOYbDBCo1sRy8tDll24veFjFhvJc6BdhL6CC4QQwFRCaZTBkctiCHcnRGYkuROBgBT4xoARubFnYF2MVVGgSABJEkIACTsrAQAKGRYfieFx26eWXYIYpJlgKPNNFAUDeQYECMHoDgIxMVAEYHBDU48UCSepSWoZW8JgGBBJq0pM0gn3RSn9aJODgfLDsGZqfYnTo4IHScOYXpWIkmNJo0xzp4CVp6LgfN0EdNmcMVcJgYmigTmOBam26sJUSF/SRn195SpLEkFbSysQmiKrAAGREdkPBSF/wF0NsADpS6wzIfVFAsLBKEFCqFwlQi4Kial2w5QtAVNBAAmlys6YBCrD4AmWthMFciBgW+65q8jJnaWcCVveqg+pm5UxKg77LrRcHQHodAxYUkIAB/Y55RwgAIfkECQkAGAAsAAAAAIAAgAAABf4gJo5kaZ5oqq5s675wLM90bd94ru98z0IAn3AoRAwujwKEyGzSjo/LJeGsWlUUJDIavHq9BG300v2anVBk5MxuIhqP5LJNHwJ1EEL9htiXEBVICw5+MQILDwsChQADUY8WhS4QUlEHc3USj1oHZZIpEmIXDH4Om496nyoEmxeYdAaiUa+qJw5bCoUIB6JUtSsECn2SDAePDbS/yiYQCgqLy9HS09TV1tfY2drb3N3e3+DhMgQGAc/idARpcQsS6GYClVqVhO9WBLynm+72KwoJBRQkc1FAlphE/VIAgKNlQSoYlE6JQgItYYkAsibI0GTwUZQAFk3kE0UhhoKOov7WhBwBQGKcii7iuTwIcuUIRBMfTpI38wLMlbdONZgRYeajBZ5sFtg0YViMXShH2TQhIEICBUlhMMAp0cBUIggSiBpA6isTCBKc6TTLtq3bt3Djyp1Lt67du3jz6t3Lt28/CgYSJLBQ0m8LCGLjaEkw0PAICAs6Nu3bLIKDnxgCGa3Ad6viBwnKsEIZZW3dMDwvqMQQlHQ9vBG2iJqTmLQvvAwlQitKWrXeCjPLxjKKxGve1ps6iUCQWqLTu5BlRRoRu2dNvW84TWe5VFaSrHgpPGtswBgn445XAGBgwAID8Onjy59Pv779+/jz69/Pv7///wCqgkAAAxwwQQFl5f6ngDGfPXBdW82cU4MmY5zy4FcWVJJIghDlIxEShX2FnBQXhPjCSRUe5NtXYehzwVAx8PbZWGYZ4FIUz7WQAHEIiWiUiS0EwOMANaLUWAoM8LidTZQYBGMM64hyQI4r2ZjTDFB9yA9bCnA1AJAwvHHKAhyyBQAFEpg2AwMWJODAlgHGKeecdNZp551yQmBBAQNcBV8bfy5zCE8TgHkGAw0gcUAER6rCgGzJGeoFivMsQOUvEzSHBGdttKgikdIkSdylVhQ0E2aqZEgaqlZkOtOSv1jAI5xfcCXLhbUIwKOkVQDXUS7RADCSRBqtGUEDFTigZguUjhloIVa6RGsLAFfwNg96MWgmyrTKVCcKrC5g5BKr6iFH5jUCJBpFAbyuYhRSNEAggALtSvPsCkKiRK5h3b16344oAVvfcB0t6xgEw4rB6X3xyGKpfgysU0Gj8wUjEJ7KhAAAIfkECQkAGAAsAAAAAIAAgAAABf4gJo5kaZ5oqq5s675wLM90bd94ru987//AYEtRKUiEyKRM8rg8HgyldIpqOJ0JqrYFYSgYkJu1+chuzyZE4nK9FAg1xRWKrosEh/n1IKhJCgV9dmgEeWRzTXCDizMVeodOFYsAEgFHjCwEj4hOimgQA2QFmCsKh6dzCnYOepekJxaoshZ2jocBrygGso8GdhF6vrkmDJuoUXUIhhcTYcMmE8ZXE4sEAQ0Bzs8lAtJNgtvhGLHGtOLnAgunC+Dn4pQWEQ7t7vX29/j5+vv8/f7/AFMAoIAgICYFDZ5cOJDNIBoABRQeWkDB4ZYEvB4s0GZxBQQFCjzJ6JbxgpmOKv4kHCBzMkZEbxc4oiyBgE0TJ+ZiLIBJZ+YJB2TILJixEqYrnyTW3CQDQMaEkk2QISVBTiI1GUqlHWg6lQQCdalmUIAaoasJCk8X5pQRIOMArmZLEKh4I8CmBgXjBmFQoGgDA3D1Ch5MuLDhw4gTK17MuLHjx5AjS55MufILLwboWVYhIK2TBao2q6h6CldlCALoliiWMXRkAG0/00sobajkCKhU14Sq2jECVBcajBhrNDKTTcN5Hm0sQNaBEQCKZsz7GILNOS0xShMu2YCeAxyV8brQG7KAhAcSUB/BYCcqzaJJAIgQTWMCkfFTQJCZv7///wAGKOCABBZo4IEIJv6o4IIM4kCAAwlYEliAEBSgxwJSFUYBBfzBAMAAm1yQoV4SuHdBABO+AJQxtgl23FKSyBBdSctNFR0nD9SYCVSmxcXaIy258CMvZZFoTIww/OaNA4JRYEyPMICYEX5djaEHlS00Z0yQZn3VSg2soDJAh11B4MAAA9x3gwRSLoTigQhs2OCcdNZp55145ingRyCR6R9s152Y4icGBGDAeu7Yoscoi4TJxgVM1rPLI00IU4cFOK4VTn16ODGAHRAscwh45wBgzE2DSkESpfC9AkFGT/iZhBy8uBaOqBfaMaQeIz4DDC9QxkCBASHZkNYpV50DAaeHNCPWsRcMgGULTk52Wl44CLTZBF5iSbcHoi8Q0Ka0+UgQQQER2BoDbahwmSSHh+0WYqqbacnLtJvtegq48c24SbIArnjKA+r+lxUZkRIogRUXVNCrnhBLEQIAOw==";
    this.loader.appendChild(this.loaderimage);
    this.loader.style.visibility = "visible";
    a = window.devicePixelRatio || 1;
    this.loaderimage.style.top = this.canvas.height / (2 * a) - 64 + "px";
    this.loaderimage.style.left = this.canvas.width / (2 * a) - 64 + "px";
    this.addEventListener(ERROR_EVENT, function(a) {
        e.loader.style.display = "None"
    }
    );
    return !0
}
;
METADATA.BaseViewer3D.prototype.load = function(a, b) {
    return this.loadModel(a, null , b)
}
;
METADATA.BaseViewer3D.prototype.uninitialize = function(a) {
    this.container && this.container.parentNode.removeChild(this.container)
}
;
METADATA.BaseViewer3D.prototype.detectWebGL = function() {
    if (window.WebGLRenderingContext) {
        for (var a = document.createElement("canvas"), b = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"], c = !1, e = 0; 4 > e; e++)
            try {
                if ((c = a.getContext(b[e])) && "function" == typeof c.getParameter)
                    return 1
            } catch (d) {}
        return 0
    }
    return -1
}
;
METADATA.BaseViewer3D.ErrorCodes = {
    UNKNOWN_FAILURE: 1,
    BAD_DATA: 2,
    NETWORK_FAILURE: 3,
    NETWORK_ACCESS_DENIED: 4,
    NETWORK_FILE_NOT_FOUND: 5,
    NETWORK_SERVER_ERROR: 6,
    NETWORK_UNHANDLED_RESPONSE_CODE: 7
};
METADATA.BaseViewer3D.prototype.resize = function() {
    var a = window.devicePixelRatio || 1;
    this.loaderimage.style.top = this.canvas.clientHeight * a / 2 - 64 + "px";
    this.loaderimage.style.left = this.canvas.clientWidth * a / 2 - 64 + "px";
    return this.impl.resize(this.container.clientWidth, this.container.clientHeight)
}
;
METADATA.BaseViewer3D.prototype.loadModel = function(a, b, c) {
    var e = this;
    return this.impl.loadSvf(a, b, function() {
        e.loader.style.display = "None";
        c && c()
    }
    )
}
;
METADATA.BaseViewer3D.prototype.getCamera = function() {
    return this.impl.camera
}
;
METADATA.BaseViewer3D.prototype.setCameraFromArray = function(a) {
    this.impl.setCameraFromArray(a)
}
;
METADATA.BaseViewer3D.prototype.setCameraFromFile = function() {
    this.impl.initCamera(this.impl.svf)
}
;
METADATA.BaseViewer3D.prototype.getProperties = function(a, b) {
    this.impl.svfloader.getProperties(a, b)
}
;
METADATA.BaseViewer3D.prototype.getObjectTree = function(a) {
    this.impl.svfloader.getObjectTree(a)
}
;
METADATA.BaseViewer3D.prototype.setCanvasClickBehavior = function(a) {
    this.impl.controls.setClickBehavior(a)
}
;
METADATA.BaseViewer3D.prototype.isolate = function(a) {
    Array.isArray(a) ? this.impl.visibilityManager.isolateMultiple(a) : this.impl.visibilityManager.isolate(a)
}
;
METADATA.BaseViewer3D.prototype.isolateById = function(a) {
    function b(b) {
        (e = Array.isArray(a) ? d.impl.getNodesByIds(a) : d.impl.getNodesByIds([a])) && d.isolate(e)
    }
    function c(a) {
        this.getObjectTree(b);
        d.removeEventListener(GEOMETRY_LOADED_EVENT, c)
    }
    var e = []
      , d = this;
    this.impl.svf && this.impl.svf.loadDone ? this.getObjectTree(b) : this.addEventListener(GEOMETRY_LOADED_EVENT, c)
}
;
METADATA.BaseViewer3D.prototype.setBackgroundColor = function(a, b, c, e, d, g) {
    this.impl.setClearColors(a, b, c, e, d, g)
}
;
METADATA.BaseViewer3D.prototype.toggleSelect = function(a) {
    this.impl.selector.toggleSelectionId(a)
}
;
METADATA.BaseViewer3D.prototype.select = function(a) {
    "number" == typeof a && (a = [a]);
    this.impl.selector.setSelectionIds(a)
}
;
METADATA.BaseViewer3D.prototype.deselect = function(a) {
    throw Error("not implemented yet");
}
;
METADATA.BaseViewer3D.prototype.clearSelection = function() {
    this.impl.selector.clearSelection()
}
;
METADATA.BaseViewer3D.prototype.hide = function(a) {
    Array.isArray(a) ? this.impl.visibilityManager.hideMultiple(a) : this.impl.visibilityManager.hide(a)
}
;
METADATA.BaseViewer3D.prototype.show = function(a) {
    Array.isArray(a) ? this.impl.visibilityManager.showMultiple(a) : this.impl.visibilityManager.show(a)
}
;
METADATA.BaseViewer3D.prototype.showAll = function() {
    this.impl.visibilityManager.isolateNone()
}
;
METADATA.BaseViewer3D.prototype.hideAll = function() {
    throw Error("not implemented yet");
}
;
METADATA.BaseViewer3D.prototype.toggleVisibility = function(a) {
    this.impl.visibilityManager.toggleVisibility(a)
}
;
METADATA.BaseViewer3D.prototype.areAllVisible = function() {
    return this.impl.visibilityManager.areAllVisible()
}
;
METADATA.BaseViewer3D.prototype.explode = function(a) {
    this.impl.explode(a)
}
;
METADATA.BaseViewer3D.prototype.setQualityLevel = function(a, b) {
    this.impl.togglePostProcess(a, b)
}
;
METADATA.BaseViewer3D.prototype.setEnvironmentMap = function(a) {
    this.impl.setCubeMap(a)
}
;
METADATA.BaseViewer3D.prototype.setGhosting = function(a) {
    this.impl.toggleGhosting(a)
}
;
METADATA.BaseViewer3D.prototype.setProgressiveRendering = function(a) {
    this.impl.toggleProgressive(a)
}
;
METADATA.BaseViewer3D.prototype.getNavigationMode = function() {
    if ("getNavigationMode" in this.impl.controls)
        return this.impl.controls.getNavigationMode()
}
;
METADATA.BaseViewer3D.prototype.setNavigationMode = function(a) {
    "setNavigationMode" in this.impl.controls && this.impl.controls.setNavigationMode(a)
}
;
METADATA.BaseViewer3D.prototype.getFOV = function() {
    return "getFOV" in this.impl.controls ? this.impl.controls.getFOV() : this.impl.camera.fov
}
;
METADATA.BaseViewer3D.prototype.setFOV = function(a) {
    "setFOV" in this.impl.controls ? this.impl.controls.setFOV(a) : (this.impl.camera.fov = a,
    this.impl.syncCamera())
}
;
METADATA.BaseViewer3D.prototype.getFocalLength = function() {
    if ("getFocalLength" in this.impl.controls)
        return this.impl.controls.getFocalLength();
    var a = THREE.Math.degToRad(this.impl.camera.fov);
    return Math.round(12 / Math.tan(.5 * a))
}
;
METADATA.BaseViewer3D.prototype.setFocalLength = function(a) {
    "setFocalLength" in this.impl.controls ? this.impl.controls.setFocalLength(a) : (this.impl.camera.setLens(a),
    this.impl.syncCamera())
}
;
METADATA = METADATA || {};
METADATA.Viewer2D = function(a, b) {
    METADATA.Viewer.call(this, a, b);
    b || (b = {});
    b.domElement = this.container.id;
    this.impl = new Viewer2DImpl(b)
}
;
METADATA.Viewer2D.prototype = Object.create(METADATA.Viewer.prototype);
METADATA.Viewer2D.prototype.constructor = METADATA.Viewer2D;
METADATA.Viewer2D.prototype.initialize = function() {
    return this.impl.initialize()
}
;
METADATA.Viewer2D.prototype.load = function(a, b) {
    return this.impl.load(a) ? (b && b(),
    !0) : !1
}
;
METADATA.Viewer2D.prototype.uninitialize = function() {
    this.impl.uninitialize();
    this.container && this.container.parentNode.removeChild(this.container)
}
;
METADATA.Viewer2D.prototype.setCameraFromArray = function(a) {}
;
METADATA.Viewer2D.prototype.setCameraFromFile = function() {}
;
METADATA = METADATA || {};
METADATA.Document = function(a) {
    function b(a) {
        if (a) {
            var e = a.children ? a.children.length : 0;
            if ("geometry" === a.type && "3d" === a.role && e) {
                for (var d = 0, g = 0; g < e; g++) {
                    var f = a.children[g];
                    if (f && "view" === f.type && "3d" === f.role) {
                        if (f.hasOwnProperty("_parent"))
                            throw Error("json 3d view already has _parent property: " + f);
                        f._parent = a;
                        d++
                    }
                }
                1 === d && (d = 0);
                if (a.hasOwnProperty("_viewCount"))
                    throw Error("json 3d geometry already has _viewCount property: " + a);
                a._viewCount = d
            } else if (0 < e)
                for (g = 0; g < e; g++)
                    b(a.children[g])
        }
    }
    this.myData = 
    a;
    b(a)
}
;
METADATA.Document.prototype.constructor = METADATA.Document;
METADATA.Document.load = function(a, b, c, e) {
    try {
        var d = new XMLHttpRequest;
        if (b.oauthNone)
            d.open("GET", a, !0),
            d.withCredentials = !0,
            d.setRequestHeader("Access-Control-Allow-Credentials", !0);
        else if (b.oauth0)
            encodeURIComponent(b.access_token),
            d.open("GET", a, !0);
        else {
            d.open("GET", a, !0);
            var g = b.getAuthHeader("GET", a);
            d.setRequestHeader("Authorization", g)
        }
        d.setRequestHeader("Access-Control-Allow-Origin", "*");
        0 == b.oauthNone && (d.responseType = "json");
        d.onload = function(a) {
            d.status && 200 === d.status ? (a = "string" === 
            typeof d.response ? JSON.parse(d.response) : d.response,
            a = new METADATA.Document(a),
            c(a)) : e("An unexpected status code was received while loading the bubble: " + d.status)
        }
        ;
        d.onerror = function(a) {
            e("An error occurred while loading the bubble with status code: " + d.status)
        }
        ;
        d.ontimeout = function(a) {
            e("A timeout occurred while loading the bubble with status code: " + d.status)
        }
        ;
        d.send()
    } catch (f) {
        e("An exception occurred while loading the model data: " + f.toString())
    }
}
;
METADATA.Document.prototype.getRootItem = function() {
    return this.myData
}
;
METADATA.Document.prototype.getItemById = function(a) {
    function b(c) {
        if (!c)
            return null ;
        for (var e in c) {
            if ("guid" === e && c[e] === a)
                return c;
            if (null  !== c[e] && "object" == typeof c[e] && "_" !== e.charAt(0)) {
                var d = b(c[e]);
                if (d)
                    return d
            }
        }
        return null 
    }
    return b(this.myData)
}
;
METADATA.Document.getSubItemsWithProperties = function(a, b, c) {
    var e = [];
    if (!a)
        return [];
    for (var d = a.children ? a.children.length : 0, g = 0; g < d; g++) {
        var f = a.children[g], k;
        a: {
            k = b;
            var h = void 0;
            for (h in k)
                if (!(h in f) || k[h] !== f[h]) {
                    k = !1;
                    break a
                }
            k = !0
        }
        k && e.push(f);
        c && e.push.apply(e, METADATA.Document.getSubItemsWithProperties(f, b, c))
    }
    return e
}
;
METADATA = METADATA || {};
METADATA.ViewingApplication = function(a, b) {
    this.appContainerId = a;
    this.container = document.getElementById(a);
    this.options = b;
    this.myRegisteredViewers = {};
    this.urn = this.myCurrentViewer = this.myDocument = null 
}
;
METADATA.ViewingApplication.prototype.k3D = "3D";
METADATA.ViewingApplication.prototype.k2D = "2D";
METADATA.ViewingApplication.prototype.registerViewer = function(a, b, c) {
    this.myRegisteredViewers[a] = {};
    this.myRegisteredViewers[a].class = b;
    this.myRegisteredViewers[a].config = c
}
;
METADATA.ViewingApplication.prototype.getViewerContainerId = function() {
    return this.appContainerId
}
;
METADATA.ViewingApplication.prototype.getViewer = function(a) {
    if (a in this.myRegisteredViewers) {
        this.setCurrentViewer(null );
        var b = this.myRegisteredViewers[a].config;
        a = new this.myRegisteredViewers[a].class(this.getViewerContainerId(),b);
        if (a.initialize())
            return this.setCurrentViewer(a),
            a
    }
    return null 
}
;
METADATA.ViewingApplication.prototype.setCurrentViewer = function(a) {
    this.myCurrentViewer && this.myCurrentViewer.uninitialize();
    this.myCurrentViewer = a
}
;
METADATA.ViewingApplication.prototype.getCurrentViewer = function() {
    return this.myCurrentViewer
}
;
METADATA.ViewingApplication.prototype.loadDocument = function(a, b) {
    var c = this;
    if (-1 != a.indexOf("urn:")) {
        var e = a.substr(4);
        METADATA.Document.load(VIEWING_URL + "/bubbles/" + e, auth, function(a) {
            c.myDocument = a;
            c.onDocumentLoaded(a);
            b && b(a)
        }
        , function(a) {
            var b = document.getElementById(c.getViewerContainerId());
            b && AlertBox.displayError(b, "LOAD Error: " + a)
        }
        )
    }
}
;
METADATA.ViewingApplication.prototype.onDocumentLoaded = function(a) {
    console.log(a)
}
;
METADATA.ViewingApplication.prototype.selectItem = function(a, b) {
    var c, e, d;
    "geometry" === a.type && "3d" === a.role ? (c = METADATA.Document.getSubItemsWithProperties(a, {
        mime: "application/METADATA-svf"
    }, !1),
    e = this.k3D) : "view" === a.type && "3d" === a.role ? (c = METADATA.Document.getSubItemsWithProperties(a._parent, {
        mime: "application/METADATA-svf"
    }, !1),
    e = this.k3D,
    d = a) : "geometry" === a.type && "2d" === a.role && (c = METADATA.Document.getSubItemsWithProperties(a, {
        role: "tileRoot"
    }, !0),
    e = this.k2D);
    if (c && 0 < c.length && (c = c[0].urn)) {
        var g = 
        this
          , f = this.myCurrentViewer && this.urn === c
          , k = null 
          , k = d && d.camera ? function() {
            g.myCurrentViewer.setCameraFromArray(d.camera);
            b && b(g.myCurrentViewer, a)
        }
         : f ? function() {
            g.myCurrentViewer.setCameraFromFile();
            b && b(g.myCurrentViewer, a)
        }
         : function() {
            b && b(g.myCurrentViewer, a)
        }
          , h = !1;
        f ? (k && k(),
        h = !0) : (this.urn = null ,
        (e = this.getViewer(e)) && e.load(c, k) && (this.urn = c,
        h = !0));
        if (h)
            return this.onItemSelected(a),
            !0
    }
    return !1
}
;
METADATA.ViewingApplication.prototype.onItemSelected = function(a) {
    console.log("Selected URL: http://" + location.host + location.pathname + "?document=urn:" + this.myDocument.getRootItem().guid + "&item=" + a.guid)
}
;
METADATA.ViewingApplication.prototype.selectItemById = function(a, b) {
    var c = this.myDocument.getItemById(a);
    return c ? this.selectItem(c, b) : !1
}
;
METADATA.GuiViewer3D = function(a, b) {
    METADATA.BaseViewer3D.call(this, a, b)
}
;
METADATA.GuiViewer3D.prototype = Object.create(METADATA.BaseViewer3D.prototype);
METADATA.GuiViewer3D.prototype.constructor = METADATA.GuiViewer3D;
METADATA.GuiViewer3D.kDefaultDocStructureConfig = {
    click: {
        onObject: ["isolate"]
    },
    clickCtrl: {
        onObject: ["toggleVisibility"]
    }
};
METADATA.GuiViewer3D.prototype.initialize = function() {
    if (!METADATA.BaseViewer3D.prototype.initialize.call(this))
        return !1;
    var a = this
      , b = a.container
      , c = this.menuplacer = document.createElement("div");
    c.className = "toolbar-menuplacer";
    //c.style.display = "none";
    var e = this.menu = document.createElement("ul");
    e.className = "toolbar-menu";
    c.appendChild(e);
    b.appendChild(c);
    c = document.createElement("div");
    c.className = "toolbarcentertop";
    b.appendChild(c);
    this.toolbar = document.createElement("div");
    this.toolbar.className = "toolbar";
    c.appendChild(this.toolbar);
    this.optionToggles = [];
    this.initFocalLengthOverlay();
    DockingPanel.initialize(a);
    this.initNavButtons();
    this.structurebutton = this.addMenuButton("Model Structure", RESOURCE_ROOT + "gui/structure_icon.png", function(b) {
        a.docstructure && a.showDocumentStructurePanel(!a.docstructure.isVisible())
    }
    );
    this.initExplodeSlider();
    var c = document.createElement("li")
      , d = document.createElement("img");
    d.src = RESOURCE_ROOT + "gui/debug_icon.png";
    c.appendChild(d);
    this.menuoptions = document.createElement("ul");
    this.menuoptions.style.width = 
    "180px";
    this.menuoptions.style.paddingTop = "4px";
    this.menuoptions.style.paddingBottom = "4px";
    c.appendChild(this.menuoptions);
    e.appendChild(c);
    if (ENABLE_DEBUG) {
        var g = this.renderoptions = new RenderOptionsPanel(a);
        this.addMenuButton("Rendering Options", RESOURCE_ROOT + "gui/options_icon.png", function(b) {
            a.showRenderingOptions(!g.dockPanel.isVisible())
        }
        )
    }
    this.initSearchBox();
    this.initColorPicker();
    this.initViewCube();
    var e = -1 != window.navigator.platform.indexOf("Android")
      , c = !e
      , f = !e;
    a.setQualityLevel(c, f);
    this.addOptionToggle("Ambient Occlusion", 
    c, function(b) {
        a.setQualityLevel(b.target.checked, f)
    }
    );
    this.addOptionToggle("Hide Ghosting Effect", !1, function(b) {
        a.setGhosting(!b.target.checked)
    }
    );
    this.addOptionToggle("Progressive Rendering", !0, function(b) {
        a.setProgressiveRendering(b.target.checked)
    }
    );
    this.addOptionToggle("Environment Map", !1, function(b) {
        b.target.checked ? a.setEnvironmentMap("environments/sky_px.jpg environments/sky_nx.jpg environments/sky_py.jpg environments/sky_ny.jpg environments/sky_pz.jpg environments/sky_nz.jpg".split(" ")) : 
        a.setEnvironmentMap()
    }
    );
    ENABLE_DEBUG && (this.initFPSStats(),
    this.initModelStats());
    this.progressbar = new ProgressBar(this.container);
    this.addEventListener(PROGRESS_UPDATE_EVENT, function(b) {
        void 0 !== b.percent && a.progressbar.setPercent(b.percent)
    }
    , !1);
    this.propertygrid = new PropertyPanel(a);
    this.addEventListener(ERROR_EVENT, function(a) {
        var c = "", d;
        for (d in a)
            a.hasOwnProperty(d) && (c += d + ": " + a[d] + "\n");
        AlertBox.displayError(b, "An error occurred:\n" + a.message + "\n\nTechnical details:\n" + c)
    }
    );
    this.selectionActive = 
    !1;
    this.addEventListener(SELECTION_CHANGED_EVENT, function(b) {
        a.selectionActive = 0 < b.dbIdArray.length
    }
    );
    this.initEscapeHandlers();
    this.populateOptionsPanel();
    return !0
}
;
METADATA.GuiViewer3D.prototype.addOptionToggle = function(a, b, c) {
    a = {
        tooltip: a,
        checked: b,
        onchange: c
    };
    this.optionToggles.push(a);
    return a
}
;
METADATA.GuiViewer3D.prototype.populateOptionsPanel = function() {
    for (var a = 0; a < this.optionToggles.length; a++) {
        var b = this.optionToggles[a]
          , c = document.createElement("li")
          , e = document.createElement("input");
        e.type = "checkbox";
        c.appendChild(e);
        var d = document.createElement("label");
        d.innerHTML = b.tooltip;
        c.appendChild(d);
        this.menuoptions.appendChild(c);
        e.checked = b.checked;
        e.onchange = b.onchange
    }
}
;
METADATA.GuiViewer3D.prototype.addMenuButton = function(a, b, c) {
    var e = document.createElement("li");
    e.setAttribute("tooltip", a);
    a = document.createElement("img");
    a.src = b;
    e.appendChild(a);
    this.menu.appendChild(e);
    a.addEventListener("click", c);
    return a
}
;
METADATA.GuiViewer3D.prototype.initColorPicker = function() {
    var a = document.createElement("li");
    a.className = "color-picker";
    var b = document.createElement("div");
    b.className = "backgroundButton";
    var c = document.createElement("div");
    c.className = "cp-small thecolorpicker";
    b.appendChild(c);
    a.appendChild(b);
    var e = document.createElement("label");
    e.innerHTML = "Background Color";
    a.appendChild(e);
    this.menuoptions.appendChild(a);
    var d = this;
    ColorPicker(c, function(a, c, e) {
        b.style.background = a;
        a = parseInt(a.slice(1), 16);
        d.setBackgroundColor(e.r, e.g, e.b, .33 * (a >> 16 & 255), .33 * (a >> 8 & 255), .33 * (a & 255))
    }
    )
}
;
METADATA.GuiViewer3D.prototype.initFPSStats = function() {
    var a = new Stats;
    a.setMode(1);
    a.domElement.style.position = "absolute";
    a.domElement.style.bottom = "0px";
    a.domElement.style.right = "0px";
    a.domElement.style.visibility = "hidden";
    a.domElement.style["z-index"] = 1;
    this.container.appendChild(a.domElement);
    this.impl.stats = a;
    this.addOptionToggle("FPS Statistics", !1, function(b) {
        a.domElement.style.visibility = b.target.checked ? "visible" : "hidden"
    }
    )
}
;
METADATA.GuiViewer3D.prototype.initModelStats = function() {
    var a = this
      , b = document.createElement("div");
    b.className = "statspanel";
    this.container.appendChild(b);
    this.addEventListener(PROGRESS_UPDATE_EVENT, function(c) {
        var e = a.impl
          , d = ""
          , g = e.svf;
        g && (d += "Geom&nbsp;Polys:&nbsp;" + g.geomPolyCount + "<br>",
        d += "Instance&nbsp;Polys:&nbsp;" + g.instancePolyCount + "<br>",
        d += "Scenes:&nbsp;" + e.modelQueue.geomScenes.length + "<br>");
        d += "# " + (c.message || "");
        b.innerHTML = d
    }
    );
    this.addOptionToggle("Model Stats", !1, function(a) {
        b.style.visibility = 
        a.target.checked ? "visible" : "hidden"
    }
    )
}
;
METADATA.GuiViewer3D.prototype.initExplodeSlider = function() {
    var a = this
      , b = this.explodeslider = document.createElement("input");
    b.className = "slider";
    b.type = "range";
    b.min = "0";
    b.max = "100";
    b.value = "0";
    b.width = "200";
    this.toolbar.appendChild(b);
    b.addEventListener("input", function(c) {
        a.explode(b.value / 100)
    }
    );
    b.addEventListener("change", function(c) {
        a.explode(b.value / 100)
    }
    );
    this.explodebutton = this.addMenuButton("Explode Model", RESOURCE_ROOT + "gui/explode_icon.png", function(c) {
        a.showExplodeSlider("hidden" == b.style.visibility || 
        "" == b.style.visibility)
    }
    );
    b.addEventListener("keyup", function(b) {
        27 === b.keyCode && a.canvas.focus()
    }
    )
}
;
METADATA.GuiViewer3D.prototype.showExplodeSlider = function(a) {
    a ? (this.explodebutton.style.opacity = .4,
    this.explodeslider.style.visibility = "visible") : (this.explodebutton.style.opacity = 1,
    this.explodeslider.style.visibility = "hidden")
}
;
METADATA.GuiViewer3D.prototype.showRenderingOptions = function(a) {
    this.renderoptions.dockPanel.setVisible(a)
}
;
METADATA.GuiViewer3D.prototype.G_Pan = function() {
    var a = this;
    a.setNavigationMode(a.getNavigationMode() === NAVIGATION_MODE.PAN ? NAVIGATION_MODE.ORBIT : NAVIGATION_MODE.PAN);
}
;
METADATA.GuiViewer3D.prototype.G_Orbit = function() {
    var a = this;
    a.setNavigationMode(NAVIGATION_MODE.ORBIT);
}
;
METADATA.GuiViewer3D.prototype.G_Zoom = function() {
    var a = this;
    a.setNavigationMode(a.getNavigationMode() ===
    NAVIGATION_MODE.DOLLY ? NAVIGATION_MODE.ORBIT : NAVIGATION_MODE.DOLLY);
}
;
METADATA.GuiViewer3D.prototype.G_isolateById = function(a) {
}
;
METADATA.GuiViewer3D.prototype.initNavButtons = function() {
    var a = this
      , b = this.addMenuButton("Pan", RESOURCE_ROOT + "gui/pan_icon.png", function(b) {
        a.setNavigationMode(a.getNavigationMode() === NAVIGATION_MODE.PAN ? NAVIGATION_MODE.ORBIT : NAVIGATION_MODE.PAN)
    }
    );
    b.style.opacity = .4;
    var c = this.addMenuButton("Orbit", RESOURCE_ROOT + "gui/turntable_icon.png", function(b) {
        a.setNavigationMode(NAVIGATION_MODE.ORBIT)
    }
    );
    c.style.opacity = 1;
    var e = this.addMenuButton("Zoom", RESOURCE_ROOT + "gui/magnify_box_icon.png", function(b) {
        a.setNavigationMode(a.getNavigationMode() === 
        NAVIGATION_MODE.DOLLY ? NAVIGATION_MODE.ORBIT : NAVIGATION_MODE.DOLLY)
    }
    );
    e.style.opacity = .4;
    this.addMenuButton("Reset Model", RESOURCE_ROOT + "gui/transreset_icon.png", function(b) {
        a.explode(0);
        a.explodeslider.value = 0;
        a.isolate(null )
    }
    );
    a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "gui/turntable_cur.cur), wait";
    this.navigationMode = NAVIGATION_MODE.ORBIT;
    a.addEventListener(NAVIGATION_MODE_CHANGED_EVENT, function(d) {
        switch (d.value) {
        case NAVIGATION_MODE.ORBIT:
            c.style.opacity = 1;
            e.style.opacity = .4;
            b.style.opacity = 
            .4;
            a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "gui/turntable_cur.cur), wait";
            break;
        case NAVIGATION_MODE.DOLLY:
            c.style.opacity = .4;
            e.style.opacity = 1;
            b.style.opacity = .4;
            a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "gui/dolly_cur.cur), wait";
            break;
        case NAVIGATION_MODE.PAN:
            c.style.opacity = .4;
            e.style.opacity = .4;
            b.style.opacity = 1;
            a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "gui/pan_cur.cur), wait";
            break;
        case NAVIGATION_MODE.FOV:
            a.canvas.style.cursor = "url(" + RESOURCE_ROOT + "gui/fov_cur.cur), wait";
            break;
        default:
            a.canvas.style.cursor = 
            "auto"
        }
        a.navigationMode = d.value;
        a.showFocalLengthOverlay(a.navigationMode === NAVIGATION_MODE.FOV)
    }
    )
}
;
METADATA.GuiViewer3D.prototype.initEscapeHandlers = function() {
    var a = this;
    this.addEventListener(ESCAPE_EVENT, function(b) {
        if (a.renderoptions && a.renderoptions.dockPanel.isVisible())
            a.renderoptions.dockPanel.setVisible(!1);
        else if ("hidden" !== a.explodeslider.style.visibility && "" !== a.explodeslider.style.visibility)
            a.showExplodeSlider(!1);
        else if (a.navigationMode !== NAVIGATION_MODE.ORBIT)
            a.setNavigationMode(NAVIGATION_MODE.ORBIT);
        else if (a.selectionActive)
            a.clearSelection();
        else if (!a.areAllVisible())
            a.showAll();
        else if (!AlertBox.dismiss())
            for (b = 0; b < a.dockingPanels.length; ++b) {
                var c = a.dockingPanels[b];
                if ("none" !== c.container.style.display && "" !== c.container.style.display) {
                    c.container === a.docstructure ? a.showDocumentStructurePanel(!1) : c.setVisible(!1);
                    break
                }
            }
    }
    )
}
;
METADATA.GuiViewer3D.prototype.initViewCube = function() {
    this.viewcube = document.createElement("div");
    this.viewcube.className = "viewcube";
    this.container.appendChild(this.viewcube);
    ViewCube(this.viewcube, this);
    var a = document.createDocumentFragment()
      , b = this;
    b.viewcube.style.display = "none";
    var c = this.homeViewContainer = document.createElement("div");
    c.className = "homeViewWrapper";
    var e = document.createElement("img");
    e.className = "homeView";
    e.src = RESOURCE_ROOT + "gui/resetview_icon.png";
    e.style.cursor = "pointer";
    c.appendChild(e);
    c.style.width = "auto";
    e.addEventListener("click", function() {
        b.impl.controls.goHome()
    }
    );
    this.addOptionToggle("View Cube", !1, function(a) {
        b.viewcube.style.display = a.target.checked ? "block" : "none";
        b.homeViewContainer.style.width = a.target.checked ? b.viewcube.style.width : "auto"
    }
    );
    this.viewcube.appendChild(a);
    this.container.appendChild(c)
}
;
METADATA.GuiViewer3D.prototype.initSearchBox = function() {
    var a = document.createElement("li")
      , b = document.createElement("input");
    b.type = "search";
    b.results = 5;
    b.placeholder = "Search";
    b.incremental = "incremental";
    b.autosave = this.container.id + "search_autosave";
    a.appendChild(b);
    this.menu.appendChild(a);
    var c = this;
    b.addEventListener("search", function(a) {
        stderr("search " + b.value);
        c.impl.svfloader.searchProperties(b.value, function(a) {
            c.isolate(c.impl.getNodesByIds(a))
        }
        )
    }
    );
    b.addEventListener("keypress", function(a) {
        27 === 
        a.keyCode && setTimeout(function() {
            "" !== b.value && (b.value = "")
        }
        , 0)
    }
    );
    this.menu.addEventListener("mouseleave", function(a) {
        function d() {
            clearTimeout(g)
        }
        var g;
        c.menu.addEventListener("mouseenter", d);
        g = setTimeout(function() {
            c.menu.removeEventListener("mouseenter", d);
            document.activeElement === b && c.canvas.focus()
        }
        , 2E3)
    }
    )
}
;
METADATA.GuiViewer3D.prototype.showDocumentStructurePanel = function(a) {
    this.structurebutton.style.opacity = a ? .4 : 1;
    this.docstructure.setVisible(a)
}
;
METADATA.GuiViewer3D.prototype.createDocumentStructurePanel = function() {
    var a = new DocumentStructurePanel(this);
    a.setClickBehavior(this.config && this.config.docStructureConfig ? this.config.docStructureConfig : METADATA.GuiViewer3D.kDefaultDocStructureConfig);
    this.docstructure = a
}
;
METADATA.GuiViewer3D.prototype.initFocalLengthOverlay = function() {
    var a = this.focallength = document.createElement("div");
    a.className = "focallength";
    var b = document.createElement("table")
      , c = document.createElement("tbody");
    b.appendChild(c);
    a.appendChild(b);
    this.container.appendChild(a);
    var b = c.insertRow(-1)
      , e = b.insertCell(0);
    e.textContent = "Focal Length:";
    e = b.insertCell(1);
    e.textContent = "";
    e.style.width = "4em";
    e.style.textAlign = "right";
    var d = 0
      , g = this;
    this.addEventListener(CAMERA_CHANGE_EVENT, function(a) {
        a = 
        g.getFocalLength();
        d !== a && (d = a,
        e.textContent = a.toString() + " mm")
    }
    );
    a.style.visibility = "hidden"
}
;
METADATA.GuiViewer3D.prototype.showFocalLengthOverlay = function(a) {
    this.focallength && "hidden" !== this.focallength.style.visibility !== a && (this.focallength.style.visibility = a ? "visible" : "hidden")
}
;
METADATA.GuiViewer3D.prototype.load = function(a, b) {
    var c = this;
    return METADATA.BaseViewer3D.prototype.load.call(this, a, function() {
        c.createDocumentStructurePanel();
        b && b()
    }
    )
}
;
